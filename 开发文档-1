# 金鱼智盒卡密授权系统 - 完整开发文档

## 目录

- [1. 项目概述](#1-项目概述)
- [2. 前端开发部分](#2-前端开发部分)
- [3. 后端开发部分](#3-后端开发部分)
- [4. 数据部分](#4-数据部分)
- [5. UI/UX设计部分](#5-uiux设计部分)
- [6. 其他信息](#6-其他信息)

---

## 1. 项目概述

### 1.1 系统简介

金鱼智盒卡密授权系统是一个企业级的软件授权管理平台，采用前后端分离架构，支持账号密码+卡密双重验证机制。系统主要用于Python桌面应用的授权控制，提供完整的卡密生成、分发、激活和管理功能。

### 1.2 核心功能

- **应用管理**：支持多应用管理，每个应用独立的授权策略
- **卡密管理**：批量生成、激活控制、到期管理
- **用户管理**：多角色权限体系，精细化权限控制
- **设备绑定**：硬件指纹识别，防止授权滥用
- **安全控制**：AES-256加密、JWT认证、IP白名单
- **监控审计**：完整的操作日志和安全审计

### 1.3 技术架构

```mermaid
graph TB
    A[前端 React + Next.js] --> B[API网关]
    B --> C[后端 FastAPI]
    C --> D[PostgreSQL 数据库]
    C --> E[Redis 缓存]
    C --> F[文件存储]
    G[Python客户端] --> B
```

---

## 2. 前端开发部分

### 2.1 技术栈说明

#### 核心框架
- **React 18.2.0**：主要UI框架
- **Next.js 13.4.19**：全栈React框架，支持SSR/SSG
- **TypeScript 5.1.6**：类型安全的JavaScript超集

#### UI组件库
- **Ant Design 5.8.6**：企业级UI设计语言
- **Heroicons**：高质量SVG图标库
- **Headless UI**：无样式可访问组件

#### 状态管理与数据获取
- **Axios 1.5.0**：HTTP客户端
- **SWR**：数据获取和缓存
- **React Hook Form**：表单状态管理

#### 样式与动画
- **Tailwind CSS 3.3.3**：原子化CSS框架
- **Framer Motion**：动画库
- **Class Variance Authority**：样式变体管理

#### 工具库
- **Day.js**：日期处理
- **React Hot Toast**：通知组件
- **js-cookie**：Cookie管理

### 2.2 组件结构图

```mermaid
graph TD
    A[App] --> B[Layout]
    B --> C[Header]
    B --> D[Sidebar]
    B --> E[Main Content]
    
    C --> C1[UserMenu]
    C --> C2[ThemeToggle]
    C --> C3[NotificationBell]
    
    D --> D1[Navigation]
    D --> D2[UserInfo]
    
    E --> E1[Dashboard]
    E --> E2[Applications]
    E --> E3[Licenses]
    E --> E4[Users]
    E --> E5[Security]
    
    E1 --> E1A[StatsCards]
    E1 --> E1B[Charts]
    E1 --> E1C[RecentActivities]
    
    E2 --> E2A[ApplicationList]
    E2 --> E2B[ApplicationForm]
    E2 --> E2C[ApplicationStats]
    
    E3 --> E3A[LicenseList]
    E3 --> E3B[LicenseGenerate]
    E3 --> E3C[LicenseActivations]
    
    F[Common Components] --> F1[Button]
    F[Common Components] --> F2[Input]
    F[Common Components] --> F3[Modal]
    F[Common Components] --> F4[Table]
    F[Common Components] --> F5[Form]
```

### 2.3 路由配置

#### 主要路由结构

```typescript
// pages/路由映射
const routes = {
  // 认证相关
  '/login': 'pages/login.tsx',
  '/change-password': 'pages/change-password/index.tsx',
  
  // 主要功能模块
  '/dashboard': 'pages/dashboard.tsx',
  '/applications': 'pages/applications/index.tsx',
  '/applications/[id]': 'pages/applications/[id].tsx',
  '/applications/stats': 'pages/applications/stats.tsx',
  '/applications/monitoring': 'pages/applications/monitoring.tsx',
  
  '/licenses': 'pages/licenses/index.tsx',
  '/licenses/generate': 'pages/licenses/generate.tsx',
  '/licenses/expiring': 'pages/licenses/expiring.tsx',
  '/licenses/activations': 'pages/licenses/activations.tsx',
  
  '/users': 'pages/users/index.tsx',
  '/users/roles': 'pages/users/roles.tsx',
  '/users/logs': 'pages/users/logs.tsx',
  
  '/security': 'pages/security/index.tsx',
  '/security/logs': 'pages/security/logs.tsx',
  '/security/alerts': 'pages/security/alerts.tsx',
  '/security/enhanced': 'pages/security/enhanced.tsx',
  
  // 系统功能
  '/settings': 'pages/settings/index.tsx',
  '/extensions': 'pages/extensions/index.tsx',
  '/monitoring': 'pages/monitoring/index.tsx',
  '/audit': 'pages/audit/index.tsx',
  '/backup': 'pages/backup/index.tsx'
};
```

#### 路由守卫

```typescript
// lib/auth-guard.ts
const authGuard = {
  // 公开路由（无需认证）
  publicRoutes: ['/login', '/404'],
  
  // 需要认证的路由
  protectedRoutes: ['*'],
  
  // 角色权限映射
  roleBasedRoutes: {
    super_admin: ['*'],
    admin: ['/dashboard', '/applications', '/licenses', '/users', '/extensions'],
    user: ['/dashboard', '/profile']
  }
};
```

### 2.4 状态管理方案

#### 全局状态管理

```typescript
// lib/store.ts - 使用Context + useReducer
interface GlobalState {
  user: UserInfo | null;
  theme: 'light' | 'dark' | 'system';
  notifications: Notification[];
  loading: boolean;
}

const initialState: GlobalState = {
  user: null,
  theme: 'system',
  notifications: [],
  loading: false
};

// Actions
type Action = 
  | { type: 'SET_USER'; payload: UserInfo }
  | { type: 'SET_THEME'; payload: 'light' | 'dark' | 'system' }
  | { type: 'ADD_NOTIFICATION'; payload: Notification }
  | { type: 'SET_LOADING'; payload: boolean };
```

#### 数据获取策略

```typescript
// hooks/useApiWithRetry.ts
const useApiWithRetry = <T>(url: string, options?: RequestOptions) => {
  const { data, error, mutate } = useSWR<T>(
    url,
    (url) => api.get(url).then(res => res.data),
    {
      revalidateOnFocus: false,
      revalidateOnReconnect: true,
      errorRetryCount: 3,
      errorRetryInterval: 1000,
      ...options
    }
  );
  
  return {
    data,
    loading: !error && !data,
    error,
    mutate
  };
};
```

### 2.6 应用公告模块实现

#### 2.6.1 前端组件设计

##### 公告状态管理

```typescript
// stores/announcementStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface Announcement {
  id: string;
  title: string;
  content: string;
  type: 'info' | 'warning' | 'error' | 'success';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  targetType: 'all' | 'application' | 'license_rule' | 'user_role';
  targetIds: string[];
  displayType: 'popup' | 'banner' | 'notification';
  isForceRead: boolean;
  startTime: string;
  endTime: string;
  attachments?: {
    name: string;
    url: string;
    size: number;
  }[];
  createdBy: string;
  createdAt: string;
  updatedAt: string;
  status: 'draft' | 'published' | 'expired' | 'deleted';
  readCount: number;
  totalTargets: number;
}

interface AnnouncementState {
  announcements: Announcement[];
  unreadCount: number;
  currentAnnouncement: Announcement | null;
  loading: boolean;
  
  // Actions
  fetchAnnouncements: () => Promise<void>;
  markAsRead: (id: string) => Promise<void>;
  createAnnouncement: (data: Partial<Announcement>) => Promise<void>;
  updateAnnouncement: (id: string, data: Partial<Announcement>) => Promise<void>;
  deleteAnnouncement: (id: string) => Promise<void>;
  setCurrentAnnouncement: (announcement: Announcement | null) => void;
}

export const useAnnouncementStore = create<AnnouncementState>()(
  persist(
    (set, get) => ({
      announcements: [],
      unreadCount: 0,
      currentAnnouncement: null,
      loading: false,
      
      fetchAnnouncements: async () => {
        set({ loading: true });
        try {
          const response = await api.get('/announcements');
          const announcements = response.data.data;
          const unreadCount = announcements.filter(
            (a: Announcement) => !localStorage.getItem(`announcement_read_${a.id}`)
          ).length;
          
          set({ announcements, unreadCount, loading: false });
        } catch (error) {
          console.error('Failed to fetch announcements:', error);
          set({ loading: false });
        }
      },
      
      markAsRead: async (id: string) => {
        try {
          await api.post(`/announcements/${id}/read`);
          localStorage.setItem(`announcement_read_${id}`, 'true');
          
          const { announcements, unreadCount } = get();
          set({ unreadCount: Math.max(0, unreadCount - 1) });
        } catch (error) {
          console.error('Failed to mark announcement as read:', error);
        }
      },
      
      createAnnouncement: async (data) => {
        set({ loading: true });
        try {
          await api.post('/announcements', data);
          await get().fetchAnnouncements();
        } catch (error) {
          console.error('Failed to create announcement:', error);
          set({ loading: false });
        }
      },
      
      updateAnnouncement: async (id, data) => {
        set({ loading: true });
        try {
          await api.put(`/announcements/${id}`, data);
          await get().fetchAnnouncements();
        } catch (error) {
          console.error('Failed to update announcement:', error);
          set({ loading: false });
        }
      },
      
      deleteAnnouncement: async (id) => {
        try {
          await api.delete(`/announcements/${id}`);
          const { announcements } = get();
          set({ 
            announcements: announcements.filter(a => a.id !== id)
          });
        } catch (error) {
          console.error('Failed to delete announcement:', error);
        }
      },
      
      setCurrentAnnouncement: (announcement) => {
        set({ currentAnnouncement: announcement });
      }
    }),
    {
      name: 'announcement-store',
      partialize: (state) => ({ unreadCount: state.unreadCount })
    }
  )
);
```

##### 公告列表组件

```typescript
// components/announcements/AnnouncementList.tsx
import React, { useEffect, useState } from 'react';
import { useAnnouncementStore } from '@/stores/announcementStore';
import { Card, Badge, Button, Modal, Typography, Space, Tag, Tooltip } from 'antd';
import { BellOutlined, EyeOutlined, EditOutlined, DeleteOutlined } from '@ant-design/icons';
import { formatDistanceToNow } from 'date-fns';
import { zhCN } from 'date-fns/locale';

const { Title, Paragraph } = Typography;

interface AnnouncementListProps {
  showActions?: boolean;
  limit?: number;
}

export const AnnouncementList: React.FC<AnnouncementListProps> = ({ 
  showActions = false, 
  limit 
}) => {
  const { 
    announcements, 
    loading, 
    fetchAnnouncements, 
    markAsRead, 
    deleteAnnouncement,
    setCurrentAnnouncement 
  } = useAnnouncementStore();
  
  const [selectedAnnouncement, setSelectedAnnouncement] = useState<Announcement | null>(null);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  
  useEffect(() => {
    fetchAnnouncements();
  }, []);
  
  const displayAnnouncements = limit ? announcements.slice(0, limit) : announcements;
  
  const handleViewDetail = (announcement: Announcement) => {
    setSelectedAnnouncement(announcement);
    setDetailModalVisible(true);
    markAsRead(announcement.id);
  };
  
  const handleDelete = async (id: string) => {
    Modal.confirm({
      title: '确认删除',
      content: '确定要删除这条公告吗？此操作不可撤销。',
      onOk: () => deleteAnnouncement(id)
    });
  };
  
  const getPriorityColor = (priority: string) => {
    const colors = {
      low: 'default',
      medium: 'blue',
      high: 'orange',
      urgent: 'red'
    };
    return colors[priority as keyof typeof colors] || 'default';
  };
  
  const getTypeIcon = (type: string) => {
    const icons = {
      info: '📢',
      warning: '⚠️',
      error: '❌',
      success: '✅'
    };
    return icons[type as keyof typeof icons] || '📢';
  };
  
  return (
    <div className="announcement-list">
      <Space direction="vertical" size="middle" style={{ width: '100%' }}>
        {displayAnnouncements.map((announcement) => {
          const isRead = localStorage.getItem(`announcement_read_${announcement.id}`);
          
          return (
            <Card
              key={announcement.id}
              className={`announcement-card ${!isRead ? 'unread' : ''}`}
              size="small"
              hoverable
              actions={showActions ? [
                <Tooltip title="查看详情">
                  <EyeOutlined onClick={() => handleViewDetail(announcement)} />
                </Tooltip>,
                <Tooltip title="编辑">
                  <EditOutlined onClick={() => setCurrentAnnouncement(announcement)} />
                </Tooltip>,
                <Tooltip title="删除">
                  <DeleteOutlined onClick={() => handleDelete(announcement.id)} />
                </Tooltip>
              ] : [
                <Button 
                  type="link" 
                  size="small" 
                  onClick={() => handleViewDetail(announcement)}
                >
                  查看详情
                </Button>
              ]}
            >
              <div className="announcement-header">
                <Space>
                  <span className="type-icon">{getTypeIcon(announcement.type)}</span>
                  <Title level={5} style={{ margin: 0 }}>
                    {announcement.title}
                  </Title>
                  {!isRead && <Badge status="processing" />}
                </Space>
                <Space>
                  <Tag color={getPriorityColor(announcement.priority)}>
                    {announcement.priority.toUpperCase()}
                  </Tag>
                  <span className="time">
                    {formatDistanceToNow(new Date(announcement.createdAt), {
                      addSuffix: true,
                      locale: zhCN
                    })}
                  </span>
                </Space>
              </div>
              
              <Paragraph 
                ellipsis={{ rows: 2, expandable: false }}
                style={{ margin: '8px 0 0 0', color: '#666' }}
              >
                {announcement.content.replace(/<[^>]*>/g, '')}
              </Paragraph>
              
              {announcement.attachments && announcement.attachments.length > 0 && (
                <div className="attachments">
                  <Space size="small">
                    📎
                    {announcement.attachments.map((file, index) => (
                      <Tag key={index} size="small">{file.name}</Tag>
                    ))}
                  </Space>
                </div>
              )}
            </Card>
          );
        })}
      </Space>
      
      {/* 公告详情弹窗 */}
      <Modal
        title={selectedAnnouncement?.title}
        open={detailModalVisible}
        onCancel={() => setDetailModalVisible(false)}
        footer={[
          <Button key="close" onClick={() => setDetailModalVisible(false)}>
            关闭
          </Button>
        ]}
        width={800}
      >
        {selectedAnnouncement && (
          <AnnouncementDetail announcement={selectedAnnouncement} />
        )}
      </Modal>
    </div>
  );
};
```

##### 公告创建/编辑组件

```typescript
// components/announcements/AnnouncementForm.tsx
import React, { useState, useEffect } from 'react';
import { 
  Form, 
  Input, 
  Select, 
  DatePicker, 
  Switch, 
  Upload, 
  Button, 
  Card,
  Space,
  message,
  Row,
  Col
} from 'antd';
import { UploadOutlined, PlusOutlined } from '@ant-design/icons';
import { useAnnouncementStore } from '@/stores/announcementStore';
import ReactQuill from 'react-quill';
import 'react-quill/dist/quill.snow.css';
import dayjs from 'dayjs';

const { Option } = Select;
const { RangePicker } = DatePicker;

interface AnnouncementFormProps {
  announcement?: Announcement;
  onSuccess?: () => void;
  onCancel?: () => void;
}

export const AnnouncementForm: React.FC<AnnouncementFormProps> = ({
  announcement,
  onSuccess,
  onCancel
}) => {
  const [form] = Form.useForm();
  const { createAnnouncement, updateAnnouncement, loading } = useAnnouncementStore();
  const [content, setContent] = useState('');
  const [fileList, setFileList] = useState<any[]>([]);
  
  useEffect(() => {
    if (announcement) {
      form.setFieldsValue({
        ...announcement,
        timeRange: [dayjs(announcement.startTime), dayjs(announcement.endTime)],
        targetIds: announcement.targetIds
      });
      setContent(announcement.content);
      setFileList(announcement.attachments?.map((file, index) => ({
        uid: index,
        name: file.name,
        status: 'done',
        url: file.url
      })) || []);
    }
  }, [announcement, form]);
  
  const handleSubmit = async (values: any) => {
    try {
      const formData = {
        ...values,
        content,
        startTime: values.timeRange[0].toISOString(),
        endTime: values.timeRange[1].toISOString(),
        attachments: fileList.map(file => ({
          name: file.name,
          url: file.url || file.response?.url,
          size: file.size
        }))
      };
      
      if (announcement) {
        await updateAnnouncement(announcement.id, formData);
        message.success('公告更新成功');
      } else {
        await createAnnouncement(formData);
        message.success('公告创建成功');
      }
      
      onSuccess?.();
    } catch (error) {
      message.error('操作失败，请重试');
    }
  };
  
  const uploadProps = {
    name: 'file',
    action: '/api/upload',
    headers: {
      authorization: `Bearer ${localStorage.getItem('token')}`
    },
    fileList,
    onChange: ({ fileList }: any) => setFileList(fileList),
    beforeUpload: (file: File) => {
      const isValidType = ['application/pdf', 'application/msword', 
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
      ].includes(file.type);
      
      if (!isValidType) {
        message.error('只支持 PDF 和 Word 文档！');
        return false;
      }
      
      const isLt10M = file.size / 1024 / 1024 < 10;
      if (!isLt10M) {
        message.error('文件大小不能超过 10MB！');
        return false;
      }
      
      return true;
    }
  };
  
  return (
    <Card title={announcement ? '编辑公告' : '创建公告'}>
      <Form
        form={form}
        layout="vertical"
        onFinish={handleSubmit}
        initialValues={{
          type: 'info',
          priority: 'medium',
          targetType: 'all',
          displayType: 'banner',
          isForceRead: false
        }}
      >
        <Row gutter={16}>
          <Col span={12}>
            <Form.Item
              name="title"
              label="公告标题"
              rules={[
                { required: true, message: '请输入公告标题' },
                { max: 50, message: '标题不能超过50个字符' }
              ]}
            >
              <Input placeholder="请输入公告标题" />
            </Form.Item>
          </Col>
          
          <Col span={6}>
            <Form.Item name="type" label="公告类型">
              <Select>
                <Option value="info">信息</Option>
                <Option value="warning">警告</Option>
                <Option value="error">错误</Option>
                <Option value="success">成功</Option>
              </Select>
            </Form.Item>
          </Col>
          
          <Col span={6}>
            <Form.Item name="priority" label="优先级">
              <Select>
                <Option value="low">低</Option>
                <Option value="medium">中</Option>
                <Option value="high">高</Option>
                <Option value="urgent">紧急</Option>
              </Select>
            </Form.Item>
          </Col>
        </Row>
        
        <Form.Item label="公告内容">
          <ReactQuill
            value={content}
            onChange={setContent}
            modules={{
              toolbar: [
                [{ 'header': [1, 2, 3, false] }],
                ['bold', 'italic', 'underline', 'strike'],
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                ['link', 'image'],
                ['clean']
              ]
            }}
            style={{ height: '200px', marginBottom: '50px' }}
          />
        </Form.Item>
        
        <Row gutter={16}>
          <Col span={8}>
            <Form.Item name="targetType" label="发布范围">
              <Select>
                <Option value="all">全部用户</Option>
                <Option value="application">指定应用</Option>
                <Option value="license_rule">指定卡密规则</Option>
                <Option value="user_role">指定用户角色</Option>
              </Select>
            </Form.Item>
          </Col>
          
          <Col span={8}>
            <Form.Item name="displayType" label="展示方式">
              <Select>
                <Option value="popup">弹窗</Option>
                <Option value="banner">横幅</Option>
                <Option value="notification">通知</Option>
              </Select>
            </Form.Item>
          </Col>
          
          <Col span={8}>
            <Form.Item name="isForceRead" label="强制阅读" valuePropName="checked">
              <Switch />
            </Form.Item>
          </Col>
        </Row>
        
        <Form.Item
          name="timeRange"
          label="生效时间"
          rules={[{ required: true, message: '请选择生效时间范围' }]}
        >
          <RangePicker 
            showTime 
            format="YYYY-MM-DD HH:mm:ss"
            style={{ width: '100%' }}
          />
        </Form.Item>
        
        <Form.Item label="附件">
          <Upload {...uploadProps} maxCount={3}>
            <Button icon={<UploadOutlined />}>上传附件</Button>
          </Upload>
          <div style={{ color: '#999', fontSize: '12px', marginTop: '4px' }}>
            支持 PDF、Word 文档，最多3个文件，每个文件不超过10MB
          </div>
        </Form.Item>
        
        <Form.Item>
          <Space>
            <Button type="primary" htmlType="submit" loading={loading}>
              {announcement ? '更新' : '创建'}
            </Button>
            <Button onClick={onCancel}>
              取消
            </Button>
          </Space>
        </Form.Item>
      </Form>
    </Card>
  );
};
```

#### 2.6.2 后端API接口设计

##### 公告管理接口

```python
# routers/announcements.py
from fastapi import APIRouter, Depends, HTTPException, Query, UploadFile, File
from sqlalchemy.orm import Session
from typing import List, Optional
from datetime import datetime
import uuid

router = APIRouter(prefix="/announcements", tags=["announcements"])

# 数据模型
class AnnouncementCreate(BaseModel):
    title: str = Field(..., max_length=50, description="公告标题")
    content: str = Field(..., description="公告内容")
    type: str = Field(default="info", regex="^(info|warning|error|success)$")
    priority: str = Field(default="medium", regex="^(low|medium|high|urgent)$")
    target_type: str = Field(default="all", regex="^(all|application|license_rule|user_role)$")
    target_ids: List[str] = Field(default=[], description="目标ID列表")
    display_type: str = Field(default="banner", regex="^(popup|banner|notification)$")
    is_force_read: bool = Field(default=False, description="是否强制阅读")
    start_time: datetime = Field(..., description="生效时间")
    end_time: datetime = Field(..., description="过期时间")
    attachments: List[dict] = Field(default=[], description="附件列表")

class AnnouncementUpdate(BaseModel):
    title: Optional[str] = Field(None, max_length=50)
    content: Optional[str] = None
    type: Optional[str] = Field(None, regex="^(info|warning|error|success)$")
    priority: Optional[str] = Field(None, regex="^(low|medium|high|urgent)$")
    target_type: Optional[str] = Field(None, regex="^(all|application|license_rule|user_role)$")
    target_ids: Optional[List[str]] = None
    display_type: Optional[str] = Field(None, regex="^(popup|banner|notification)$")
    is_force_read: Optional[bool] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    status: Optional[str] = Field(None, regex="^(draft|published|expired|deleted)$")

class AnnouncementResponse(BaseModel):
    id: str
    title: str
    content: str
    type: str
    priority: str
    target_type: str
    target_ids: List[str]
    display_type: str
    is_force_read: bool
    start_time: datetime
    end_time: datetime
    attachments: List[dict]
    created_by: str
    created_at: datetime
    updated_at: datetime
    status: str
    read_count: int
    total_targets: int

@router.get("/", response_model=List[AnnouncementResponse])
async def get_announcements(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
    status: Optional[str] = Query(None, regex="^(draft|published|expired|deleted)$"),
    type: Optional[str] = Query(None, regex="^(info|warning|error|success)$"),
    priority: Optional[str] = Query(None, regex="^(low|medium|high|urgent)$"),
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100)
):
    """
    获取公告列表
    - 支持按状态、类型、优先级筛选
    - 支持分页查询
    - 普通用户只能看到针对自己的有效公告
    - 管理员可以看到所有公告
    """
    try:
        query = db.query(Announcement)
        
        # 权限过滤
        if current_user.role not in ['super_admin', 'admin']:
            # 普通用户只能看到针对自己的有效公告
            now = datetime.utcnow()
            query = query.filter(
                and_(
                    Announcement.status == 'published',
                    Announcement.start_time <= now,
                    Announcement.end_time >= now,
                    or_(
                        Announcement.target_type == 'all',
                        and_(
                            Announcement.target_type == 'user_role',
                            Announcement.target_ids.contains([current_user.role])
                        ),
                        and_(
                            Announcement.target_type == 'application',
                            # 根据用户的应用权限过滤
                        )
                    )
                )
            )
        
        # 条件过滤
        if status:
            query = query.filter(Announcement.status == status)
        if type:
            query = query.filter(Announcement.type == type)
        if priority:
            query = query.filter(Announcement.priority == priority)
        
        # 分页
        total = query.count()
        announcements = query.offset((page - 1) * size).limit(size).all()
        
        # 计算阅读统计
        result = []
        for announcement in announcements:
            read_count = db.query(AnnouncementRead).filter(
                AnnouncementRead.announcement_id == announcement.id
            ).count()
            
            total_targets = calculate_target_count(db, announcement)
            
            result.append(AnnouncementResponse(
                **announcement.__dict__,
                read_count=read_count,
                total_targets=total_targets
            ))
        
        return {
            "data": result,
            "total": total,
            "page": page,
            "size": size
        }
        
    except Exception as e:
        logger.error(f"Failed to get announcements: {str(e)}")
        raise HTTPException(status_code=500, detail="获取公告列表失败")

@router.post("/", response_model=AnnouncementResponse)
async def create_announcement(
    announcement: AnnouncementCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    创建公告
    - 只有管理员可以创建公告
    - 自动进行敏感词检测
    - 验证目标用户/应用的有效性
    """
    # 权限检查
    if current_user.role not in ['super_admin', 'admin']:
        raise HTTPException(status_code=403, detail="权限不足")
    
    try:
        # 敏感词检测
        if contains_sensitive_words(announcement.title) or contains_sensitive_words(announcement.content):
            raise HTTPException(status_code=400, detail="内容包含敏感词，请修改后重试")
        
        # 验证时间范围
        if announcement.start_time >= announcement.end_time:
            raise HTTPException(status_code=400, detail="生效时间必须早于过期时间")
        
        # 验证目标ID的有效性
        if announcement.target_type != 'all' and announcement.target_ids:
            validate_target_ids(db, announcement.target_type, announcement.target_ids)
        
        # 创建公告
        db_announcement = Announcement(
            id=str(uuid.uuid4()),
            **announcement.dict(),
            created_by=current_user.id,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
            status='published'
        )
        
        db.add(db_announcement)
        db.commit()
        db.refresh(db_announcement)
        
        # 触发推送事件
        await trigger_announcement_push(db_announcement)
        
        # 记录操作日志
        log_operation(
            db, current_user.id, 
            "CREATE_ANNOUNCEMENT", 
            f"创建公告: {announcement.title}",
            {"announcement_id": db_announcement.id}
        )
        
        return AnnouncementResponse(
            **db_announcement.__dict__,
            read_count=0,
            total_targets=calculate_target_count(db, db_announcement)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to create announcement: {str(e)}")
        db.rollback()
        raise HTTPException(status_code=500, detail="创建公告失败")

@router.put("/{announcement_id}", response_model=AnnouncementResponse)
async def update_announcement(
    announcement_id: str,
    announcement: AnnouncementUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    更新公告
    - 只有管理员和公告创建者可以更新
    - 已发布的公告修改后需要重新审核
    """
    # 权限检查
    if current_user.role not in ['super_admin', 'admin']:
        raise HTTPException(status_code=403, detail="权限不足")
    
    try:
        db_announcement = db.query(Announcement).filter(
            Announcement.id == announcement_id
        ).first()
        
        if not db_announcement:
            raise HTTPException(status_code=404, detail="公告不存在")
        
        # 检查是否有权限修改
        if (current_user.role != 'super_admin' and 
            db_announcement.created_by != current_user.id):
            raise HTTPException(status_code=403, detail="只能修改自己创建的公告")
        
        # 更新字段
        update_data = announcement.dict(exclude_unset=True)
        if update_data:
            # 敏感词检测
            if 'title' in update_data and contains_sensitive_words(update_data['title']):
                raise HTTPException(status_code=400, detail="标题包含敏感词")
            if 'content' in update_data and contains_sensitive_words(update_data['content']):
                raise HTTPException(status_code=400, detail="内容包含敏感词")
            
            # 验证时间范围
            start_time = update_data.get('start_time', db_announcement.start_time)
            end_time = update_data.get('end_time', db_announcement.end_time)
            if start_time >= end_time:
                raise HTTPException(status_code=400, detail="生效时间必须早于过期时间")
            
            for field, value in update_data.items():
                setattr(db_announcement, field, value)
            
            db_announcement.updated_at = datetime.utcnow()
            
            db.commit()
            db.refresh(db_announcement)
        
        # 记录操作日志
        log_operation(
            db, current_user.id,
            "UPDATE_ANNOUNCEMENT",
            f"更新公告: {db_announcement.title}",
            {"announcement_id": announcement_id, "changes": update_data}
        )
        
        return AnnouncementResponse(
            **db_announcement.__dict__,
            read_count=db.query(AnnouncementRead).filter(
                AnnouncementRead.announcement_id == announcement_id
            ).count(),
            total_targets=calculate_target_count(db, db_announcement)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to update announcement: {str(e)}")
        db.rollback()
        raise HTTPException(status_code=500, detail="更新公告失败")

@router.post("/{announcement_id}/read")
async def mark_announcement_read(
    announcement_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    标记公告为已读
    """
    try:
        # 检查公告是否存在
        announcement = db.query(Announcement).filter(
            Announcement.id == announcement_id
        ).first()
        
        if not announcement:
            raise HTTPException(status_code=404, detail="公告不存在")
        
        # 检查是否已读
        existing_read = db.query(AnnouncementRead).filter(
            and_(
                AnnouncementRead.announcement_id == announcement_id,
                AnnouncementRead.user_id == current_user.id
            )
        ).first()
        
        if not existing_read:
            # 创建阅读记录
            read_record = AnnouncementRead(
                id=str(uuid.uuid4()),
                announcement_id=announcement_id,
                user_id=current_user.id,
                read_at=datetime.utcnow()
            )
            db.add(read_record)
            db.commit()
        
        return {"message": "标记成功"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to mark announcement as read: {str(e)}")
        raise HTTPException(status_code=500, detail="标记失败")

@router.delete("/{announcement_id}")
async def delete_announcement(
    announcement_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    删除公告（软删除）
    """
    # 权限检查
    if current_user.role not in ['super_admin', 'admin']:
        raise HTTPException(status_code=403, detail="权限不足")
    
    try:
        db_announcement = db.query(Announcement).filter(
            Announcement.id == announcement_id
        ).first()
        
        if not db_announcement:
            raise HTTPException(status_code=404, detail="公告不存在")
        
        # 检查权限
        if (current_user.role != 'super_admin' and 
            db_announcement.created_by != current_user.id):
            raise HTTPException(status_code=403, detail="只能删除自己创建的公告")
        
        # 软删除
        db_announcement.status = 'deleted'
        db_announcement.updated_at = datetime.utcnow()
        
        db.commit()
        
        # 记录操作日志
        log_operation(
            db, current_user.id,
            "DELETE_ANNOUNCEMENT",
            f"删除公告: {db_announcement.title}",
            {"announcement_id": announcement_id}
        )
        
        return {"message": "删除成功"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete announcement: {str(e)}")
        db.rollback()
        raise HTTPException(status_code=500, detail="删除失败")

# 辅助函数
def calculate_target_count(db: Session, announcement: Announcement) -> int:
    """计算公告目标用户数量"""
    if announcement.target_type == 'all':
        return db.query(User).filter(User.status == 'active').count()
    elif announcement.target_type == 'user_role':
        return db.query(User).filter(
            and_(
                User.role.in_(announcement.target_ids),
                User.status == 'active'
            )
        ).count()
    elif announcement.target_type == 'application':
        # 计算使用指定应用的用户数
        return db.query(User).join(UserLicenseBind).join(LicenseCode).filter(
            and_(
                LicenseCode.application_id.in_(announcement.target_ids),
                User.status == 'active'
            )
        ).distinct().count()
    elif announcement.target_type == 'license_rule':
        # 计算使用指定卡密规则的用户数
        return db.query(User).join(UserLicenseBind).join(LicenseCode).filter(
            and_(
                LicenseCode.rule_id.in_(announcement.target_ids),
                User.status == 'active'
            )
        ).distinct().count()
    
    return 0

def validate_target_ids(db: Session, target_type: str, target_ids: List[str]):
    """验证目标ID的有效性"""
    if target_type == 'application':
        valid_count = db.query(Application).filter(
            Application.id.in_(target_ids)
        ).count()
        if valid_count != len(target_ids):
            raise HTTPException(status_code=400, detail="部分应用ID无效")
    elif target_type == 'license_rule':
        valid_count = db.query(LicenseRule).filter(
            LicenseRule.id.in_(target_ids)
        ).count()
        if valid_count != len(target_ids):
            raise HTTPException(status_code=400, detail="部分卡密规则ID无效")
    elif target_type == 'user_role':
        valid_roles = ['super_admin', 'admin', 'user']
        invalid_roles = [role for role in target_ids if role not in valid_roles]
        if invalid_roles:
            raise HTTPException(status_code=400, detail=f"无效的用户角色: {invalid_roles}")

def contains_sensitive_words(text: str) -> bool:
    """敏感词检测"""
    # 这里可以集成第三方敏感词检测服务
    sensitive_words = ['敏感词1', '敏感词2']  # 示例
    return any(word in text for word in sensitive_words)

async def trigger_announcement_push(announcement: Announcement):
    """触发公告推送"""
    # 发布事件到消息队列
    event_data = {
        "type": "announcement_published",
        "announcement_id": announcement.id,
        "target_type": announcement.target_type,
        "target_ids": announcement.target_ids,
        "display_type": announcement.display_type,
        "priority": announcement.priority
    }
    
    await publish_event("announcement.published", event_data)
```

#### 2.6.3 数据库表结构设计

```sql
-- 公告表
CREATE TABLE announcements (
    id VARCHAR(36) PRIMARY KEY,
    title VARCHAR(50) NOT NULL COMMENT '公告标题',
    content TEXT NOT NULL COMMENT '公告内容（支持HTML）',
    type ENUM('info', 'warning', 'error', 'success') DEFAULT 'info' COMMENT '公告类型',
    priority ENUM('low', 'medium', 'high', 'urgent') DEFAULT 'medium' COMMENT '优先级',
    target_type ENUM('all', 'application', 'license_rule', 'user_role') DEFAULT 'all' COMMENT '目标类型',
    target_ids JSON COMMENT '目标ID列表',
    display_type ENUM('popup', 'banner', 'notification') DEFAULT 'banner' COMMENT '展示方式',
    is_force_read BOOLEAN DEFAULT FALSE COMMENT '是否强制阅读',
    start_time DATETIME NOT NULL COMMENT '生效时间',
    end_time DATETIME NOT NULL COMMENT '过期时间',
    attachments JSON COMMENT '附件信息',
    created_by VARCHAR(36) NOT NULL COMMENT '创建者ID',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    status ENUM('draft', 'published', 'expired', 'deleted') DEFAULT 'draft' COMMENT '状态',
    
    INDEX idx_status_time (status, start_time, end_time),
    INDEX idx_target_type (target_type),
    INDEX idx_priority (priority),
    INDEX idx_created_by (created_by),
    FOREIGN KEY (created_by) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='公告表';

-- 公告阅读记录表
CREATE TABLE announcement_reads (
    id VARCHAR(36) PRIMARY KEY,
    announcement_id VARCHAR(36) NOT NULL COMMENT '公告ID',
    user_id VARCHAR(36) NOT NULL COMMENT '用户ID',
    read_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '阅读时间',
    
    UNIQUE KEY uk_announcement_user (announcement_id, user_id),
    INDEX idx_announcement_id (announcement_id),
    INDEX idx_user_id (user_id),
    INDEX idx_read_at (read_at),
    FOREIGN KEY (announcement_id) REFERENCES announcements(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='公告阅读记录表';

-- 定向推送记录表
CREATE TABLE announcement_pushes (
    id VARCHAR(36) PRIMARY KEY,
    announcement_id VARCHAR(36) COMMENT '公告ID（可为空，用于自动推送）',
    user_id VARCHAR(36) NOT NULL COMMENT '目标用户ID',
    push_type ENUM('announcement', 'license_expiry', 'device_limit', 'auth_failure') NOT NULL COMMENT '推送类型',
    title VARCHAR(100) NOT NULL COMMENT '推送标题',
    content TEXT NOT NULL COMMENT '推送内容',
    channels JSON NOT NULL COMMENT '推送渠道（desktop, web, email）',
    status ENUM('pending', 'sent', 'delivered', 'read', 'failed') DEFAULT 'pending' COMMENT '推送状态',
    sent_at DATETIME COMMENT '发送时间',
    delivered_at DATETIME COMMENT '送达时间',
    read_at DATETIME COMMENT '阅读时间',
    error_message TEXT COMMENT '错误信息',
    retry_count INT DEFAULT 0 COMMENT '重试次数',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    
    INDEX idx_user_status (user_id, status),
    INDEX idx_push_type (push_type),
    INDEX idx_announcement_id (announcement_id),
    INDEX idx_sent_at (sent_at),
    FOREIGN KEY (announcement_id) REFERENCES announcements(id) ON DELETE SET NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
) COMMENT='推送记录表';

-- 反馈表
CREATE TABLE feedbacks (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36) NOT NULL COMMENT '反馈用户ID',
    type ENUM('license_issue', 'login_issue', 'feature_request', 'bug_report', 'other') NOT NULL COMMENT '反馈类型',
    priority ENUM('low', 'medium', 'high', 'urgent') DEFAULT 'medium' COMMENT '紧急程度',
    title VARCHAR(100) NOT NULL COMMENT '反馈标题',
    content TEXT NOT NULL COMMENT '反馈内容',
    attachments JSON COMMENT '附件信息',
    related_announcement_id VARCHAR(36) COMMENT '关联公告ID',
    related_license_id VARCHAR(36) COMMENT '关联卡密ID',
    related_application_id VARCHAR(36) COMMENT '关联应用ID',
    device_info JSON COMMENT '设备信息',
    assigned_to VARCHAR(36) COMMENT '分配给的管理员ID',
    status ENUM('pending', 'processing', 'resolved', 'closed', 'escalated') DEFAULT 'pending' COMMENT '处理状态',
    admin_reply TEXT COMMENT '管理员回复',
    resolved_at DATETIME COMMENT '解决时间',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    
    INDEX idx_user_status (user_id, status),
    INDEX idx_type_priority (type, priority),
    INDEX idx_assigned_to (assigned_to),
    INDEX idx_created_at (created_at),
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (related_announcement_id) REFERENCES announcements(id) ON DELETE SET NULL,
    FOREIGN KEY (related_license_id) REFERENCES license_codes(id) ON DELETE SET NULL,
    FOREIGN KEY (related_application_id) REFERENCES applications(id) ON DELETE SET NULL,
    FOREIGN KEY (assigned_to) REFERENCES users(id) ON DELETE SET NULL
) COMMENT='用户反馈表';
```

#### 2.6.4 权限控制设计

```python
# 权限控制矩阵
ANNOUNCEMENT_PERMISSIONS = {
    'super_admin': {
        'create': True,
        'read': True,
        'update': True,
        'delete': True,
        'manage_all': True,
        'view_statistics': True
    },
    'admin': {
        'create': True,
        'read': True,
        'update': True,  # 只能修改自己创建的
        'delete': True,  # 只能删除自己创建的
        'manage_all': False,
        'view_statistics': True
    },
    'user': {
        'create': False,
        'read': True,  # 只能看到针对自己的公告
        'update': False,
        'delete': False,
        'manage_all': False,
        'view_statistics': False
    }
}

# 权限装饰器
def require_announcement_permission(permission: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(status_code=401, detail="未认证")
            
            user_permissions = ANNOUNCEMENT_PERMISSIONS.get(current_user.role, {})
            if not user_permissions.get(permission, False):
                raise HTTPException(status_code=403, detail="权限不足")
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# 数据过滤器
class AnnouncementFilter:
    @staticmethod
    def filter_by_user_permission(query, user: User):
        """根据用户权限过滤公告"""
        if user.role in ['super_admin', 'admin']:
            return query
        
        # 普通用户只能看到针对自己的有效公告
        now = datetime.utcnow()
        return query.filter(
            and_(
                Announcement.status == 'published',
                Announcement.start_time <= now,
                Announcement.end_time >= now,
                or_(
                    Announcement.target_type == 'all',
                    and_(
                        Announcement.target_type == 'user_role',
                        Announcement.target_ids.contains([user.role])
                    ),
                    and_(
                        Announcement.target_type == 'application',
                        # 检查用户是否有权限访问这些应用
                        exists().where(
                            and_(
                                UserLicenseBind.user_id == user.id,
                                LicenseCode.application_id.in_(Announcement.target_ids)
                            )
                        )
                    )
                )
            )
        )
```

#### 2.6.5 模块联动机制

##### 事件总线设计

```python
# events/event_bus.py
import asyncio
import json
from typing import Dict, List, Callable, Any
from datetime import datetime
import logging
from enum import Enum

logger = logging.getLogger(__name__)

class EventType(Enum):
    """事件类型枚举"""
    # 公告相关事件
    ANNOUNCEMENT_PUBLISHED = "announcement.published"
    ANNOUNCEMENT_UPDATED = "announcement.updated"
    ANNOUNCEMENT_DELETED = "announcement.deleted"
    
    # 卡密相关事件
    LICENSE_ACTIVATED = "license.activated"
    LICENSE_EXPIRED = "license.expired"
    LICENSE_EXPIRING_SOON = "license.expiring_soon"
    LICENSE_DEACTIVATED = "license.deactivated"
    
    # 用户相关事件
    USER_LOGIN_FAILED = "user.login_failed"
    USER_DEVICE_LIMIT_EXCEEDED = "user.device_limit_exceeded"
    USER_BANNED = "user.banned"
    
    # 应用相关事件
    APPLICATION_MAINTENANCE = "application.maintenance"
    APPLICATION_VERSION_UPDATED = "application.version_updated"

class Event:
    """事件数据结构"""
    def __init__(self, event_type: EventType, data: Dict[str, Any], user_id: str = None):
        self.id = str(uuid.uuid4())
        self.type = event_type
        self.data = data
        self.user_id = user_id
        self.timestamp = datetime.utcnow()
        self.processed = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "type": self.type.value,
            "data": self.data,
            "user_id": self.user_id,
            "timestamp": self.timestamp.isoformat(),
            "processed": self.processed
        }

class EventBus:
    """事件总线"""
    def __init__(self):
        self._subscribers: Dict[EventType, List[Callable]] = {}
        self._event_queue = asyncio.Queue()
        self._running = False
        self._worker_task = None

    async def start(self):
        """启动事件总线"""
        if not self._running:
            self._running = True
            self._worker_task = asyncio.create_task(self._process_events())
            logger.info("Event bus started")

    async def stop(self):
        """停止事件总线"""
        self._running = False
        if self._worker_task:
            self._worker_task.cancel()
            try:
                await self._worker_task
            except asyncio.CancelledError:
                pass
        logger.info("Event bus stopped")

    def subscribe(self, event_type: EventType, handler: Callable):
        """订阅事件"""
        if event_type not in self._subscribers:
            self._subscribers[event_type] = []
        self._subscribers[event_type].append(handler)
        logger.info(f"Subscribed to {event_type.value}")

    async def publish(self, event: Event):
        """发布事件"""
        await self._event_queue.put(event)
        logger.info(f"Published event {event.type.value} with id {event.id}")

    async def _process_events(self):
        """处理事件队列"""
        while self._running:
            try:
                event = await asyncio.wait_for(self._event_queue.get(), timeout=1.0)
                await self._handle_event(event)
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Error processing event: {str(e)}")

    async def _handle_event(self, event: Event):
        """处理单个事件"""
        handlers = self._subscribers.get(event.type, [])
        if not handlers:
            logger.warning(f"No handlers for event type {event.type.value}")
            return

        for handler in handlers:
            try:
                if asyncio.iscoroutinefunction(handler):
                    await handler(event)
                else:
                    handler(event)
                logger.debug(f"Event {event.id} handled by {handler.__name__}")
            except Exception as e:
                logger.error(f"Error in event handler {handler.__name__}: {str(e)}")

        event.processed = True

# 全局事件总线实例
event_bus = EventBus()
```

##### 公告联动处理器

```python
# handlers/announcement_handlers.py
from events.event_bus import event_bus, EventType, Event
from services.announcement_service import AnnouncementService
from services.notification_service import NotificationService
from database import get_db
import logging

logger = logging.getLogger(__name__)

class AnnouncementEventHandler:
    """公告事件处理器"""
    
    def __init__(self):
        self.announcement_service = AnnouncementService()
        self.notification_service = NotificationService()
        self._register_handlers()
    
    def _register_handlers(self):
        """注册事件处理器"""
        event_bus.subscribe(EventType.LICENSE_EXPIRED, self.handle_license_expired)
        event_bus.subscribe(EventType.LICENSE_EXPIRING_SOON, self.handle_license_expiring_soon)
        event_bus.subscribe(EventType.USER_LOGIN_FAILED, self.handle_login_failed)
        event_bus.subscribe(EventType.USER_DEVICE_LIMIT_EXCEEDED, self.handle_device_limit_exceeded)
        event_bus.subscribe(EventType.APPLICATION_MAINTENANCE, self.handle_application_maintenance)
        event_bus.subscribe(EventType.ANNOUNCEMENT_PUBLISHED, self.handle_announcement_published)
    
    async def handle_license_expired(self, event: Event):
        """处理卡密过期事件"""
        try:
            license_data = event.data
            user_id = license_data.get('user_id')
            license_code = license_data.get('license_code')
            application_name = license_data.get('application_name')
            
            # 创建过期通知公告
            announcement_data = {
                'title': f'卡密过期提醒',
                'content': f'您的{application_name}授权已过期，卡密：{license_code[:8]}***，请及时续费以继续使用。',
                'type': 'warning',
                'priority': 'high',
                'target_type': 'user_role',
                'target_ids': [user_id],
                'display_type': 'popup',
                'is_force_read': True,
                'start_time': datetime.utcnow(),
                'end_time': datetime.utcnow() + timedelta(days=7)
            }
            
            db = next(get_db())
            await self.announcement_service.create_system_announcement(db, announcement_data)
            
            # 发送推送通知
            await self.notification_service.send_notification(
                user_id=user_id,
                title='卡密过期提醒',
                content=announcement_data['content'],
                channels=['desktop', 'web'],
                push_type='license_expiry'
            )
            
            logger.info(f"Created expiry announcement for user {user_id}")
            
        except Exception as e:
            logger.error(f"Failed to handle license expired event: {str(e)}")
    
    async def handle_license_expiring_soon(self, event: Event):
        """处理卡密即将过期事件"""
        try:
            license_data = event.data
            user_id = license_data.get('user_id')
            license_code = license_data.get('license_code')
            application_name = license_data.get('application_name')
            days_left = license_data.get('days_left', 0)
            
            # 创建即将过期提醒公告
            announcement_data = {
                'title': f'卡密即将过期',
                'content': f'您的{application_name}授权将在{days_left}天后过期，卡密：{license_code[:8]}***，建议提前续费。',
                'type': 'info',
                'priority': 'medium',
                'target_type': 'user_role',
                'target_ids': [user_id],
                'display_type': 'banner',
                'is_force_read': False,
                'start_time': datetime.utcnow(),
                'end_time': datetime.utcnow() + timedelta(days=days_left + 1)
            }
            
            db = next(get_db())
            await self.announcement_service.create_system_announcement(db, announcement_data)
            
            logger.info(f"Created expiring soon announcement for user {user_id}")
            
        except Exception as e:
            logger.error(f"Failed to handle license expiring soon event: {str(e)}")
    
    async def handle_login_failed(self, event: Event):
        """处理登录失败事件"""
        try:
            login_data = event.data
            user_id = login_data.get('user_id')
            failed_attempts = login_data.get('failed_attempts', 0)
            ip_address = login_data.get('ip_address')
            
            # 连续失败次数达到阈值时发送安全提醒
            if failed_attempts >= 5:
                announcement_data = {
                    'title': '账户安全提醒',
                    'content': f'检测到您的账户存在异常登录尝试（IP: {ip_address}），如非本人操作，请立即修改密码并联系客服。',
                    'type': 'error',
                    'priority': 'urgent',
                    'target_type': 'user_role',
                    'target_ids': [user_id],
                    'display_type': 'popup',
                    'is_force_read': True,
                    'start_time': datetime.utcnow(),
                    'end_time': datetime.utcnow() + timedelta(days=3)
                }
                
                db = next(get_db())
                await self.announcement_service.create_system_announcement(db, announcement_data)
                
                # 发送紧急安全通知
                await self.notification_service.send_notification(
                    user_id=user_id,
                    title='账户安全警告',
                    content=announcement_data['content'],
                    channels=['desktop', 'web', 'email'],
                    push_type='auth_failure'
                )
                
                logger.warning(f"Created security alert for user {user_id} after {failed_attempts} failed attempts")
        
        except Exception as e:
            logger.error(f"Failed to handle login failed event: {str(e)}")
    
    async def handle_device_limit_exceeded(self, event: Event):
        """处理设备数量超限事件"""
        try:
            device_data = event.data
            user_id = device_data.get('user_id')
            current_devices = device_data.get('current_devices', 0)
            max_devices = device_data.get('max_devices', 0)
            new_device_info = device_data.get('new_device_info', {})
            
            announcement_data = {
                'title': '设备数量超限提醒',
                'content': f'您的账户设备数量已达上限（{current_devices}/{max_devices}），新设备登录被拒绝。如需在新设备使用，请先解绑其他设备。',
                'type': 'warning',
                'priority': 'high',
                'target_type': 'user_role',
                'target_ids': [user_id],
                'display_type': 'popup',
                'is_force_read': True,
                'start_time': datetime.utcnow(),
                'end_time': datetime.utcnow() + timedelta(days=1)
            }
            
            db = next(get_db())
            await self.announcement_service.create_system_announcement(db, announcement_data)
            
            # 发送设备限制通知
            await self.notification_service.send_notification(
                user_id=user_id,
                title='设备数量超限',
                content=announcement_data['content'],
                channels=['desktop', 'web'],
                push_type='device_limit'
            )
            
            logger.info(f"Created device limit announcement for user {user_id}")
            
        except Exception as e:
            logger.error(f"Failed to handle device limit exceeded event: {str(e)}")
    
    async def handle_application_maintenance(self, event: Event):
        """处理应用维护事件"""
        try:
            maintenance_data = event.data
            application_id = maintenance_data.get('application_id')
            application_name = maintenance_data.get('application_name')
            maintenance_start = maintenance_data.get('start_time')
            maintenance_end = maintenance_data.get('end_time')
            reason = maintenance_data.get('reason', '系统维护')
            
            announcement_data = {
                'title': f'{application_name}维护通知',
                'content': f'{application_name}将于{maintenance_start}至{maintenance_end}进行{reason}，期间服务可能中断，请合理安排使用时间。',
                'type': 'info',
                'priority': 'high',
                'target_type': 'application',
                'target_ids': [application_id],
                'display_type': 'banner',
                'is_force_read': False,
                'start_time': datetime.utcnow(),
                'end_time': datetime.fromisoformat(maintenance_end) + timedelta(hours=1)
            }
            
            db = next(get_db())
            await self.announcement_service.create_system_announcement(db, announcement_data)
            
            logger.info(f"Created maintenance announcement for application {application_id}")
            
        except Exception as e:
            logger.error(f"Failed to handle application maintenance event: {str(e)}")
    
    async def handle_announcement_published(self, event: Event):
        """处理公告发布事件"""
        try:
            announcement_data = event.data
            announcement_id = announcement_data.get('announcement_id')
            target_type = announcement_data.get('target_type')
            target_ids = announcement_data.get('target_ids', [])
            display_type = announcement_data.get('display_type')
            priority = announcement_data.get('priority')
            
            # 根据展示方式和优先级决定推送策略
            if display_type == 'popup' or priority in ['high', 'urgent']:
                # 高优先级公告立即推送
                await self._push_announcement_immediately(announcement_id, target_type, target_ids)
            else:
                # 普通公告延迟推送，避免打扰用户
                await self._schedule_announcement_push(announcement_id, target_type, target_ids)
            
            logger.info(f"Processed announcement published event for {announcement_id}")
            
        except Exception as e:
            logger.error(f"Failed to handle announcement published event: {str(e)}")
    
    async def _push_announcement_immediately(self, announcement_id: str, target_type: str, target_ids: List[str]):
        """立即推送公告"""
        db = next(get_db())
        target_users = await self.announcement_service.get_target_users(db, target_type, target_ids)
        
        for user_id in target_users:
            await self.notification_service.send_notification(
                user_id=user_id,
                title='新公告通知',
                content='您有新的重要公告，请及时查看。',
                channels=['desktop', 'web'],
                push_type='announcement',
                related_id=announcement_id
            )
    
    async def _schedule_announcement_push(self, announcement_id: str, target_type: str, target_ids: List[str]):
        """延迟推送公告"""
        # 这里可以集成任务调度器，如Celery
        # 暂时使用简单的延迟推送
        await asyncio.sleep(300)  # 延迟5分钟推送
        await self._push_announcement_immediately(announcement_id, target_type, target_ids)

# 初始化事件处理器
announcement_handler = AnnouncementEventHandler()
```

##### 通知服务

```python
# services/notification_service.py
import asyncio
import json
from typing import List, Dict, Any
from datetime import datetime
from database import get_db
from models.announcement import AnnouncementPush
import uuid
import logging

logger = logging.getLogger(__name__)

class NotificationService:
    """通知推送服务"""
    
    def __init__(self):
        self.websocket_manager = WebSocketManager()
        self.email_service = EmailService()
    
    async def send_notification(
        self,
        user_id: str,
        title: str,
        content: str,
        channels: List[str],
        push_type: str,
        related_id: str = None
    ):
        """发送通知"""
        try:
            # 创建推送记录
            db = next(get_db())
            push_record = AnnouncementPush(
                id=str(uuid.uuid4()),
                announcement_id=related_id,
                user_id=user_id,
                push_type=push_type,
                title=title,
                content=content,
                channels=channels,
                status='pending',
                created_at=datetime.utcnow()
            )
            
            db.add(push_record)
            db.commit()
            
            # 并发推送到各个渠道
            tasks = []
            if 'desktop' in channels:
                tasks.append(self._send_desktop_notification(user_id, title, content))
            if 'web' in channels:
                tasks.append(self._send_web_notification(user_id, title, content))
            if 'email' in channels:
                tasks.append(self._send_email_notification(user_id, title, content))
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # 更新推送状态
            success_count = sum(1 for result in results if not isinstance(result, Exception))
            if success_count > 0:
                push_record.status = 'sent'
                push_record.sent_at = datetime.utcnow()
            else:
                push_record.status = 'failed'
                push_record.error_message = str(results[0]) if results else 'Unknown error'
            
            db.commit()
            
            logger.info(f"Notification sent to user {user_id} via {success_count}/{len(tasks)} channels")
            
        except Exception as e:
            logger.error(f"Failed to send notification: {str(e)}")
            if 'push_record' in locals():
                push_record.status = 'failed'
                push_record.error_message = str(e)
                db.commit()
    
    async def _send_desktop_notification(self, user_id: str, title: str, content: str):
        """发送桌面通知"""
        # 这里集成桌面应用的通知API
        # 可以通过WebSocket或HTTP API推送到桌面客户端
        notification_data = {
            'type': 'desktop_notification',
            'title': title,
            'content': content,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # 发送到桌面客户端
        await self._send_to_desktop_client(user_id, notification_data)
    
    async def _send_web_notification(self, user_id: str, title: str, content: str):
        """发送Web通知"""
        notification_data = {
            'type': 'web_notification',
            'title': title,
            'content': content,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # 通过WebSocket推送到Web客户端
        await self.websocket_manager.send_to_user(user_id, notification_data)
    
    async def _send_email_notification(self, user_id: str, title: str, content: str):
        """发送邮件通知"""
        # 获取用户邮箱
        db = next(get_db())
        user = db.query(User).filter(User.id == user_id).first()
        if not user or not user.email:
            raise Exception("User email not found")
        
        # 发送邮件
        await self.email_service.send_email(
            to_email=user.email,
            subject=title,
            content=content
        )
    
    async def _send_to_desktop_client(self, user_id: str, data: Dict[str, Any]):
        """发送到桌面客户端"""
        # 这里需要根据实际的桌面应用通信方式实现
        # 可能是HTTP API、WebSocket或其他IPC方式
        pass

class WebSocketManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        self.connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, user_id: str):
        """建立WebSocket连接"""
        await websocket.accept()
        if user_id not in self.connections:
            self.connections[user_id] = []
        self.connections[user_id].append(websocket)
        logger.info(f"WebSocket connected for user {user_id}")
    
    def disconnect(self, websocket: WebSocket, user_id: str):
        """断开WebSocket连接"""
        if user_id in self.connections:
            self.connections[user_id].remove(websocket)
            if not self.connections[user_id]:
                del self.connections[user_id]
        logger.info(f"WebSocket disconnected for user {user_id}")
    
    async def send_to_user(self, user_id: str, data: Dict[str, Any]):
        """发送消息给指定用户"""
        if user_id in self.connections:
            message = json.dumps(data)
            disconnected = []
            
            for websocket in self.connections[user_id]:
                try:
                    await websocket.send_text(message)
                except Exception as e:
                    logger.error(f"Failed to send WebSocket message: {str(e)}")
                    disconnected.append(websocket)
            
            # 清理断开的连接
            for websocket in disconnected:
                self.disconnect(websocket, user_id)

# 全局WebSocket管理器实例
websocket_manager = WebSocketManager()
```

### 2.5 主要界面交互逻辑

#### 登录流程

```mermaid
sequenceDiagram
    participant U as 用户
    participant F as 前端
    participant A as API
    
    U->>F: 输入用户名密码
    F->>F: 表单验证
    F->>A: POST /auth/login
    A->>F: 返回JWT Token
    F->>F: 存储Token到Cookie
    F->>F: 跳转到Dashboard
    F->>A: GET /auth/me (验证Token)
    A->>F: 返回用户信息
    F->>F: 更新全局状态
```

#### 卡密激活流程

```mermaid
sequenceDiagram
    participant C as 客户端
    participant F as 前端
    participant A as API
    participant D as 数据库
    
    C->>F: 输入卡密
    F->>F: 卡密格式验证
    F->>A: POST /auth/activate
    A->>D: 查询卡密状态
    D->>A: 返回卡密信息
    A->>A: 验证设备指纹
    A->>D: 更新卡密状态
    A->>F: 返回激活结果
    F->>C: 显示激活状态
```

---

## 3. 后端开发部分

### 3.1 配置管理优化

#### 3.1.1 环境变量配置方案

##### 配置文件结构

```bash
# .env.example - 环境变量模板文件
# 数据库配置
DATABASE_URL=postgresql://username:password@localhost:5432/goldfish_license
DATABASE_POOL_SIZE=20
DATABASE_MAX_OVERFLOW=30
DATABASE_POOL_TIMEOUT=30
DATABASE_POOL_RECYCLE=3600

# Redis配置
REDIS_URL=redis://localhost:6379/0
REDIS_PASSWORD=
REDIS_MAX_CONNECTIONS=50
REDIS_SOCKET_TIMEOUT=5
REDIS_SOCKET_CONNECT_TIMEOUT=5

# JWT配置
JWT_SECRET_KEY=your-super-secret-jwt-key-change-in-production
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# 加密配置
ENCRYPTION_KEY=your-32-byte-encryption-key-here
PASSWORD_SALT_ROUNDS=12

# 服务器配置
SERVER_HOST=0.0.0.0
SERVER_PORT=
SERVER_WORKERS=4
DEBUG_MODE=false
LOG_LEVEL=INFO

# 跨域配置
CORS_ORIGINS=http://localhost:3000,http://127.0.0.1:3000
CORS_ALLOW_CREDENTIALS=true

# 限流配置
RATE_LIMIT_REQUESTS_PER_MINUTE=60
RATE_LIMIT_BURST_SIZE=10

# 邮件配置
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-password
SMTP_USE_TLS=true

# 文件上传配置
UPLOAD_MAX_SIZE_MB=10
UPLOAD_ALLOWED_EXTENSIONS=jpg,jpeg,png,gif,pdf,doc,docx
UPLOAD_PATH=./uploads

# 缓存配置
CACHE_DEFAULT_TIMEOUT=300
CACHE_LICENSE_TIMEOUT=3600
CACHE_USER_SESSION_TIMEOUT=1800

# 监控配置
MONITORING_ENABLED=true
METRICS_PORT=9090
HEALTH_CHECK_INTERVAL=30

# 外部服务配置
LICENSE_VALIDATION_URL=https://api.license-provider.com/validate
NOTIFICATION_SERVICE_URL=https://api.notification-service.com
AUDIT_LOG_WEBHOOK_URL=https://api.audit-service.com/webhook

# 安全配置
SECURE_COOKIES=true
CSRF_PROTECTION_ENABLED=true
API_KEY_HEADER_NAME=X-API-Key
ADMIN_API_KEY=your-admin-api-key-here

# 开发环境配置
ENVIRONMENT=development
PROFILING_ENABLED=false
SQL_ECHO=false
```

##### 配置管理类

```python
# config/settings.py
import os
from typing import List, Optional
from pydantic import BaseSettings, validator
from functools import lru_cache
import secrets

class Settings(BaseSettings):
    """应用配置管理类"""
    
    # 数据库配置
    database_url: str
    database_pool_size: int = 20
    database_max_overflow: int = 30
    database_pool_timeout: int = 30
    database_pool_recycle: int = 3600
    
    # Redis配置
    redis_url: str = "redis://localhost:6379/0"
    redis_password: Optional[str] = None
    redis_max_connections: int = 50
    redis_socket_timeout: int = 5
    redis_socket_connect_timeout: int = 5
    
    # JWT配置
    jwt_secret_key: str
    jwt_algorithm: str = "HS256"
    jwt_access_token_expire_minutes: int = 30
    jwt_refresh_token_expire_days: int = 7
    
    # 加密配置
    encryption_key: str
    password_salt_rounds: int = 12
    
    # 服务器配置
    server_host: str = "0.0.0.0"
    server_port: int = 8000
    server_workers: int = 4
    debug_mode: bool = False
    log_level: str = "INFO"
    
    # 跨域配置
    cors_origins: List[str] = ["http://localhost:3000"]
    cors_allow_credentials: bool = True
    
    # 限流配置
    rate_limit_requests_per_minute: int = 60
    rate_limit_burst_size: int = 10
    
    # 邮件配置
    smtp_server: Optional[str] = None
    smtp_port: int = 587
    smtp_username: Optional[str] = None
    smtp_password: Optional[str] = None
    smtp_use_tls: bool = True
    
    # 文件上传配置
    upload_max_size_mb: int = 10
    upload_allowed_extensions: List[str] = ["jpg", "jpeg", "png", "gif", "pdf", "doc", "docx"]
    upload_path: str = "./uploads"
    
    # 缓存配置
    cache_default_timeout: int = 300
    cache_license_timeout: int = 3600
    cache_user_session_timeout: int = 1800
    
    # 监控配置
    monitoring_enabled: bool = True
    metrics_port: int = 9090
    health_check_interval: int = 30
    
    # 外部服务配置
    license_validation_url: Optional[str] = None
    notification_service_url: Optional[str] = None
    audit_log_webhook_url: Optional[str] = None
    
    # 安全配置
    secure_cookies: bool = True
    csrf_protection_enabled: bool = True
    api_key_header_name: str = "X-API-Key"
    admin_api_key: Optional[str] = None
    
    # 开发环境配置
    environment: str = "development"
    profiling_enabled: bool = False
    sql_echo: bool = False
    
    @validator('jwt_secret_key')
    def validate_jwt_secret_key(cls, v):
        if len(v) < 32:
            raise ValueError('JWT密钥长度不能少于32个字符')
        return v
    
    @validator('encryption_key')
    def validate_encryption_key(cls, v):
        if len(v) != 32:
            raise ValueError('加密密钥必须为32字节')
        return v
    
    @validator('cors_origins', pre=True)
    def parse_cors_origins(cls, v):
        if isinstance(v, str):
            return [origin.strip() for origin in v.split(',')]
        return v
    
    @validator('upload_allowed_extensions', pre=True)
    def parse_upload_extensions(cls, v):
        if isinstance(v, str):
            return [ext.strip().lower() for ext in v.split(',')]
        return v
    
    def generate_secret_key(self) -> str:
        """生成安全的密钥"""
        return secrets.token_urlsafe(32)
    
    @property
    def is_production(self) -> bool:
        """判断是否为生产环境"""
        return self.environment.lower() == 'production'
    
    @property
    def is_development(self) -> bool:
        """判断是否为开发环境"""
        return self.environment.lower() == 'development'
    
    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'
        case_sensitive = False
        # 环境变量前缀
        env_prefix = ""
        # 允许从环境变量中读取嵌套配置
        env_nested_delimiter = "__"

@lru_cache()
def get_settings() -> Settings:
    """获取配置实例（单例模式）"""
    return Settings()

# 全局配置实例
settings = get_settings()
```

##### 配置验证和初始化

```python
# config/validator.py
import os
import sys
from pathlib import Path
from typing import List, Dict, Any
from config.settings import settings
import logging

logger = logging.getLogger(__name__)

class ConfigValidator:
    """配置验证器"""
    
    def __init__(self):
        self.errors: List[str] = []
        self.warnings: List[str] = []
    
    def validate_all(self) -> bool:
        """验证所有配置项"""
        self.validate_database_config()
        self.validate_security_config()
        self.validate_file_paths()
        self.validate_network_config()
        self.validate_external_services()
        
        if self.errors:
            logger.error("配置验证失败:")
            for error in self.errors:
                logger.error(f"  - {error}")
            return False
        
        if self.warnings:
            logger.warning("配置警告:")
            for warning in self.warnings:
                logger.warning(f"  - {warning}")
        
        logger.info("配置验证通过")
        return True
    
    def validate_database_config(self):
        """验证数据库配置"""
        if not settings.database_url:
            self.errors.append("数据库URL未配置")
        
        if settings.database_pool_size <= 0:
            self.errors.append("数据库连接池大小必须大于0")
        
        if settings.database_pool_size > 100:
            self.warnings.append("数据库连接池大小过大，可能影响性能")
    
    def validate_security_config(self):
        """验证安全配置"""
        if len(settings.jwt_secret_key) < 32:
            self.errors.append("JWT密钥长度不足，存在安全风险")
        
        if settings.jwt_secret_key == "your-super-secret-jwt-key-change-in-production":
            self.errors.append("JWT密钥使用默认值，必须修改")
        
        if settings.encryption_key == "your-32-byte-encryption-key-here":
            self.errors.append("加密密钥使用默认值，必须修改")
        
        if settings.is_production and settings.debug_mode:
            self.warnings.append("生产环境不建议开启调试模式")
        
        if settings.is_production and not settings.secure_cookies:
            self.warnings.append("生产环境建议启用安全Cookie")
    
    def validate_file_paths(self):
        """验证文件路径配置"""
        upload_path = Path(settings.upload_path)
        if not upload_path.exists():
            try:
                upload_path.mkdir(parents=True, exist_ok=True)
                logger.info(f"创建上传目录: {upload_path}")
            except Exception as e:
                self.errors.append(f"无法创建上传目录 {upload_path}: {str(e)}")
        
        if not os.access(upload_path, os.W_OK):
            self.errors.append(f"上传目录 {upload_path} 没有写入权限")
    
    def validate_network_config(self):
        """验证网络配置"""
        if settings.server_port < 1024 and os.getuid() != 0:
            self.warnings.append("使用特权端口需要管理员权限")
        
        if settings.server_port > 65535:
            self.errors.append("服务器端口号超出有效范围")
        
        # 验证CORS配置
        if "*" in settings.cors_origins and settings.is_production:
            self.warnings.append("生产环境不建议使用通配符CORS配置")
    
    def validate_external_services(self):
        """验证外部服务配置"""
        if settings.smtp_server and not settings.smtp_username:
            self.warnings.append("配置了SMTP服务器但未设置用户名")
        
        if settings.monitoring_enabled and settings.metrics_port == settings.server_port:
            self.errors.append("监控端口不能与服务端口相同")

def validate_config() -> bool:
    """验证配置并返回是否通过"""
    validator = ConfigValidator()
    return validator.validate_all()

def init_config():
    """初始化配置"""
    # 检查.env文件是否存在
    env_file = Path(".env")
    if not env_file.exists():
        logger.warning(".env文件不存在，将使用环境变量或默认值")
        
        # 检查是否有.env.example文件
        env_example = Path(".env.example")
        if env_example.exists():
            logger.info("发现.env.example文件，请复制并重命名为.env后配置相应参数")
    
    # 验证配置
    if not validate_config():
        logger.error("配置验证失败，程序退出")
        sys.exit(1)
    
    # 设置日志级别
    logging.getLogger().setLevel(getattr(logging, settings.log_level.upper()))
    
    logger.info(f"应用配置初始化完成 - 环境: {settings.environment}")
```

##### 配置热重载机制

```python
# config/hot_reload.py
import asyncio
import os
from pathlib import Path
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from config.settings import get_settings
import logging
from datetime import datetime
from typing import List

logger = logging.getLogger(__name__)

class ConfigReloadHandler(FileSystemEventHandler):
    """配置文件变更处理器"""
    
    def __init__(self, callback):
        self.callback = callback
        self.last_modified = {}
    
    def on_modified(self, event):
        if event.is_directory:
            return
        
        file_path = Path(event.src_path)
        if file_path.name in [".env", "settings.py"]:
            # 防止重复触发
            current_time = os.path.getmtime(file_path)
            if file_path in self.last_modified:
                if current_time - self.last_modified[file_path] < 1:
                    return
            
            self.last_modified[file_path] = current_time
            logger.info(f"检测到配置文件变更: {file_path}")
            
            # 异步执行回调
            asyncio.create_task(self.callback())

class ConfigHotReload:
    """配置热重载管理器"""
    
    def __init__(self):
        self.observer = None
        self.enabled = False
    
    async def start(self, watch_paths: List[str] = None):
        """启动配置热重载"""
        if watch_paths is None:
            watch_paths = ["."]
        
        self.observer = Observer()
        handler = ConfigReloadHandler(self._reload_config)
        
        for path in watch_paths:
            self.observer.schedule(handler, path, recursive=False)
        
        self.observer.start()
        self.enabled = True
        logger.info("配置热重载已启动")
    
    def stop(self):
        """停止配置热重载"""
        if self.observer:
            self.observer.stop()
            self.observer.join()
            self.enabled = False
            logger.info("配置热重载已停止")
    
    async def _reload_config(self):
        """重新加载配置"""
        try:
            # 清除缓存的配置
            get_settings.cache_clear()
            
            # 重新验证配置
            from config.validator import validate_config
            if validate_config():
                logger.info("配置重新加载成功")
                # 这里可以触发其他需要重新初始化的组件
                await self._notify_config_change()
            else:
                logger.error("配置重新加载失败，保持原有配置")
        
        except Exception as e:
            logger.error(f"配置重新加载异常: {str(e)}")
    
    async def _notify_config_change(self):
        """通知配置变更"""
        # 这里可以发送事件通知其他模块配置已变更
        from events.event_bus import event_bus, Event, EventType
        
        event = Event(
            event_type=EventType.CONFIG_CHANGED,
            data={"timestamp": datetime.utcnow().isoformat()}
        )
        await event_bus.publish(event)

# 全局热重载实例
config_hot_reload = ConfigHotReload()
```

#### 3.1.2 应用启动配置集成

```python
# main.py
from fastapi import FastAPI
from config.settings import settings
from config.validator import init_config
from config.hot_reload import config_hot_reload
import uvicorn
import logging

# 初始化配置
init_config()

# 创建FastAPI应用
app = FastAPI(
    title="金鱼智盒卡密授权系统",
    description="企业级卡密授权管理系统",
    version="1.0.0",
    debug=settings.debug_mode
)

@app.on_event("startup")
async def startup_event():
    """应用启动事件"""
    logger = logging.getLogger(__name__)
    logger.info(f"应用启动 - 环境: {settings.environment}")
    logger.info(f"服务地址: {settings.server_host}:{settings.server_port}")
    
    # 开发环境启用配置热重载
    if settings.is_development:
        await config_hot_reload.start()
        logger.info("开发环境配置热重载已启用")

@app.on_event("shutdown")
async def shutdown_event():
    """应用关闭事件"""
    if config_hot_reload.enabled:
        config_hot_reload.stop()
    
    logger = logging.getLogger(__name__)
    logger.info("应用已关闭")

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host=settings.server_host,
        port=settings.server_port,
        workers=settings.server_workers if settings.is_production else 1,
        reload=settings.is_development,
        log_level=settings.log_level.lower()
    )
```

### 3.2 错误处理机制完善

#### 3.2.1 全局异常拦截器

##### 异常处理中间件

```python
# middleware/exception_handler.py
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException as StarletteHTTPException
from starlette.middleware.base import BaseHTTPMiddleware
from typing import Union
import logging
import traceback
from datetime import datetime
import uuid
from config.settings import settings

logger = logging.getLogger(__name__)

class GlobalExceptionHandler(BaseHTTPMiddleware):
    """全局异常处理中间件"""
    
    async def dispatch(self, request: Request, call_next):
        try:
            response = await call_next(request)
            return response
        except Exception as exc:
            return await self.handle_exception(request, exc)
    
    async def handle_exception(self, request: Request, exc: Exception) -> JSONResponse:
        """处理异常并返回标准化响应"""
        error_id = str(uuid.uuid4())
        
        # 记录异常信息
        logger.error(
            f"异常ID: {error_id} | 路径: {request.url.path} | "
            f"方法: {request.method} | 异常: {str(exc)}",
            exc_info=True
        )
        
        # 根据异常类型返回不同的错误响应
        if isinstance(exc, HTTPException):
            return await self._handle_http_exception(exc, error_id)
        elif isinstance(exc, RequestValidationError):
            return await self._handle_validation_error(exc, error_id)
        elif isinstance(exc, ValueError):
            return await self._handle_value_error(exc, error_id)
        elif isinstance(exc, PermissionError):
            return await self._handle_permission_error(exc, error_id)
        else:
            return await self._handle_internal_error(exc, error_id)
    
    async def _handle_http_exception(self, exc: HTTPException, error_id: str) -> JSONResponse:
        """处理HTTP异常"""
        return JSONResponse(
            status_code=exc.status_code,
            content={
                "success": False,
                "error_code": f"HTTP_{exc.status_code}",
                "message": exc.detail,
                "error_id": error_id,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
    
    async def _handle_validation_error(self, exc: RequestValidationError, error_id: str) -> JSONResponse:
        """处理请求验证错误"""
        errors = []
        for error in exc.errors():
            field = ".".join(str(loc) for loc in error["loc"])
            errors.append({
                "field": field,
                "message": error["msg"],
                "type": error["type"]
            })
        
        return JSONResponse(
            status_code=422,
            content={
                "success": False,
                "error_code": "VALIDATION_ERROR",
                "message": "请求参数验证失败",
                "details": errors,
                "error_id": error_id,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
    
    async def _handle_value_error(self, exc: ValueError, error_id: str) -> JSONResponse:
        """处理值错误"""
        return JSONResponse(
            status_code=400,
            content={
                "success": False,
                "error_code": "VALUE_ERROR",
                "message": str(exc),
                "error_id": error_id,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
    
    async def _handle_permission_error(self, exc: PermissionError, error_id: str) -> JSONResponse:
        """处理权限错误"""
        return JSONResponse(
            status_code=403,
            content={
                "success": False,
                "error_code": "PERMISSION_DENIED",
                "message": "权限不足",
                "error_id": error_id,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
    
    async def _handle_internal_error(self, exc: Exception, error_id: str) -> JSONResponse:
        """处理内部服务器错误"""
        # 生产环境不暴露详细错误信息
        message = "内部服务器错误" if settings.is_production else str(exc)
        
        return JSONResponse(
            status_code=500,
            content={
                "success": False,
                "error_code": "INTERNAL_ERROR",
                "message": message,
                "error_id": error_id,
                "timestamp": datetime.utcnow().isoformat()
            }
        )
```

##### 业务异常定义

```python
# exceptions/business_exceptions.py
from fastapi import HTTPException
from typing import Optional, Dict, Any

class BusinessException(HTTPException):
    """业务异常基类"""
    
    def __init__(
        self,
        status_code: int,
        error_code: str,
        message: str,
        details: Optional[Dict[str, Any]] = None
    ):
        self.error_code = error_code
        self.details = details or {}
        super().__init__(status_code=status_code, detail=message)

# 认证相关异常
class AuthenticationException(BusinessException):
    """认证异常"""
    
    def __init__(self, message: str = "认证失败"):
        super().__init__(
            status_code=401,
            error_code="AUTH_FAILED",
            message=message
        )

class TokenExpiredException(BusinessException):
    """Token过期异常"""
    
    def __init__(self, message: str = "访问令牌已过期"):
        super().__init__(
            status_code=401,
            error_code="TOKEN_EXPIRED",
            message=message
        )

class InvalidTokenException(BusinessException):
    """无效Token异常"""
    
    def __init__(self, message: str = "无效的访问令牌"):
        super().__init__(
            status_code=401,
            error_code="INVALID_TOKEN",
            message=message
        )

# 授权相关异常
class AuthorizationException(BusinessException):
    """授权异常"""
    
    def __init__(self, message: str = "权限不足"):
        super().__init__(
            status_code=403,
            error_code="PERMISSION_DENIED",
            message=message
        )

class RoleRequiredException(BusinessException):
    """角色权限不足异常"""
    
    def __init__(self, required_role: str):
        super().__init__(
            status_code=403,
            error_code="ROLE_REQUIRED",
            message=f"需要 {required_role} 角色权限",
            details={"required_role": required_role}
        )

# 卡密相关异常
class LicenseNotFoundException(BusinessException):
    """卡密不存在异常"""
    
    def __init__(self, license_key: str):
        super().__init__(
            status_code=404,
            error_code="LICENSE_NOT_FOUND",
            message=f"卡密 {license_key} 不存在",
            details={"license_key": license_key}
        )

class LicenseExpiredException(BusinessException):
    """卡密过期异常"""
    
    def __init__(self, license_key: str, expired_at: str):
        super().__init__(
            status_code=400,
            error_code="LICENSE_EXPIRED",
            message=f"卡密 {license_key} 已于 {expired_at} 过期",
            details={"license_key": license_key, "expired_at": expired_at}
        )

class LicenseAlreadyActivatedException(BusinessException):
    """卡密已激活异常"""
    
    def __init__(self, license_key: str):
        super().__init__(
            status_code=400,
            error_code="LICENSE_ALREADY_ACTIVATED",
            message=f"卡密 {license_key} 已被激活",
            details={"license_key": license_key}
        )

class DeviceLimitExceededException(BusinessException):
    """设备数量超限异常"""
    
    def __init__(self, current_count: int, max_count: int):
        super().__init__(
            status_code=400,
            error_code="DEVICE_LIMIT_EXCEEDED",
            message=f"设备数量已达上限 ({current_count}/{max_count})",
            details={"current_count": current_count, "max_count": max_count}
        )

# 用户相关异常
class UserNotFoundException(BusinessException):
    """用户不存在异常"""
    
    def __init__(self, identifier: str):
        super().__init__(
            status_code=404,
            error_code="USER_NOT_FOUND",
            message=f"用户 {identifier} 不存在",
            details={"identifier": identifier}
        )

class UserAlreadyExistsException(BusinessException):
    """用户已存在异常"""
    
    def __init__(self, username: str):
        super().__init__(
            status_code=409,
            error_code="USER_ALREADY_EXISTS",
            message=f"用户名 {username} 已存在",
            details={"username": username}
        )

class InvalidCredentialsException(BusinessException):
    """凭据无效异常"""
    
    def __init__(self, message: str = "用户名或密码错误"):
        super().__init__(
            status_code=401,
            error_code="INVALID_CREDENTIALS",
            message=message
        )

# 数据库相关异常
class DatabaseException(BusinessException):
    """数据库异常"""
    
    def __init__(self, message: str = "数据库操作失败"):
        super().__init__(
            status_code=500,
            error_code="DATABASE_ERROR",
            message=message
        )

class DuplicateKeyException(BusinessException):
    """重复键异常"""
    
    def __init__(self, field: str, value: str):
        super().__init__(
            status_code=409,
            error_code="DUPLICATE_KEY",
            message=f"{field} '{value}' 已存在",
            details={"field": field, "value": value}
        )

# 外部服务异常
class ExternalServiceException(BusinessException):
    """外部服务异常"""
    
    def __init__(self, service_name: str, message: str = "外部服务调用失败"):
        super().__init__(
            status_code=503,
            error_code="EXTERNAL_SERVICE_ERROR",
            message=f"{service_name}: {message}",
            details={"service_name": service_name}
        )

# 限流异常
class RateLimitException(BusinessException):
    """限流异常"""
    
    def __init__(self, retry_after: int = 60):
        super().__init__(
            status_code=429,
            error_code="RATE_LIMIT_EXCEEDED",
            message=f"请求过于频繁，请 {retry_after} 秒后重试",
            details={"retry_after": retry_after}
        )
```

#### 3.2.2 错误码规范体系

##### 错误码定义

```python
# constants/error_codes.py
from enum import Enum
from typing import Dict, Any

class ErrorCode(Enum):
    """错误码枚举"""
    
    # 通用错误码 (1000-1999)
    SUCCESS = ("SUCCESS", "操作成功")
    UNKNOWN_ERROR = ("UNKNOWN_ERROR", "未知错误")
    INVALID_PARAMETER = ("INVALID_PARAMETER", "参数无效")
    MISSING_PARAMETER = ("MISSING_PARAMETER", "缺少必要参数")
    VALIDATION_ERROR = ("VALIDATION_ERROR", "数据验证失败")
    INTERNAL_ERROR = ("INTERNAL_ERROR", "内部服务器错误")
    SERVICE_UNAVAILABLE = ("SERVICE_UNAVAILABLE", "服务不可用")
    
    # 认证错误码 (2000-2999)
    AUTH_FAILED = ("AUTH_FAILED", "认证失败")
    TOKEN_EXPIRED = ("TOKEN_EXPIRED", "访问令牌已过期")
    TOKEN_INVALID = ("TOKEN_INVALID", "无效的访问令牌")
    TOKEN_MISSING = ("TOKEN_MISSING", "缺少访问令牌")
    REFRESH_TOKEN_EXPIRED = ("REFRESH_TOKEN_EXPIRED", "刷新令牌已过期")
    REFRESH_TOKEN_INVALID = ("REFRESH_TOKEN_INVALID", "无效的刷新令牌")
    LOGIN_REQUIRED = ("LOGIN_REQUIRED", "需要登录")
    LOGOUT_REQUIRED = ("LOGOUT_REQUIRED", "需要注销")
    
    # 授权错误码 (3000-3999)
    PERMISSION_DENIED = ("PERMISSION_DENIED", "权限不足")
    ROLE_REQUIRED = ("ROLE_REQUIRED", "需要特定角色权限")
    RESOURCE_ACCESS_DENIED = ("RESOURCE_ACCESS_DENIED", "资源访问被拒绝")
    OPERATION_NOT_ALLOWED = ("OPERATION_NOT_ALLOWED", "操作不被允许")
    
    # 用户错误码 (4000-4999)
    USER_NOT_FOUND = ("USER_NOT_FOUND", "用户不存在")
    USER_ALREADY_EXISTS = ("USER_ALREADY_EXISTS", "用户已存在")
    INVALID_CREDENTIALS = ("INVALID_CREDENTIALS", "用户名或密码错误")
    USER_DISABLED = ("USER_DISABLED", "用户已被禁用")
    USER_LOCKED = ("USER_LOCKED", "用户已被锁定")
    PASSWORD_EXPIRED = ("PASSWORD_EXPIRED", "密码已过期")
    PASSWORD_TOO_WEAK = ("PASSWORD_TOO_WEAK", "密码强度不足")
    
    # 卡密错误码 (5000-5999)
    LICENSE_NOT_FOUND = ("LICENSE_NOT_FOUND", "卡密不存在")
    LICENSE_EXPIRED = ("LICENSE_EXPIRED", "卡密已过期")
    LICENSE_NOT_ACTIVATED = ("LICENSE_NOT_ACTIVATED", "卡密未激活")
    LICENSE_ALREADY_ACTIVATED = ("LICENSE_ALREADY_ACTIVATED", "卡密已激活")
    LICENSE_SUSPENDED = ("LICENSE_SUSPENDED", "卡密已暂停")
    LICENSE_REVOKED = ("LICENSE_REVOKED", "卡密已撤销")
    DEVICE_LIMIT_EXCEEDED = ("DEVICE_LIMIT_EXCEEDED", "设备数量超限")
    DEVICE_NOT_AUTHORIZED = ("DEVICE_NOT_AUTHORIZED", "设备未授权")
    LICENSE_QUOTA_EXCEEDED = ("LICENSE_QUOTA_EXCEEDED", "卡密配额已用完")
    
    # 应用错误码 (6000-6999)
    APPLICATION_NOT_FOUND = ("APPLICATION_NOT_FOUND", "应用不存在")
    APPLICATION_DISABLED = ("APPLICATION_DISABLED", "应用已禁用")
    APPLICATION_MAINTENANCE = ("APPLICATION_MAINTENANCE", "应用维护中")
    VERSION_NOT_SUPPORTED = ("VERSION_NOT_SUPPORTED", "版本不支持")
    
    # 数据库错误码 (7000-7999)
    DATABASE_ERROR = ("DATABASE_ERROR", "数据库错误")
    DUPLICATE_KEY = ("DUPLICATE_KEY", "重复键冲突")
    FOREIGN_KEY_CONSTRAINT = ("FOREIGN_KEY_CONSTRAINT", "外键约束违反")
    DATA_INTEGRITY_ERROR = ("DATA_INTEGRITY_ERROR", "数据完整性错误")
    CONNECTION_TIMEOUT = ("CONNECTION_TIMEOUT", "数据库连接超时")
    
    # 外部服务错误码 (8000-8999)
    EXTERNAL_SERVICE_ERROR = ("EXTERNAL_SERVICE_ERROR", "外部服务错误")
    PAYMENT_SERVICE_ERROR = ("PAYMENT_SERVICE_ERROR", "支付服务错误")
    EMAIL_SERVICE_ERROR = ("EMAIL_SERVICE_ERROR", "邮件服务错误")
    SMS_SERVICE_ERROR = ("SMS_SERVICE_ERROR", "短信服务错误")
    
    # 限流错误码 (9000-9999)
    RATE_LIMIT_EXCEEDED = ("RATE_LIMIT_EXCEEDED", "请求频率超限")
    CONCURRENT_LIMIT_EXCEEDED = ("CONCURRENT_LIMIT_EXCEEDED", "并发数超限")
    QUOTA_EXCEEDED = ("QUOTA_EXCEEDED", "配额已用完")
    
    def __init__(self, code: str, message: str):
        self.code = code
        self.message = message
    
    @classmethod
    def get_error_info(cls, error_code: str) -> Dict[str, Any]:
        """根据错误码获取错误信息"""
        for error in cls:
            if error.code == error_code:
                return {
                    "code": error.code,
                    "message": error.message
                }
        return {
            "code": "UNKNOWN_ERROR",
            "message": "未知错误码"
        }
```

##### 用户友好错误消息模板

```python
# utils/error_messages.py
from typing import Dict, Any, Optional
from constants.error_codes import ErrorCode

class ErrorMessageTemplate:
    """错误消息模板类"""
    
    # 用户友好的错误消息模板
    USER_FRIENDLY_MESSAGES = {
        # 认证相关
        "AUTH_FAILED": "登录失败，请检查用户名和密码",
        "TOKEN_EXPIRED": "登录已过期，请重新登录",
        "TOKEN_INVALID": "登录状态异常，请重新登录",
        "LOGIN_REQUIRED": "请先登录后再进行操作",
        
        # 权限相关
        "PERMISSION_DENIED": "您没有权限执行此操作",
        "ROLE_REQUIRED": "您的权限不足，无法执行此操作",
        
        # 用户相关
        "USER_NOT_FOUND": "用户不存在，请检查用户信息",
        "USER_ALREADY_EXISTS": "用户名已被使用，请选择其他用户名",
        "INVALID_CREDENTIALS": "用户名或密码错误，请重新输入",
        "USER_DISABLED": "账户已被禁用，请联系管理员",
        "USER_LOCKED": "账户已被锁定，请联系管理员",
        
        # 卡密相关
        "LICENSE_NOT_FOUND": "卡密不存在，请检查卡密是否正确",
        "LICENSE_EXPIRED": "卡密已过期，请联系客服续费",
        "LICENSE_ALREADY_ACTIVATED": "卡密已被激活，无法重复使用",
        "DEVICE_LIMIT_EXCEEDED": "设备数量已达上限，请先解绑其他设备",
        "DEVICE_NOT_AUTHORIZED": "当前设备未授权，请先激活卡密",
        
        # 应用相关
        "APPLICATION_NOT_FOUND": "应用不存在或已下线",
        "APPLICATION_DISABLED": "应用已暂停服务，请稍后再试",
        "APPLICATION_MAINTENANCE": "应用正在维护中，请稍后再试",
        
        # 系统相关
        "INTERNAL_ERROR": "系统繁忙，请稍后再试",
        "SERVICE_UNAVAILABLE": "服务暂时不可用，请稍后再试",
        "RATE_LIMIT_EXCEEDED": "操作过于频繁，请稍后再试",
        "VALIDATION_ERROR": "输入信息有误，请检查后重新提交",
    }
    
    # 技术错误消息（用于日志记录）
    TECHNICAL_MESSAGES = {
        "DATABASE_ERROR": "Database operation failed",
        "CONNECTION_TIMEOUT": "Database connection timeout",
        "EXTERNAL_SERVICE_ERROR": "External service call failed",
        "DUPLICATE_KEY": "Duplicate key constraint violation",
    }
    
    @classmethod
    def get_user_message(
        cls, 
        error_code: str, 
        context: Optional[Dict[str, Any]] = None
    ) -> str:
        """获取用户友好的错误消息"""
        base_message = cls.USER_FRIENDLY_MESSAGES.get(
            error_code, 
            "操作失败，请稍后重试"
        )
        
        # 根据上下文信息定制消息
        if context:
            if error_code == "DEVICE_LIMIT_EXCEEDED":
                current = context.get("current_count", 0)
                max_count = context.get("max_count", 0)
                return f"设备数量已达上限 ({current}/{max_count})，请先解绑其他设备"
            
            elif error_code == "LICENSE_EXPIRED":
                expired_at = context.get("expired_at", "")
                if expired_at:
                    return f"卡密已于 {expired_at} 过期，请联系客服续费"
            
            elif error_code == "RATE_LIMIT_EXCEEDED":
                retry_after = context.get("retry_after", 60)
                return f"操作过于频繁，请 {retry_after} 秒后重试"
        
        return base_message
    
    @classmethod
    def get_technical_message(
        cls, 
        error_code: str, 
        original_error: Optional[str] = None
    ) -> str:
        """获取技术错误消息"""
        base_message = cls.TECHNICAL_MESSAGES.get(
            error_code, 
            f"Technical error: {error_code}"
        )
        
        if original_error:
            return f"{base_message}: {original_error}"
        
        return base_message
    
    @classmethod
    def format_validation_errors(cls, errors: list) -> str:
        """格式化验证错误消息"""
        if not errors:
            return "数据验证失败"
        
        if len(errors) == 1:
            error = errors[0]
            field = error.get("field", "未知字段")
            message = error.get("message", "格式错误")
            return f"{field}: {message}"
        
        # 多个错误时返回汇总消息
        return f"发现 {len(errors)} 个输入错误，请检查后重新提交"
```

### 3.3 安全增强措施

#### 3.3.1 密钥轮换机制

##### 密钥管理服务

```python
# security/key_manager.py
from typing import Dict, Optional, Tuple
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization
import secrets
import base64
import json
import asyncio
from sqlalchemy.ext.asyncio import AsyncSession
from database.models import SecurityKey
from config.settings import settings
import logging

logger = logging.getLogger(__name__)

class KeyManager:
    """密钥管理器"""
    
    def __init__(self):
        self._current_keys: Dict[str, Dict] = {}
        self._rotation_tasks: Dict[str, asyncio.Task] = {}
        self._lock = asyncio.Lock()
    
    async def initialize(self, db: AsyncSession):
        """初始化密钥管理器"""
        await self._load_keys_from_db(db)
        await self._start_rotation_tasks()
    
    async def _load_keys_from_db(self, db: AsyncSession):
        """从数据库加载密钥"""
        try:
            # 查询所有活跃的密钥
            result = await db.execute(
                "SELECT * FROM security_keys WHERE status = 'active' ORDER BY created_at DESC"
            )
            keys = result.fetchall()
            
            for key_record in keys:
                self._current_keys[key_record.key_type] = {
                    'id': key_record.id,
                    'key_data': key_record.key_data,
                    'created_at': key_record.created_at,
                    'expires_at': key_record.expires_at,
                    'algorithm': key_record.algorithm
                }
            
            logger.info(f"已加载 {len(keys)} 个密钥")
        except Exception as e:
            logger.error(f"加载密钥失败: {e}")
            raise
    
    async def _start_rotation_tasks(self):
        """启动密钥轮换任务"""
        key_types = ['jwt_signing', 'data_encryption', 'api_signing']
        
        for key_type in key_types:
            task = asyncio.create_task(self._rotation_worker(key_type))
            self._rotation_tasks[key_type] = task
            logger.info(f"已启动 {key_type} 密钥轮换任务")
    
    async def _rotation_worker(self, key_type: str):
        """密钥轮换工作进程"""
        while True:
            try:
                await self._check_and_rotate_key(key_type)
                # 每小时检查一次
                await asyncio.sleep(3600)
            except Exception as e:
                logger.error(f"密钥轮换任务 {key_type} 出错: {e}")
                await asyncio.sleep(300)  # 出错后5分钟重试
    
    async def _check_and_rotate_key(self, key_type: str):
        """检查并轮换密钥"""
        async with self._lock:
            current_key = self._current_keys.get(key_type)
            
            if not current_key:
                # 没有当前密钥，生成新的
                await self._generate_new_key(key_type)
                return
            
            # 检查是否需要轮换
            expires_at = current_key['expires_at']
            now = datetime.utcnow()
            
            # 提前24小时开始轮换
            rotation_time = expires_at - timedelta(hours=24)
            
            if now >= rotation_time:
                logger.info(f"开始轮换 {key_type} 密钥")
                await self._rotate_key(key_type)
    
    async def _generate_new_key(self, key_type: str) -> Dict:
        """生成新密钥"""
        if key_type == 'jwt_signing':
            return await self._generate_rsa_key_pair(key_type)
        elif key_type in ['data_encryption', 'api_signing']:
            return await self._generate_symmetric_key(key_type)
        else:
            raise ValueError(f"不支持的密钥类型: {key_type}")
    
    async def _generate_rsa_key_pair(self, key_type: str) -> Dict:
        """生成RSA密钥对"""
        # 生成私钥
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        
        # 序列化私钥
        private_pem = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        # 获取公钥
        public_key = private_key.public_key()
        public_pem = public_key.public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        )
        
        key_data = {
            'private_key': base64.b64encode(private_pem).decode('utf-8'),
            'public_key': base64.b64encode(public_pem).decode('utf-8')
        }
        
        return await self._save_key_to_db(
            key_type=key_type,
            key_data=json.dumps(key_data),
            algorithm='RSA-2048'
        )
    
    async def _generate_symmetric_key(self, key_type: str) -> Dict:
        """生成对称密钥"""
        # 生成32字节的随机密钥
        key = secrets.token_bytes(32)
        key_data = {
            'key': base64.b64encode(key).decode('utf-8')
        }
        
        return await self._save_key_to_db(
            key_type=key_type,
            key_data=json.dumps(key_data),
            algorithm='AES-256'
        )
    
    async def _save_key_to_db(self, key_type: str, key_data: str, algorithm: str) -> Dict:
        """保存密钥到数据库"""
        from database.connection import get_db
        
        async with get_db() as db:
            try:
                # 创建新密钥记录
                new_key = SecurityKey(
                    key_type=key_type,
                    key_data=key_data,
                    algorithm=algorithm,
                    created_at=datetime.utcnow(),
                    expires_at=datetime.utcnow() + timedelta(days=30),  # 30天过期
                    status='active'
                )
                
                db.add(new_key)
                await db.commit()
                await db.refresh(new_key)
                
                # 更新内存中的密钥
                key_info = {
                    'id': new_key.id,
                    'key_data': key_data,
                    'created_at': new_key.created_at,
                    'expires_at': new_key.expires_at,
                    'algorithm': algorithm
                }
                
                self._current_keys[key_type] = key_info
                
                logger.info(f"已生成新的 {key_type} 密钥，ID: {new_key.id}")
                return key_info
                
            except Exception as e:
                await db.rollback()
                logger.error(f"保存密钥失败: {e}")
                raise
    
    async def _rotate_key(self, key_type: str):
        """轮换密钥"""
        from database.connection import get_db
        
        async with get_db() as db:
            try:
                # 将当前密钥标记为即将过期
                current_key = self._current_keys.get(key_type)
                if current_key:
                    await db.execute(
                        "UPDATE security_keys SET status = 'rotating' WHERE id = :key_id",
                        {'key_id': current_key['id']}
                    )
                
                # 生成新密钥
                new_key = await self._generate_new_key(key_type)
                
                # 等待一段时间让新密钥生效
                await asyncio.sleep(60)
                
                # 将旧密钥标记为已过期
                if current_key:
                    await db.execute(
                        "UPDATE security_keys SET status = 'expired' WHERE id = :key_id",
                        {'key_id': current_key['id']}
                    )
                
                await db.commit()
                
                logger.info(f"密钥 {key_type} 轮换完成")
                
                # 发送密钥轮换通知
                await self._notify_key_rotation(key_type, new_key)
                
            except Exception as e:
                await db.rollback()
                logger.error(f"密钥轮换失败: {e}")
                raise
    
    async def _notify_key_rotation(self, key_type: str, new_key: Dict):
        """通知密钥轮换"""
        # 这里可以发送通知给相关服务
        # 例如：更新缓存、通知其他微服务等
        logger.info(f"密钥轮换通知: {key_type} -> {new_key['id']}")
    
    def get_current_key(self, key_type: str) -> Optional[Dict]:
        """获取当前密钥"""
        return self._current_keys.get(key_type)
    
    def get_jwt_signing_key(self) -> Optional[str]:
        """获取JWT签名密钥"""
        key_info = self.get_current_key('jwt_signing')
        if key_info:
            key_data = json.loads(key_info['key_data'])
            return key_data.get('private_key')
        return None
    
    def get_jwt_public_key(self) -> Optional[str]:
        """获取JWT公钥"""
        key_info = self.get_current_key('jwt_signing')
        if key_info:
            key_data = json.loads(key_info['key_data'])
            return key_data.get('public_key')
        return None
    
    def get_encryption_key(self) -> Optional[bytes]:
        """获取数据加密密钥"""
        key_info = self.get_current_key('data_encryption')
        if key_info:
            key_data = json.loads(key_info['key_data'])
            return base64.b64decode(key_data['key'].encode('utf-8'))
        return None
    
    async def cleanup(self):
        """清理资源"""
        # 取消所有轮换任务
        for task in self._rotation_tasks.values():
            task.cancel()
        
        # 等待任务完成
        await asyncio.gather(*self._rotation_tasks.values(), return_exceptions=True)
        
        logger.info("密钥管理器已清理")

# 全局密钥管理器实例
key_manager = KeyManager()
```

##### 密钥轮换数据库表

```sql
-- 密钥管理表
CREATE TABLE security_keys (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    key_type VARCHAR(50) NOT NULL COMMENT '密钥类型：jwt_signing, data_encryption, api_signing',
    key_data TEXT NOT NULL COMMENT '密钥数据（JSON格式）',
    algorithm VARCHAR(20) NOT NULL COMMENT '加密算法',
    status ENUM('active', 'rotating', 'expired') DEFAULT 'active' COMMENT '密钥状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    expires_at TIMESTAMP NOT NULL COMMENT '过期时间',
    rotated_at TIMESTAMP NULL COMMENT '轮换时间',
    created_by VARCHAR(50) DEFAULT 'system' COMMENT '创建者',
    
    INDEX idx_key_type_status (key_type, status),
    INDEX idx_expires_at (expires_at),
    INDEX idx_created_at (created_at)
) COMMENT='安全密钥管理表';

-- 密钥使用记录表
CREATE TABLE key_usage_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    key_id BIGINT NOT NULL,
    operation VARCHAR(50) NOT NULL COMMENT '操作类型：sign, encrypt, decrypt, verify',
    user_id BIGINT NULL COMMENT '用户ID',
    ip_address VARCHAR(45) NULL COMMENT 'IP地址',
    user_agent TEXT NULL COMMENT '用户代理',
    success BOOLEAN DEFAULT TRUE COMMENT '操作是否成功',
    error_message TEXT NULL COMMENT '错误信息',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',
    
    FOREIGN KEY (key_id) REFERENCES security_keys(id),
    INDEX idx_key_id (key_id),
    INDEX idx_created_at (created_at),
    INDEX idx_user_id (user_id)
) COMMENT='密钥使用日志表';
```

#### 3.3.2 API防护策略

##### 限流中间件

```python
# middleware/rate_limiter.py
from fastapi import Request, HTTPException
from fastapi.responses import JSONResponse
from starlette.middleware.base import BaseHTTPMiddleware
from typing import Dict, Optional, Tuple
import time
import asyncio
from collections import defaultdict, deque
import redis.asyncio as redis
from config.settings import settings
import logging
import hashlib
import json

logger = logging.getLogger(__name__)

class RateLimiter:
    """限流器"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.local_cache = defaultdict(lambda: deque())
        self.cache_lock = asyncio.Lock()
    
    async def is_allowed(
        self, 
        key: str, 
        limit: int, 
        window: int,
        identifier: str = "default"
    ) -> Tuple[bool, Dict]:
        """检查是否允许请求"""
        now = time.time()
        
        # 使用滑动窗口算法
        return await self._sliding_window_check(key, limit, window, now, identifier)
    
    async def _sliding_window_check(
        self, 
        key: str, 
        limit: int, 
        window: int, 
        now: float,
        identifier: str
    ) -> Tuple[bool, Dict]:
        """滑动窗口限流检查"""
        try:
            # Redis Lua脚本实现原子性滑动窗口
            lua_script = """
            local key = KEYS[1]
            local window = tonumber(ARGV[1])
            local limit = tonumber(ARGV[2])
            local now = tonumber(ARGV[3])
            local identifier = ARGV[4]
            
            -- 清理过期记录
            redis.call('ZREMRANGEBYSCORE', key, 0, now - window)
            
            -- 获取当前窗口内的请求数
            local current = redis.call('ZCARD', key)
            
            if current < limit then
                -- 添加当前请求
                redis.call('ZADD', key, now, identifier .. ':' .. now)
                redis.call('EXPIRE', key, window + 1)
                return {1, current + 1, limit - current - 1}
            else
                return {0, current, 0}
            end
            """
            
            result = await self.redis.eval(
                lua_script,
                1,
                key,
                window,
                limit,
                now,
                identifier
            )
            
            allowed = bool(result[0])
            current_requests = int(result[1])
            remaining = int(result[2])
            
            # 计算重置时间
            reset_time = int(now + window)
            
            return allowed, {
                'allowed': allowed,
                'limit': limit,
                'remaining': remaining,
                'reset_time': reset_time,
                'current': current_requests
            }
            
        except Exception as e:
            logger.error(f"限流检查失败: {e}")
            # 降级到本地缓存
            return await self._local_fallback_check(key, limit, window, now)
    
    async def _local_fallback_check(
        self, 
        key: str, 
        limit: int, 
        window: int, 
        now: float
    ) -> Tuple[bool, Dict]:
        """本地缓存降级检查"""
        async with self.cache_lock:
            requests = self.local_cache[key]
            
            # 清理过期请求
            while requests and requests[0] <= now - window:
                requests.popleft()
            
            current_requests = len(requests)
            
            if current_requests < limit:
                requests.append(now)
                return True, {
                    'allowed': True,
                    'limit': limit,
                    'remaining': limit - current_requests - 1,
                    'reset_time': int(now + window),
                    'current': current_requests + 1
                }
            else:
                return False, {
                    'allowed': False,
                    'limit': limit,
                    'remaining': 0,
                    'reset_time': int(now + window),
                    'current': current_requests
                }

class RateLimitMiddleware(BaseHTTPMiddleware):
    """限流中间件"""
    
    def __init__(self, app, redis_client: redis.Redis):
        super().__init__(app)
        self.limiter = RateLimiter(redis_client)
        
        # 限流规则配置
        self.rules = {
            # 全局限流
            'global': {'limit': 1000, 'window': 60},  # 每分钟1000次
            
            # IP限流
            'ip': {'limit': 100, 'window': 60},  # 每分钟100次
            
            # 用户限流
            'user': {'limit': 200, 'window': 60},  # 每分钟200次
            
            # API端点限流
            'endpoint': {
                '/api/auth/login': {'limit': 5, 'window': 300},  # 登录：5分钟5次
                '/api/licenses/activate': {'limit': 10, 'window': 60},  # 激活：每分钟10次
                '/api/licenses/verify': {'limit': 1000, 'window': 60},  # 验证：每分钟1000次
            }
        }
    
    async def dispatch(self, request: Request, call_next):
        # 获取客户端标识
        client_ip = self._get_client_ip(request)
        user_id = await self._get_user_id(request)
        endpoint = request.url.path
        
        # 检查各种限流规则
        checks = [
            ('global', 'global', 'global'),
            ('ip', f'ip:{client_ip}', client_ip),
            ('endpoint', f'endpoint:{endpoint}', f'{client_ip}:{endpoint}')
        ]
        
        if user_id:
            checks.append(('user', f'user:{user_id}', str(user_id)))
        
        # 执行限流检查
        for rule_type, key, identifier in checks:
            if not await self._check_rate_limit(rule_type, key, identifier, endpoint):
                return await self._rate_limit_response(rule_type, key)
        
        # 记录请求
        await self._log_request(request, client_ip, user_id)
        
        response = await call_next(request)
        return response
    
    async def _check_rate_limit(
        self, 
        rule_type: str, 
        key: str, 
        identifier: str,
        endpoint: str
    ) -> bool:
        """检查限流规则"""
        try:
            # 获取限流配置
            if rule_type == 'endpoint' and endpoint in self.rules['endpoint']:
                config = self.rules['endpoint'][endpoint]
            else:
                config = self.rules.get(rule_type, {'limit': 100, 'window': 60})
            
            allowed, info = await self.limiter.is_allowed(
                key=key,
                limit=config['limit'],
                window=config['window'],
                identifier=identifier
            )
            
            if not allowed:
                logger.warning(
                    f"限流触发: {rule_type} | {key} | "
                    f"当前: {info['current']} | 限制: {info['limit']}"
                )
            
            return allowed
            
        except Exception as e:
            logger.error(f"限流检查异常: {e}")
            return True  # 异常时允许通过
    
    async def _rate_limit_response(self, rule_type: str, key: str) -> JSONResponse:
        """返回限流响应"""
        return JSONResponse(
            status_code=429,
            content={
                'success': False,
                'error_code': 'RATE_LIMIT_EXCEEDED',
                'message': '请求过于频繁，请稍后重试',
                'details': {
                    'rule_type': rule_type,
                    'retry_after': 60
                }
            },
            headers={
                'Retry-After': '60',
                'X-RateLimit-Rule': rule_type
            }
        )
    
    def _get_client_ip(self, request: Request) -> str:
        """获取客户端IP"""
        # 检查代理头
        forwarded_for = request.headers.get('X-Forwarded-For')
        if forwarded_for:
            return forwarded_for.split(',')[0].strip()
        
        real_ip = request.headers.get('X-Real-IP')
        if real_ip:
            return real_ip
        
        return request.client.host if request.client else '127.0.0.1'
    
    async def _get_user_id(self, request: Request) -> Optional[str]:
        """获取用户ID"""
        try:
            # 从JWT token中提取用户ID
            auth_header = request.headers.get('Authorization')
            if auth_header and auth_header.startswith('Bearer '):
                token = auth_header[7:]
                # 这里应该解析JWT获取用户ID
                # 简化示例，实际应该使用JWT库
                return 'user_from_token'
        except Exception:
            pass
        return None
    
    async def _log_request(self, request: Request, client_ip: str, user_id: Optional[str]):
        """记录请求日志"""
        try:
            log_data = {
                'timestamp': time.time(),
                'method': request.method,
                'path': request.url.path,
                'client_ip': client_ip,
                'user_id': user_id,
                'user_agent': request.headers.get('User-Agent', ''),
                'referer': request.headers.get('Referer', '')
            }
            
            # 异步记录到日志系统
            logger.info(f"API请求: {json.dumps(log_data)}")
            
        except Exception as e:
            logger.error(f"记录请求日志失败: {e}")
 ```

##### 审计日志增强

```python
# security/audit_logger.py
from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum
import json
import hashlib
import hmac
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import serialization
from sqlalchemy.ext.asyncio import AsyncSession
from database.models import AuditLog, AuditLogSignature
from config.settings import settings
import logging
import asyncio
from concurrent.futures import ThreadPoolExecutor

logger = logging.getLogger(__name__)

class AuditEventType(Enum):
    """审计事件类型"""
    USER_LOGIN = "user_login"
    USER_LOGOUT = "user_logout"
    LICENSE_ACTIVATE = "license_activate"
    LICENSE_VERIFY = "license_verify"
    LICENSE_CREATE = "license_create"
    LICENSE_DELETE = "license_delete"
    USER_CREATE = "user_create"
    USER_UPDATE = "user_update"
    USER_DELETE = "user_delete"
    PERMISSION_CHANGE = "permission_change"
    SYSTEM_CONFIG = "system_config"
    DATA_EXPORT = "data_export"
    DATA_IMPORT = "data_import"
    SECURITY_ALERT = "security_alert"

class AuditSeverity(Enum):
    """审计严重级别"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class AuditLogger:
    """审计日志记录器"""
    
    def __init__(self):
        self._executor = ThreadPoolExecutor(max_workers=2)
        self._signing_key = None
        self._batch_logs: List[Dict] = []
        self._batch_lock = asyncio.Lock()
        self._batch_task = None
        self._initialize_signing_key()
    
    def _initialize_signing_key(self):
        """初始化签名密钥"""
        try:
            # 从密钥管理器获取签名密钥
            from security.key_manager import key_manager
            self._signing_key = key_manager.get_current_key('api_signing')
        except Exception as e:
            logger.error(f"初始化审计日志签名密钥失败: {e}")
    
    async def log_event(
        self,
        event_type: AuditEventType,
        user_id: Optional[int] = None,
        resource_type: Optional[str] = None,
        resource_id: Optional[str] = None,
        action: str = "",
        details: Optional[Dict[str, Any]] = None,
        severity: AuditSeverity = AuditSeverity.MEDIUM,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        session_id: Optional[str] = None
    ):
        """记录审计事件"""
        try:
            # 构建审计日志记录
            log_entry = {
                'event_type': event_type.value,
                'user_id': user_id,
                'resource_type': resource_type,
                'resource_id': resource_id,
                'action': action,
                'details': details or {},
                'severity': severity.value,
                'ip_address': ip_address,
                'user_agent': user_agent,
                'session_id': session_id,
                'timestamp': datetime.utcnow().isoformat(),
                'server_id': settings.SERVER_ID,
                'version': settings.APP_VERSION
            }
            
            # 生成日志签名
            signature = await self._generate_signature(log_entry)
            log_entry['signature'] = signature
            
            # 添加到批处理队列
            await self._add_to_batch(log_entry)
            
        except Exception as e:
            logger.error(f"记录审计日志失败: {e}")
    
    async def _generate_signature(self, log_entry: Dict) -> str:
        """生成日志签名"""
        try:
            # 创建规范化的日志内容
            canonical_content = self._canonicalize_log_entry(log_entry)
            
            # 使用HMAC-SHA256生成签名
            if self._signing_key:
                key_data = json.loads(self._signing_key['key_data'])
                signing_key = key_data['key'].encode('utf-8')
                
                signature = hmac.new(
                    signing_key,
                    canonical_content.encode('utf-8'),
                    hashlib.sha256
                ).hexdigest()
                
                return signature
            else:
                logger.warning("审计日志签名密钥未找到")
                return ""
                
        except Exception as e:
            logger.error(f"生成审计日志签名失败: {e}")
            return ""
    
    def _canonicalize_log_entry(self, log_entry: Dict) -> str:
        """规范化日志条目"""
        # 排除签名字段，按键排序
        canonical_dict = {k: v for k, v in log_entry.items() if k != 'signature'}
        
        # 递归排序字典
        def sort_dict(obj):
            if isinstance(obj, dict):
                return {k: sort_dict(v) for k, v in sorted(obj.items())}
            elif isinstance(obj, list):
                return [sort_dict(item) for item in obj]
            else:
                return obj
        
        sorted_dict = sort_dict(canonical_dict)
        return json.dumps(sorted_dict, separators=(',', ':'), ensure_ascii=False)
    
    async def _add_to_batch(self, log_entry: Dict):
        """添加到批处理队列"""
        async with self._batch_lock:
            self._batch_logs.append(log_entry)
            
            # 如果批处理队列达到阈值或者没有正在运行的批处理任务，启动批处理
            if len(self._batch_logs) >= 10 or not self._batch_task:
                if not self._batch_task or self._batch_task.done():
                    self._batch_task = asyncio.create_task(self._process_batch())
    
    async def _process_batch(self):
        """处理批处理队列"""
        # 等待一小段时间收集更多日志
        await asyncio.sleep(1)
        
        async with self._batch_lock:
            if not self._batch_logs:
                return
            
            logs_to_process = self._batch_logs.copy()
            self._batch_logs.clear()
        
        try:
            await self._save_logs_to_database(logs_to_process)
        except Exception as e:
            logger.error(f"批处理保存审计日志失败: {e}")
            # 重新添加到队列
            async with self._batch_lock:
                self._batch_logs.extend(logs_to_process)
    
    async def _save_logs_to_database(self, logs: List[Dict]):
        """保存日志到数据库"""
        from database.connection import get_db
        
        async with get_db() as db:
            try:
                # 批量插入审计日志
                audit_logs = []
                signatures = []
                
                for log_entry in logs:
                    # 创建审计日志记录
                    audit_log = AuditLog(
                        event_type=log_entry['event_type'],
                        user_id=log_entry.get('user_id'),
                        resource_type=log_entry.get('resource_type'),
                        resource_id=log_entry.get('resource_id'),
                        action=log_entry['action'],
                        details=json.dumps(log_entry['details']),
                        severity=log_entry['severity'],
                        ip_address=log_entry.get('ip_address'),
                        user_agent=log_entry.get('user_agent'),
                        session_id=log_entry.get('session_id'),
                        timestamp=datetime.fromisoformat(log_entry['timestamp']),
                        server_id=log_entry['server_id'],
                        version=log_entry['version']
                    )
                    audit_logs.append(audit_log)
                
                # 批量插入
                db.add_all(audit_logs)
                await db.flush()  # 获取生成的ID
                
                # 创建签名记录
                for i, log_entry in enumerate(logs):
                    if log_entry.get('signature'):
                        signature_record = AuditLogSignature(
                            audit_log_id=audit_logs[i].id,
                            signature=log_entry['signature'],
                            algorithm='HMAC-SHA256',
                            key_id=self._signing_key['id'] if self._signing_key else None
                        )
                        signatures.append(signature_record)
                
                if signatures:
                    db.add_all(signatures)
                
                await db.commit()
                
                logger.info(f"成功保存 {len(logs)} 条审计日志")
                
            except Exception as e:
                await db.rollback()
                logger.error(f"保存审计日志到数据库失败: {e}")
                raise
    
    async def verify_log_integrity(
        self, 
        log_id: int, 
        expected_signature: str
    ) -> bool:
        """验证日志完整性"""
        try:
            from database.connection import get_db
            
            async with get_db() as db:
                # 获取审计日志
                result = await db.execute(
                    "SELECT * FROM audit_logs WHERE id = :log_id",
                    {'log_id': log_id}
                )
                log_record = result.fetchone()
                
                if not log_record:
                    return False
                
                # 重构日志条目
                log_entry = {
                    'event_type': log_record.event_type,
                    'user_id': log_record.user_id,
                    'resource_type': log_record.resource_type,
                    'resource_id': log_record.resource_id,
                    'action': log_record.action,
                    'details': json.loads(log_record.details) if log_record.details else {},
                    'severity': log_record.severity,
                    'ip_address': log_record.ip_address,
                    'user_agent': log_record.user_agent,
                    'session_id': log_record.session_id,
                    'timestamp': log_record.timestamp.isoformat(),
                    'server_id': log_record.server_id,
                    'version': log_record.version
                }
                
                # 重新生成签名
                regenerated_signature = await self._generate_signature(log_entry)
                
                # 比较签名
                return regenerated_signature == expected_signature
                
        except Exception as e:
            logger.error(f"验证日志完整性失败: {e}")
            return False
    
    async def get_audit_trail(
        self,
        user_id: Optional[int] = None,
        resource_type: Optional[str] = None,
        event_type: Optional[str] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        limit: int = 100
    ) -> List[Dict]:
        """获取审计轨迹"""
        try:
            from database.connection import get_db
            
            async with get_db() as db:
                query = "SELECT * FROM audit_logs WHERE 1=1"
                params = {}
                
                if user_id:
                    query += " AND user_id = :user_id"
                    params['user_id'] = user_id
                
                if resource_type:
                    query += " AND resource_type = :resource_type"
                    params['resource_type'] = resource_type
                
                if event_type:
                    query += " AND event_type = :event_type"
                    params['event_type'] = event_type
                
                if start_time:
                    query += " AND timestamp >= :start_time"
                    params['start_time'] = start_time
                
                if end_time:
                    query += " AND timestamp <= :end_time"
                    params['end_time'] = end_time
                
                query += " ORDER BY timestamp DESC LIMIT :limit"
                params['limit'] = limit
                
                result = await db.execute(query, params)
                records = result.fetchall()
                
                return [
                    {
                        'id': record.id,
                        'event_type': record.event_type,
                        'user_id': record.user_id,
                        'resource_type': record.resource_type,
                        'resource_id': record.resource_id,
                        'action': record.action,
                        'details': json.loads(record.details) if record.details else {},
                        'severity': record.severity,
                        'ip_address': record.ip_address,
                        'user_agent': record.user_agent,
                        'session_id': record.session_id,
                        'timestamp': record.timestamp.isoformat(),
                        'server_id': record.server_id,
                        'version': record.version
                    }
                    for record in records
                ]
                
        except Exception as e:
            logger.error(f"获取审计轨迹失败: {e}")
            return []
    
    async def cleanup(self):
        """清理资源"""
        # 处理剩余的批处理日志
        if self._batch_task and not self._batch_task.done():
            await self._batch_task
        
        # 处理剩余的日志
        if self._batch_logs:
            await self._save_logs_to_database(self._batch_logs)
        
        # 关闭线程池
        self._executor.shutdown(wait=True)
        
        logger.info("审计日志记录器已清理")

# 全局审计日志记录器实例
audit_logger = AuditLogger()
```

##### 审计日志数据库表

```sql
-- 审计日志表
CREATE TABLE audit_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    event_type VARCHAR(50) NOT NULL COMMENT '事件类型',
    user_id BIGINT NULL COMMENT '用户ID',
    resource_type VARCHAR(50) NULL COMMENT '资源类型',
    resource_id VARCHAR(100) NULL COMMENT '资源ID',
    action VARCHAR(100) NOT NULL COMMENT '操作描述',
    details JSON NULL COMMENT '详细信息',
    severity ENUM('low', 'medium', 'high', 'critical') DEFAULT 'medium' COMMENT '严重级别',
    ip_address VARCHAR(45) NULL COMMENT 'IP地址',
    user_agent TEXT NULL COMMENT '用户代理',
    session_id VARCHAR(100) NULL COMMENT '会话ID',
    timestamp TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6) COMMENT '时间戳',
    server_id VARCHAR(50) NULL COMMENT '服务器ID',
    version VARCHAR(20) NULL COMMENT '应用版本',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    
    INDEX idx_event_type (event_type),
    INDEX idx_user_id (user_id),
    INDEX idx_resource (resource_type, resource_id),
    INDEX idx_timestamp (timestamp),
    INDEX idx_severity (severity),
    INDEX idx_ip_address (ip_address)
) COMMENT='审计日志表';

-- 审计日志签名表
CREATE TABLE audit_log_signatures (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    audit_log_id BIGINT NOT NULL,
    signature VARCHAR(512) NOT NULL COMMENT '日志签名',
    algorithm VARCHAR(50) NOT NULL COMMENT '签名算法',
    key_id BIGINT NULL COMMENT '签名密钥ID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    
    FOREIGN KEY (audit_log_id) REFERENCES audit_logs(id) ON DELETE CASCADE,
    FOREIGN KEY (key_id) REFERENCES security_keys(id),
    UNIQUE KEY uk_audit_log_id (audit_log_id),
    INDEX idx_key_id (key_id)
) COMMENT='审计日志签名表';
```

#### 3.3.3 数据库连接池优化

##### 连接池配置管理

```python
# database/pool_manager.py
from typing import Dict, Optional, Any
from sqlalchemy.ext.asyncio import create_async_engine, AsyncEngine
from sqlalchemy.pool import QueuePool, NullPool
from sqlalchemy import event
from config.settings import settings
import logging
import asyncio
import time
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class PoolStatus(Enum):
    """连接池状态"""
    HEALTHY = "healthy"
    WARNING = "warning"
    CRITICAL = "critical"
    UNAVAILABLE = "unavailable"

@dataclass
class PoolMetrics:
    """连接池指标"""
    total_connections: int = 0
    active_connections: int = 0
    idle_connections: int = 0
    checked_out_connections: int = 0
    overflow_connections: int = 0
    invalid_connections: int = 0
    pool_size: int = 0
    max_overflow: int = 0
    status: PoolStatus = PoolStatus.HEALTHY
    last_updated: float = 0

class DatabasePoolManager:
    """数据库连接池管理器"""
    
    def __init__(self):
        self._engines: Dict[str, AsyncEngine] = {}
        self._metrics: Dict[str, PoolMetrics] = {}
        self._monitor_task: Optional[asyncio.Task] = None
        self._health_check_interval = 30  # 30秒检查一次
    
    async def initialize(self):
        """初始化连接池管理器"""
        try:
            # 创建主数据库连接池
            await self._create_engine(
                'primary',
                settings.DATABASE_URL,
                {
                    'pool_size': settings.DB_POOL_SIZE,
                    'max_overflow': settings.DB_MAX_OVERFLOW,
                    'pool_timeout': settings.DB_POOL_TIMEOUT,
                    'pool_recycle': settings.DB_POOL_RECYCLE,
                    'pool_pre_ping': True,
                    'poolclass': QueuePool
                }
            )
            
            # 如果配置了只读数据库，创建只读连接池
            if hasattr(settings, 'DATABASE_READONLY_URL') and settings.DATABASE_READONLY_URL:
                await self._create_engine(
                    'readonly',
                    settings.DATABASE_READONLY_URL,
                    {
                        'pool_size': settings.DB_READONLY_POOL_SIZE or 5,
                        'max_overflow': settings.DB_READONLY_MAX_OVERFLOW or 10,
                        'pool_timeout': 30,
                        'pool_recycle': 3600,
                        'pool_pre_ping': True,
                        'poolclass': QueuePool
                    }
                )
            
            # 启动监控任务
            self._monitor_task = asyncio.create_task(self._monitor_pools())
            
            logger.info("数据库连接池管理器初始化完成")
            
        except Exception as e:
            logger.error(f"初始化数据库连接池失败: {e}")
            raise
    
    async def _create_engine(self, name: str, url: str, pool_config: Dict[str, Any]):
        """创建数据库引擎"""
        try:
            engine = create_async_engine(
                url,
                echo=settings.DEBUG,
                **pool_config
            )
            
            # 注册连接池事件监听器
            self._register_pool_events(engine, name)
            
            self._engines[name] = engine
            self._metrics[name] = PoolMetrics(
                pool_size=pool_config.get('pool_size', 5),
                max_overflow=pool_config.get('max_overflow', 10)
            )
            
            logger.info(f"已创建数据库引擎: {name}")
            
        except Exception as e:
            logger.error(f"创建数据库引擎 {name} 失败: {e}")
            raise
    
    def _register_pool_events(self, engine: AsyncEngine, name: str):
        """注册连接池事件监听器"""
        
        @event.listens_for(engine.sync_engine.pool, "connect")
        def on_connect(dbapi_conn, connection_record):
            logger.debug(f"连接池 {name}: 新连接建立")
        
        @event.listens_for(engine.sync_engine.pool, "checkout")
        def on_checkout(dbapi_conn, connection_record, connection_proxy):
            logger.debug(f"连接池 {name}: 连接被检出")
        
        @event.listens_for(engine.sync_engine.pool, "checkin")
        def on_checkin(dbapi_conn, connection_record):
            logger.debug(f"连接池 {name}: 连接被归还")
        
        @event.listens_for(engine.sync_engine.pool, "invalidate")
        def on_invalidate(dbapi_conn, connection_record, exception):
            logger.warning(f"连接池 {name}: 连接被标记为无效 - {exception}")
    
    async def _monitor_pools(self):
        """监控连接池状态"""
        while True:
            try:
                await self._update_metrics()
                await self._check_pool_health()
                await asyncio.sleep(self._health_check_interval)
            except Exception as e:
                logger.error(f"连接池监控任务出错: {e}")
                await asyncio.sleep(5)
    
    async def _update_metrics(self):
        """更新连接池指标"""
        for name, engine in self._engines.items():
            try:
                pool = engine.pool
                metrics = self._metrics[name]
                
                # 更新连接池指标
                metrics.total_connections = pool.size()
                metrics.checked_out_connections = pool.checkedout()
                metrics.overflow_connections = pool.overflow()
                metrics.invalid_connections = pool.invalidated()
                metrics.idle_connections = metrics.total_connections - metrics.checked_out_connections
                metrics.active_connections = metrics.checked_out_connections
                metrics.last_updated = time.time()
                
                # 评估连接池状态
                metrics.status = self._evaluate_pool_status(metrics)
                
            except Exception as e:
                logger.error(f"更新连接池 {name} 指标失败: {e}")
    
    def _evaluate_pool_status(self, metrics: PoolMetrics) -> PoolStatus:
        """评估连接池状态"""
        total_capacity = metrics.pool_size + metrics.max_overflow
        usage_ratio = metrics.active_connections / total_capacity if total_capacity > 0 else 0
        
        if metrics.invalid_connections > 0:
            return PoolStatus.CRITICAL
        elif usage_ratio >= 0.9:
            return PoolStatus.CRITICAL
        elif usage_ratio >= 0.7:
            return PoolStatus.WARNING
        else:
            return PoolStatus.HEALTHY
    
    async def _check_pool_health(self):
        """检查连接池健康状态"""
        for name, metrics in self._metrics.items():
            if metrics.status in [PoolStatus.CRITICAL, PoolStatus.WARNING]:
                logger.warning(
                    f"连接池 {name} 状态异常: {metrics.status.value} | "
                    f"活跃连接: {metrics.active_connections}/{metrics.pool_size + metrics.max_overflow} | "
                    f"无效连接: {metrics.invalid_connections}"
                )
                
                # 如果是严重状态，尝试恢复
                if metrics.status == PoolStatus.CRITICAL:
                    await self._attempt_pool_recovery(name)
    
    async def _attempt_pool_recovery(self, pool_name: str):
        """尝试恢复连接池"""
        try:
            engine = self._engines.get(pool_name)
            if engine:
                # 清理无效连接
                await engine.dispose()
                logger.info(f"已清理连接池 {pool_name} 的无效连接")
        except Exception as e:
            logger.error(f"恢复连接池 {pool_name} 失败: {e}")
    
    def get_engine(self, name: str = 'primary') -> Optional[AsyncEngine]:
        """获取数据库引擎"""
        return self._engines.get(name)
    
    def get_metrics(self, name: str = 'primary') -> Optional[PoolMetrics]:
        """获取连接池指标"""
        return self._metrics.get(name)
    
    def get_all_metrics(self) -> Dict[str, PoolMetrics]:
        """获取所有连接池指标"""
        return self._metrics.copy()
    
    async def health_check(self) -> Dict[str, Any]:
        """健康检查"""
        health_status = {
            'overall_status': 'healthy',
            'pools': {},
            'timestamp': time.time()
        }
        
        critical_count = 0
        warning_count = 0
        
        for name, metrics in self._metrics.items():
            pool_health = {
                'status': metrics.status.value,
                'active_connections': metrics.active_connections,
                'total_connections': metrics.total_connections,
                'pool_size': metrics.pool_size,
                'max_overflow': metrics.max_overflow,
                'usage_ratio': metrics.active_connections / (metrics.pool_size + metrics.max_overflow) if (metrics.pool_size + metrics.max_overflow) > 0 else 0
            }
            
            health_status['pools'][name] = pool_health
            
            if metrics.status == PoolStatus.CRITICAL:
                critical_count += 1
            elif metrics.status == PoolStatus.WARNING:
                warning_count += 1
        
        # 确定整体状态
        if critical_count > 0:
            health_status['overall_status'] = 'critical'
        elif warning_count > 0:
            health_status['overall_status'] = 'warning'
        
        return health_status
    
    async def cleanup(self):
        """清理资源"""
        # 停止监控任务
        if self._monitor_task:
            self._monitor_task.cancel()
            try:
                await self._monitor_task
            except asyncio.CancelledError:
                pass
        
        # 关闭所有数据库引擎
        for name, engine in self._engines.items():
            try:
                await engine.dispose()
                logger.info(f"已关闭数据库引擎: {name}")
            except Exception as e:
                logger.error(f"关闭数据库引擎 {name} 失败: {e}")
        
        self._engines.clear()
        self._metrics.clear()
        
        logger.info("数据库连接池管理器已清理")

# 全局连接池管理器实例
pool_manager = DatabasePoolManager()
```

##### 连接池监控API

```python
# api/monitoring/pool_status.py
from fastapi import APIRouter, Depends, HTTPException
from typing import Dict, Any
from database.pool_manager import pool_manager
from auth.dependencies import require_admin
from utils.response import success_response

router = APIRouter(prefix="/api/monitoring", tags=["监控"])

@router.get("/pool/health")
async def get_pool_health(
    current_user = Depends(require_admin)
) -> Dict[str, Any]:
    """获取连接池健康状态"""
    try:
        health_status = await pool_manager.health_check()
        return success_response(data=health_status)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取连接池状态失败: {str(e)}")

@router.get("/pool/metrics")
async def get_pool_metrics(
    current_user = Depends(require_admin)
) -> Dict[str, Any]:
    """获取连接池详细指标"""
    try:
        all_metrics = pool_manager.get_all_metrics()
        metrics_data = {}
        
        for name, metrics in all_metrics.items():
            metrics_data[name] = {
                'total_connections': metrics.total_connections,
                'active_connections': metrics.active_connections,
                'idle_connections': metrics.idle_connections,
                'checked_out_connections': metrics.checked_out_connections,
                'overflow_connections': metrics.overflow_connections,
                'invalid_connections': metrics.invalid_connections,
                'pool_size': metrics.pool_size,
                'max_overflow': metrics.max_overflow,
                'status': metrics.status.value,
                'last_updated': metrics.last_updated
            }
        
        return success_response(data=metrics_data)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取连接池指标失败: {str(e)}")
```

#### 3.3.4 性能优化专项

##### 卡密查询优化

```python
# services/license_service_optimized.py
from typing import List, Dict, Any, Optional, Tuple
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func, and_, or_, text
from sqlalchemy.orm import selectinload, joinedload
from database.models import License, User, Application
from database.connection import get_db
from utils.cache import cache_manager
from utils.pagination import PaginationParams, PaginationResult
import logging
import asyncio
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class OptimizedLicenseService:
    """优化的卡密服务"""
    
    def __init__(self):
        self._cache_ttl = 300  # 5分钟缓存
        self._batch_size = 1000  # 批处理大小
    
    async def search_licenses_optimized(
        self,
        pagination: PaginationParams,
        filters: Optional[Dict[str, Any]] = None,
        sort_by: str = "created_at",
        sort_order: str = "desc"
    ) -> PaginationResult:
        """优化的卡密搜索"""
        try:
            # 构建缓存键
            cache_key = self._build_search_cache_key(pagination, filters, sort_by, sort_order)
            
            # 尝试从缓存获取
            cached_result = await cache_manager.get(cache_key)
            if cached_result:
                logger.debug(f"从缓存获取卡密搜索结果: {cache_key}")
                return PaginationResult.from_dict(cached_result)
            
            async with get_db() as db:
                # 构建优化的查询
                query = await self._build_optimized_query(db, filters, sort_by, sort_order)
                
                # 执行计数查询（优化版本）
                total_count = await self._get_optimized_count(db, filters)
                
                # 执行分页查询
                offset = (pagination.page - 1) * pagination.page_size
                query = query.offset(offset).limit(pagination.page_size)
                
                # 使用预加载优化关联查询
                query = query.options(
                    selectinload(License.user),
                    selectinload(License.application)
                )
                
                result = await db.execute(query)
                licenses = result.scalars().all()
                
                # 构建结果
                items = [
                    {
                        'id': license.id,
                        'license_key': license.license_key,
                        'status': license.status,
                        'expires_at': license.expires_at.isoformat() if license.expires_at else None,
                        'created_at': license.created_at.isoformat(),
                        'user': {
                            'id': license.user.id,
                            'username': license.user.username
                        } if license.user else None,
                        'application': {
                            'id': license.application.id,
                            'name': license.application.name
                        } if license.application else None
                    }
                    for license in licenses
                ]
                
                pagination_result = PaginationResult(
                    items=items,
                    total=total_count,
                    page=pagination.page,
                    page_size=pagination.page_size,
                    total_pages=(total_count + pagination.page_size - 1) // pagination.page_size
                )
                
                # 缓存结果
                await cache_manager.set(
                    cache_key, 
                    pagination_result.to_dict(), 
                    ttl=self._cache_ttl
                )
                
                return pagination_result
                
        except Exception as e:
            logger.error(f"优化卡密搜索失败: {e}")
            raise
    
    async def _build_optimized_query(
        self, 
        db: AsyncSession, 
        filters: Optional[Dict[str, Any]], 
        sort_by: str, 
        sort_order: str
    ):
        """构建优化的查询"""
        # 基础查询
        query = select(License)
        
        # 应用过滤条件
        if filters:
            conditions = []
            
            if filters.get('status'):
                conditions.append(License.status == filters['status'])
            
            if filters.get('user_id'):
                conditions.append(License.user_id == filters['user_id'])
            
            if filters.get('application_id'):
                conditions.append(License.application_id == filters['application_id'])
            
            if filters.get('license_key'):
                # 使用索引友好的前缀匹配
                conditions.append(License.license_key.like(f"{filters['license_key']}%"))
            
            if filters.get('created_after'):
                conditions.append(License.created_at >= filters['created_after'])
            
            if filters.get('created_before'):
                conditions.append(License.created_at <= filters['created_before'])
            
            if filters.get('expires_after'):
                conditions.append(License.expires_at >= filters['expires_after'])
            
            if filters.get('expires_before'):
                conditions.append(License.expires_at <= filters['expires_before'])
            
            if conditions:
                query = query.where(and_(*conditions))
        
        # 应用排序
        sort_column = getattr(License, sort_by, License.created_at)
        if sort_order.lower() == 'desc':
            query = query.order_by(sort_column.desc())
        else:
            query = query.order_by(sort_column.asc())
        
        return query
    
    async def _get_optimized_count(
        self, 
        db: AsyncSession, 
        filters: Optional[Dict[str, Any]]
    ) -> int:
        """获取优化的计数"""
        # 构建计数查询
        count_query = select(func.count(License.id))
        
        # 应用相同的过滤条件
        if filters:
            conditions = []
            
            if filters.get('status'):
                conditions.append(License.status == filters['status'])
            
            if filters.get('user_id'):
                conditions.append(License.user_id == filters['user_id'])
            
            if filters.get('application_id'):
                conditions.append(License.application_id == filters['application_id'])
            
            if filters.get('license_key'):
                conditions.append(License.license_key.like(f"{filters['license_key']}%"))
            
            if filters.get('created_after'):
                conditions.append(License.created_at >= filters['created_after'])
            
            if filters.get('created_before'):
                conditions.append(License.created_at <= filters['created_before'])
            
            if filters.get('expires_after'):
                conditions.append(License.expires_at >= filters['expires_after'])
            
            if filters.get('expires_before'):
                conditions.append(License.expires_at <= filters['expires_before'])
            
            if conditions:
                count_query = count_query.where(and_(*conditions))
        
        result = await db.execute(count_query)
        return result.scalar() or 0
    
    def _build_search_cache_key(
        self, 
        pagination: PaginationParams, 
        filters: Optional[Dict[str, Any]], 
        sort_by: str, 
        sort_order: str
    ) -> str:
        """构建搜索缓存键"""
        import hashlib
        import json
        
        cache_data = {
            'page': pagination.page,
            'page_size': pagination.page_size,
            'filters': filters or {},
            'sort_by': sort_by,
            'sort_order': sort_order
        }
        
        cache_str = json.dumps(cache_data, sort_keys=True)
        cache_hash = hashlib.md5(cache_str.encode()).hexdigest()
        
        return f"license_search:{cache_hash}"
    
    async def batch_update_licenses(
        self, 
        license_ids: List[int], 
        update_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """批量更新卡密"""
        try:
            async with get_db() as db:
                # 分批处理
                total_updated = 0
                failed_ids = []
                
                for i in range(0, len(license_ids), self._batch_size):
                    batch_ids = license_ids[i:i + self._batch_size]
                    
                    try:
                        # 批量更新
                        update_query = (
                            License.__table__.update()
                            .where(License.id.in_(batch_ids))
                            .values(**update_data)
                        )
                        
                        result = await db.execute(update_query)
                        total_updated += result.rowcount
                        
                    except Exception as e:
                        logger.error(f"批量更新卡密失败 (批次 {i//self._batch_size + 1}): {e}")
                        failed_ids.extend(batch_ids)
                
                await db.commit()
                
                # 清理相关缓存
                await self._clear_license_cache()
                
                return {
                    'total_updated': total_updated,
                    'failed_count': len(failed_ids),
                    'failed_ids': failed_ids
                }
                
        except Exception as e:
            logger.error(f"批量更新卡密失败: {e}")
            raise
    
    async def get_license_statistics(
        self, 
        date_range: Optional[Tuple[datetime, datetime]] = None
    ) -> Dict[str, Any]:
        """获取卡密统计信息"""
        try:
            cache_key = f"license_stats:{date_range[0].date() if date_range else 'all'}:{date_range[1].date() if date_range else 'all'}"
            
            # 尝试从缓存获取
            cached_stats = await cache_manager.get(cache_key)
            if cached_stats:
                return cached_stats
            
            async with get_db() as db:
                # 基础统计查询
                base_query = select(License)
                
                if date_range:
                    base_query = base_query.where(
                        and_(
                            License.created_at >= date_range[0],
                            License.created_at <= date_range[1]
                        )
                    )
                
                # 总数统计
                total_query = select(func.count(License.id)).select_from(base_query.subquery())
                total_result = await db.execute(total_query)
                total_count = total_result.scalar() or 0
                
                # 状态统计
                status_query = (
                    select(License.status, func.count(License.id))
                    .select_from(base_query.subquery())
                    .group_by(License.status)
                )
                status_result = await db.execute(status_query)
                status_stats = {row[0]: row[1] for row in status_result.fetchall()}
                
                # 应用统计
                app_query = (
                    select(Application.name, func.count(License.id))
                    .select_from(
                        base_query.subquery().join(Application, License.application_id == Application.id)
                    )
                    .group_by(Application.name)
                    .order_by(func.count(License.id).desc())
                    .limit(10)
                )
                app_result = await db.execute(app_query)
                app_stats = {row[0]: row[1] for row in app_result.fetchall()}
                
                # 时间趋势统计（最近30天）
                if not date_range:
                    trend_start = datetime.utcnow() - timedelta(days=30)
                    trend_query = (
                        select(
                            func.date(License.created_at).label('date'),
                            func.count(License.id).label('count')
                        )
                        .where(License.created_at >= trend_start)
                        .group_by(func.date(License.created_at))
                        .order_by(func.date(License.created_at))
                    )
                    trend_result = await db.execute(trend_query)
                    trend_stats = [
                        {'date': row.date.isoformat(), 'count': row.count}
                        for row in trend_result.fetchall()
                    ]
                else:
                    trend_stats = []
                
                stats = {
                    'total_count': total_count,
                    'status_distribution': status_stats,
                    'top_applications': app_stats,
                    'daily_trend': trend_stats,
                    'generated_at': datetime.utcnow().isoformat()
                }
                
                # 缓存统计结果
                await cache_manager.set(cache_key, stats, ttl=600)  # 10分钟缓存
                
                return stats
                
        except Exception as e:
            logger.error(f"获取卡密统计失败: {e}")
            raise
    
    async def _clear_license_cache(self):
        """清理卡密相关缓存"""
        try:
            # 清理搜索缓存
            await cache_manager.delete_pattern("license_search:*")
            # 清理统计缓存
            await cache_manager.delete_pattern("license_stats:*")
            logger.info("已清理卡密相关缓存")
        except Exception as e:
            logger.error(f"清理卡密缓存失败: {e}")

# 全局优化服务实例
optimized_license_service = OptimizedLicenseService()
```

##### 数据库索引优化

```sql
-- 卡密表索引优化
-- 复合索引：状态 + 创建时间
CREATE INDEX idx_licenses_status_created ON licenses(status, created_at DESC);

-- 复合索引：用户ID + 状态
CREATE INDEX idx_licenses_user_status ON licenses(user_id, status);

-- 复合索引：应用ID + 状态 + 创建时间
CREATE INDEX idx_licenses_app_status_created ON licenses(application_id, status, created_at DESC);

-- 复合索引：过期时间 + 状态（用于过期检查）
CREATE INDEX idx_licenses_expires_status ON licenses(expires_at, status);

-- 卡密前缀索引（用于模糊搜索优化）
CREATE INDEX idx_licenses_key_prefix ON licenses(license_key(10));

-- 用户表索引优化
CREATE INDEX idx_users_username_status ON users(username, status);
CREATE INDEX idx_users_email_status ON users(email, status);
CREATE INDEX idx_users_created_at ON users(created_at DESC);

-- 应用表索引优化
CREATE INDEX idx_applications_name_status ON applications(name, status);
CREATE INDEX idx_applications_created_at ON applications(created_at DESC);

-- 审计日志表索引优化
CREATE INDEX idx_audit_logs_user_event_time ON audit_logs(user_id, event_type, timestamp DESC);
CREATE INDEX idx_audit_logs_resource_time ON audit_logs(resource_type, resource_id, timestamp DESC);
CREATE INDEX idx_audit_logs_severity_time ON audit_logs(severity, timestamp DESC);
```

#### 3.3.5 前端类型定义完善

##### API响应类型定义

```typescript
// types/api.ts
export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  error?: string;
  timestamp: string;
}

export interface PaginationParams {
  page: number;
  page_size: number;
}

export interface PaginationResponse<T> {
  items: T[];
  total: number;
  page: number;
  page_size: number;
  total_pages: number;
}

// 用户相关类型
export interface User {
  id: number;
  username: string;
  email: string;
  role: 'admin' | 'user';
  status: 'active' | 'inactive' | 'banned';
  created_at: string;
  updated_at: string;
  last_login?: string;
  profile?: UserProfile;
}

export interface UserProfile {
  avatar?: string;
  nickname?: string;
  phone?: string;
  bio?: string;
}

export interface CreateUserRequest {
  username: string;
  email: string;
  password: string;
  role?: 'admin' | 'user';
  profile?: Partial<UserProfile>;
}

export interface UpdateUserRequest {
  email?: string;
  role?: 'admin' | 'user';
  status?: 'active' | 'inactive' | 'banned';
  profile?: Partial<UserProfile>;
}

// 卡密相关类型
export interface License {
  id: number;
  license_key: string;
  status: 'active' | 'inactive' | 'expired' | 'banned';
  type: 'trial' | 'standard' | 'premium' | 'enterprise';
  duration_days: number;
  max_devices: number;
  expires_at?: string;
  created_at: string;
  updated_at: string;
  user_id?: number;
  application_id: number;
  user?: User;
  application?: Application;
  devices?: Device[];
  usage_stats?: LicenseUsageStats;
}

export interface LicenseUsageStats {
  total_activations: number;
  active_devices: number;
  last_used_at?: string;
  total_usage_hours: number;
}

export interface CreateLicenseRequest {
  type: 'trial' | 'standard' | 'premium' | 'enterprise';
  duration_days: number;
  max_devices: number;
  application_id: number;
  user_id?: number;
  batch_size?: number;
}

export interface UpdateLicenseRequest {
  status?: 'active' | 'inactive' | 'expired' | 'banned';
  duration_days?: number;
  max_devices?: number;
  expires_at?: string;
}

export interface LicenseSearchFilters {
  status?: string;
  type?: string;
  user_id?: number;
  application_id?: number;
  license_key?: string;
  created_after?: string;
  created_before?: string;
  expires_after?: string;
  expires_before?: string;
}

// 应用相关类型
export interface Application {
  id: number;
  name: string;
  description?: string;
  version: string;
  status: 'active' | 'inactive' | 'maintenance';
  api_key: string;
  webhook_url?: string;
  settings: ApplicationSettings;
  created_at: string;
  updated_at: string;
  license_count?: number;
  active_license_count?: number;
}

export interface ApplicationSettings {
  max_devices_per_license: number;
  allow_device_transfer: boolean;
  require_online_verification: boolean;
  verification_interval_hours: number;
  auto_ban_on_violation: boolean;
  custom_fields?: Record<string, any>;
}

export interface CreateApplicationRequest {
  name: string;
  description?: string;
  version: string;
  webhook_url?: string;
  settings: ApplicationSettings;
}

export interface UpdateApplicationRequest {
  name?: string;
  description?: string;
  version?: string;
  status?: 'active' | 'inactive' | 'maintenance';
  webhook_url?: string;
  settings?: Partial<ApplicationSettings>;
}

// 设备相关类型
export interface Device {
  id: number;
  device_id: string;
  device_name: string;
  device_type: 'desktop' | 'mobile' | 'server' | 'other';
  os_info: string;
  hardware_info: string;
  status: 'active' | 'inactive' | 'banned';
  first_seen_at: string;
  last_seen_at: string;
  license_id: number;
  license?: License;
}

export interface DeviceVerificationRequest {
  device_id: string;
  device_name: string;
  device_type: 'desktop' | 'mobile' | 'server' | 'other';
  os_info: string;
  hardware_info: string;
}

// 公告相关类型
export interface Announcement {
  id: number;
  title: string;
  content: string;
  type: 'info' | 'warning' | 'error' | 'success';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  status: 'draft' | 'published' | 'archived';
  target_audience: 'all' | 'users' | 'admins' | 'specific';
  target_user_ids?: number[];
  target_application_ids?: number[];
  publish_at?: string;
  expires_at?: string;
  created_at: string;
  updated_at: string;
  author_id: number;
  author?: User;
  read_count: number;
  is_read?: boolean;
}

export interface CreateAnnouncementRequest {
  title: string;
  content: string;
  type: 'info' | 'warning' | 'error' | 'success';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  target_audience: 'all' | 'users' | 'admins' | 'specific';
  target_user_ids?: number[];
  target_application_ids?: number[];
  publish_at?: string;
  expires_at?: string;
}

export interface UpdateAnnouncementRequest {
  title?: string;
  content?: string;
  type?: 'info' | 'warning' | 'error' | 'success';
  priority?: 'low' | 'medium' | 'high' | 'urgent';
  status?: 'draft' | 'published' | 'archived';
  target_audience?: 'all' | 'users' | 'admins' | 'specific';
  target_user_ids?: number[];
  target_application_ids?: number[];
  publish_at?: string;
  expires_at?: string;
}

// 统计相关类型
export interface DashboardStats {
  total_users: number;
  active_users: number;
  total_licenses: number;
  active_licenses: number;
  total_applications: number;
  active_applications: number;
  total_devices: number;
  active_devices: number;
  recent_activities: ActivityLog[];
  license_trend: TrendData[];
  user_trend: TrendData[];
}

export interface TrendData {
  date: string;
  count: number;
}

export interface ActivityLog {
  id: number;
  action: string;
  resource_type: string;
  resource_id: string;
  user_id: number;
  user?: User;
  timestamp: string;
  details?: Record<string, any>;
}

// 系统配置类型
export interface SystemConfig {
  site_name: string;
  site_description: string;
  site_logo?: string;
  contact_email: string;
  max_devices_per_user: number;
  default_license_duration: number;
  enable_user_registration: boolean;
  require_email_verification: boolean;
  session_timeout_minutes: number;
  max_login_attempts: number;
  lockout_duration_minutes: number;
  enable_audit_log: boolean;
  log_retention_days: number;
}

export interface UpdateSystemConfigRequest {
  site_name?: string;
  site_description?: string;
  site_logo?: string;
  contact_email?: string;
  max_devices_per_user?: number;
  default_license_duration?: number;
  enable_user_registration?: boolean;
  require_email_verification?: boolean;
  session_timeout_minutes?: number;
  max_login_attempts?: number;
  lockout_duration_minutes?: number;
  enable_audit_log?: boolean;
  log_retention_days?: number;
}

// WebSocket消息类型
export interface WebSocketMessage {
  type: string;
  data: any;
  timestamp: string;
}

export interface NotificationMessage extends WebSocketMessage {
  type: 'notification';
  data: {
    id: number;
    title: string;
    message: string;
    type: 'info' | 'warning' | 'error' | 'success';
    action_url?: string;
  };
}

export interface SystemStatusMessage extends WebSocketMessage {
  type: 'system_status';
  data: {
    status: 'online' | 'maintenance' | 'offline';
    message?: string;
  };
}

// 错误类型
export interface ApiError {
  code: string;
  message: string;
  details?: Record<string, any>;
  timestamp: string;
}

export interface ValidationError {
  field: string;
  message: string;
  code: string;
}

// 表单类型
export interface LoginForm {
  username: string;
  password: string;
  remember_me?: boolean;
}

export interface RegisterForm {
  username: string;
  email: string;
  password: string;
  confirm_password: string;
  agree_terms: boolean;
}

export interface ChangePasswordForm {
  current_password: string;
  new_password: string;
  confirm_password: string;
}

export interface ResetPasswordForm {
  email: string;
}

export interface ResetPasswordConfirmForm {
  token: string;
  new_password: string;
  confirm_password: string;
}
```

##### API客户端类型定义

```typescript
// services/api-client.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';
import { ApiResponse, PaginationResponse } from '@/types/api';

class ApiClient {
  private instance: AxiosInstance;

  constructor(baseURL: string) {
    this.instance = axios.create({
      baseURL,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // 请求拦截器
    this.instance.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('access_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // 响应拦截器
    this.instance.interceptors.response.use(
      (response: AxiosResponse<ApiResponse>) => response,
      (error) => {
        if (error.response?.status === 401) {
          // 处理未授权错误
          localStorage.removeItem('access_token');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T = any>(
    url: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.instance.get<ApiResponse<T>>(url, config);
    return response.data;
  }

  async post<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.instance.post<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async put<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.instance.put<ApiResponse<T>>(url, data, config);
    return response.data;
  }

  async delete<T = any>(
    url: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.instance.delete<ApiResponse<T>>(url, config);
    return response.data;
  }

  async patch<T = any>(
    url: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    const response = await this.instance.patch<ApiResponse<T>>(url, data, config);
    return response.data;
  }
}

export const apiClient = new ApiClient(process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000');
```

#### 3.3.6 日志系统升级

##### 结构化日志框架

```python
# utils/logging_config.py
import logging
import logging.handlers
import json
import traceback
from datetime import datetime
from typing import Dict, Any, Optional
from pathlib import Path
from enum import Enum
import asyncio
from contextlib import contextmanager

class LogLevel(Enum):
    """日志级别枚举"""
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARNING = "WARNING"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"

class StructuredFormatter(logging.Formatter):
    """结构化日志格式化器"""
    
    def format(self, record: logging.LogRecord) -> str:
        """格式化日志记录"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno,
            'thread_id': record.thread,
            'process_id': record.process
        }
        
        # 添加异常信息
        if record.exc_info:
            log_data['exception'] = {
                'type': record.exc_info[0].__name__,
                'message': str(record.exc_info[1]),
                'traceback': traceback.format_exception(*record.exc_info)
            }
        
        # 添加自定义字段
        if hasattr(record, 'extra_data'):
            log_data.update(record.extra_data)
        
        # 添加请求上下文（如果存在）
        if hasattr(record, 'request_id'):
            log_data['request_id'] = record.request_id
        
        if hasattr(record, 'user_id'):
            log_data['user_id'] = record.user_id
        
        if hasattr(record, 'session_id'):
            log_data['session_id'] = record.session_id
        
        return json.dumps(log_data, ensure_ascii=False)

class AsyncFileHandler(logging.handlers.RotatingFileHandler):
    """异步文件处理器"""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._write_queue = asyncio.Queue()
        self._writer_task = None
    
    async def start_writer(self):
        """启动异步写入任务"""
        if self._writer_task is None:
            self._writer_task = asyncio.create_task(self._write_worker())
    
    async def stop_writer(self):
        """停止异步写入任务"""
        if self._writer_task:
            self._writer_task.cancel()
            try:
                await self._writer_task
            except asyncio.CancelledError:
                pass
            self._writer_task = None
    
    async def _write_worker(self):
        """异步写入工作器"""
        while True:
            try:
                record = await self._write_queue.get()
                if record is None:  # 停止信号
                    break
                super().emit(record)
                self._write_queue.task_done()
            except asyncio.CancelledError:
                break
            except Exception as e:
                print(f"日志写入错误: {e}")
    
    def emit(self, record):
        """发送日志记录到队列"""
        try:
            self._write_queue.put_nowait(record)
        except asyncio.QueueFull:
            # 队列满时丢弃最旧的记录
            try:
                self._write_queue.get_nowait()
                self._write_queue.put_nowait(record)
            except asyncio.QueueEmpty:
                pass

class LoggerManager:
    """日志管理器"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.loggers: Dict[str, logging.Logger] = {}
        self.handlers: Dict[str, logging.Handler] = {}
        self._setup_logging()
    
    def _setup_logging(self):
        """设置日志配置"""
        # 创建日志目录
        log_dir = Path(self.config.get('log_dir', 'logs'))
        log_dir.mkdir(exist_ok=True)
        
        # 设置根日志级别
        root_logger = logging.getLogger()
        root_logger.setLevel(getattr(logging, self.config.get('level', 'INFO')))
        
        # 创建格式化器
        formatter = StructuredFormatter()
        
        # 创建控制台处理器
        if self.config.get('console_enabled', True):
            console_handler = logging.StreamHandler()
            console_handler.setFormatter(formatter)
            console_handler.setLevel(getattr(logging, self.config.get('console_level', 'INFO')))
            root_logger.addHandler(console_handler)
            self.handlers['console'] = console_handler
        
        # 创建文件处理器
        if self.config.get('file_enabled', True):
            file_config = self.config.get('file', {})
            
            # 应用日志
            app_handler = logging.handlers.RotatingFileHandler(
                filename=log_dir / file_config.get('app_file', 'app.log'),
                maxBytes=file_config.get('max_bytes', 10 * 1024 * 1024),  # 10MB
                backupCount=file_config.get('backup_count', 5),
                encoding='utf-8'
            )
            app_handler.setFormatter(formatter)
            app_handler.setLevel(getattr(logging, file_config.get('level', 'INFO')))
            root_logger.addHandler(app_handler)
            self.handlers['app'] = app_handler
            
            # 错误日志
            error_handler = logging.handlers.RotatingFileHandler(
                filename=log_dir / file_config.get('error_file', 'error.log'),
                maxBytes=file_config.get('max_bytes', 10 * 1024 * 1024),
                backupCount=file_config.get('backup_count', 5),
                encoding='utf-8'
            )
            error_handler.setFormatter(formatter)
            error_handler.setLevel(logging.ERROR)
            root_logger.addHandler(error_handler)
            self.handlers['error'] = error_handler
            
            # 审计日志
            audit_handler = logging.handlers.RotatingFileHandler(
                filename=log_dir / file_config.get('audit_file', 'audit.log'),
                maxBytes=file_config.get('max_bytes', 10 * 1024 * 1024),
                backupCount=file_config.get('backup_count', 10),
                encoding='utf-8'
            )
            audit_handler.setFormatter(formatter)
            audit_handler.setLevel(logging.INFO)
            self.handlers['audit'] = audit_handler
    
    def get_logger(self, name: str) -> logging.Logger:
        """获取指定名称的日志器"""
        if name not in self.loggers:
            logger = logging.getLogger(name)
            self.loggers[name] = logger
        return self.loggers[name]
    
    def get_audit_logger(self) -> logging.Logger:
        """获取审计日志器"""
        audit_logger = self.get_logger('audit')
        # 只使用审计处理器
        audit_logger.handlers = [self.handlers['audit']]
        audit_logger.propagate = False
        return audit_logger
    
    @contextmanager
    def log_context(self, **context):
        """日志上下文管理器"""
        # 保存当前上下文
        old_context = getattr(logging.getLoggerClass(), '_context', {})
        
        # 设置新上下文
        for logger in self.loggers.values():
            for handler in logger.handlers:
                for key, value in context.items():
                    setattr(handler, key, value)
        
        try:
            yield
        finally:
            # 恢复旧上下文
            for logger in self.loggers.values():
                for handler in logger.handlers:
                    for key in context.keys():
                        if hasattr(handler, key):
                            delattr(handler, key)

# 日志配置
LOGGING_CONFIG = {
    'level': 'INFO',
    'log_dir': 'logs',
    'console_enabled': True,
    'console_level': 'INFO',
    'file_enabled': True,
    'file': {
        'app_file': 'app.log',
        'error_file': 'error.log',
        'audit_file': 'audit.log',
        'max_bytes': 10 * 1024 * 1024,  # 10MB
        'backup_count': 5,
        'level': 'INFO'
    }
}

# 全局日志管理器
logger_manager = LoggerManager(LOGGING_CONFIG)

# 便捷函数
def get_logger(name: str) -> logging.Logger:
    """获取日志器"""
    return logger_manager.get_logger(name)

def get_audit_logger() -> logging.Logger:
    """获取审计日志器"""
    return logger_manager.get_audit_logger()

def log_with_context(**context):
    """带上下文的日志装饰器"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            with logger_manager.log_context(**context):
                return func(*args, **kwargs)
        return wrapper
    return decorator
```

##### 审计日志增强

```python
# services/audit_service.py
from typing import Dict, Any, Optional, List
from datetime import datetime
from enum import Enum
import json
import hashlib
import hmac
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_, or_, func
from database.models import AuditLog, User
from database.connection import get_db
from utils.logging_config import get_audit_logger
from utils.crypto import get_audit_key
from utils.pagination import PaginationParams, PaginationResult

class AuditEventType(Enum):
    """审计事件类型"""
    USER_LOGIN = "user_login"
    USER_LOGOUT = "user_logout"
    USER_CREATE = "user_create"
    USER_UPDATE = "user_update"
    USER_DELETE = "user_delete"
    LICENSE_CREATE = "license_create"
    LICENSE_UPDATE = "license_update"
    LICENSE_DELETE = "license_delete"
    LICENSE_ACTIVATE = "license_activate"
    APPLICATION_CREATE = "application_create"
    APPLICATION_UPDATE = "application_update"
    APPLICATION_DELETE = "application_delete"
    DEVICE_REGISTER = "device_register"
    DEVICE_UPDATE = "device_update"
    DEVICE_DELETE = "device_delete"
    ANNOUNCEMENT_CREATE = "announcement_create"
    ANNOUNCEMENT_UPDATE = "announcement_update"
    ANNOUNCEMENT_DELETE = "announcement_delete"
    SYSTEM_CONFIG_UPDATE = "system_config_update"
    SECURITY_VIOLATION = "security_violation"
    API_ACCESS = "api_access"
    DATA_EXPORT = "data_export"
    DATA_IMPORT = "data_import"

class AuditSeverity(Enum):
    """审计严重级别"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class AuditService:
    """审计服务"""
    
    def __init__(self):
        self.logger = get_audit_logger()
        self._audit_key = get_audit_key()
    
    async def log_event(
        self,
        event_type: AuditEventType,
        user_id: Optional[int] = None,
        resource_type: Optional[str] = None,
        resource_id: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
        severity: AuditSeverity = AuditSeverity.MEDIUM,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None,
        session_id: Optional[str] = None
    ) -> int:
        """记录审计事件"""
        try:
            timestamp = datetime.utcnow()
            
            # 构建审计数据
            audit_data = {
                'event_type': event_type.value,
                'user_id': user_id,
                'resource_type': resource_type,
                'resource_id': resource_id,
                'details': details or {},
                'severity': severity.value,
                'ip_address': ip_address,
                'user_agent': user_agent,
                'session_id': session_id,
                'timestamp': timestamp.isoformat()
            }
            
            # 生成完整性校验
            audit_data['integrity_hash'] = self._generate_integrity_hash(audit_data)
            
            # 记录到数据库
            async with get_db() as db:
                audit_log = AuditLog(
                    event_type=event_type.value,
                    user_id=user_id,
                    resource_type=resource_type,
                    resource_id=resource_id,
                    details=audit_data['details'],
                    severity=severity.value,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    session_id=session_id,
                    timestamp=timestamp,
                    integrity_hash=audit_data['integrity_hash']
                )
                
                db.add(audit_log)
                await db.commit()
                await db.refresh(audit_log)
                
                audit_id = audit_log.id
            
            # 记录到日志文件
            self.logger.info(
                f"审计事件: {event_type.value}",
                extra={
                    'extra_data': {
                        'audit_id': audit_id,
                        'event_type': event_type.value,
                        'user_id': user_id,
                        'resource_type': resource_type,
                        'resource_id': resource_id,
                        'severity': severity.value,
                        'ip_address': ip_address,
                        'session_id': session_id,
                        'details': details
                    }
                }
            )
            
            return audit_id
            
        except Exception as e:
            self.logger.error(f"记录审计事件失败: {e}", exc_info=True)
            raise
    
    def _generate_integrity_hash(self, audit_data: Dict[str, Any]) -> str:
        """生成完整性校验哈希"""
        # 移除哈希字段本身
        data_copy = audit_data.copy()
        data_copy.pop('integrity_hash', None)
        
        # 序列化数据
        data_str = json.dumps(data_copy, sort_keys=True, ensure_ascii=False)
        
        # 生成HMAC签名
        signature = hmac.new(
            self._audit_key.encode('utf-8'),
            data_str.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        
        return signature
    
    async def verify_integrity(self, audit_id: int) -> bool:
        """验证审计记录完整性"""
        try:
            async with get_db() as db:
                query = select(AuditLog).where(AuditLog.id == audit_id)
                result = await db.execute(query)
                audit_log = result.scalar_one_or_none()
                
                if not audit_log:
                    return False
                
                # 重新构建审计数据
                audit_data = {
                    'event_type': audit_log.event_type,
                    'user_id': audit_log.user_id,
                    'resource_type': audit_log.resource_type,
                    'resource_id': audit_log.resource_id,
                    'details': audit_log.details,
                    'severity': audit_log.severity,
                    'ip_address': audit_log.ip_address,
                    'user_agent': audit_log.user_agent,
                    'session_id': audit_log.session_id,
                    'timestamp': audit_log.timestamp.isoformat()
                }
                
                # 验证哈希
                expected_hash = self._generate_integrity_hash(audit_data)
                return expected_hash == audit_log.integrity_hash
                
        except Exception as e:
            self.logger.error(f"验证审计记录完整性失败: {e}", exc_info=True)
            return False
    
    async def search_audit_logs(
        self,
        pagination: PaginationParams,
        filters: Optional[Dict[str, Any]] = None
    ) -> PaginationResult:
        """搜索审计日志"""
        try:
            async with get_db() as db:
                # 构建查询
                query = select(AuditLog).join(User, AuditLog.user_id == User.id, isouter=True)
                
                # 应用过滤条件
                if filters:
                    conditions = []
                    
                    if filters.get('event_type'):
                        conditions.append(AuditLog.event_type == filters['event_type'])
                    
                    if filters.get('user_id'):
                        conditions.append(AuditLog.user_id == filters['user_id'])
                    
                    if filters.get('resource_type'):
                        conditions.append(AuditLog.resource_type == filters['resource_type'])
                    
                    if filters.get('severity'):
                        conditions.append(AuditLog.severity == filters['severity'])
                    
                    if filters.get('start_time'):
                        conditions.append(AuditLog.timestamp >= filters['start_time'])
                    
                    if filters.get('end_time'):
                        conditions.append(AuditLog.timestamp <= filters['end_time'])
                    
                    if filters.get('ip_address'):
                        conditions.append(AuditLog.ip_address == filters['ip_address'])
                    
                    if conditions:
                        query = query.where(and_(*conditions))
                
                # 计数查询
                count_query = select(func.count(AuditLog.id))
                if filters:
                    count_query = count_query.where(and_(*conditions))
                
                count_result = await db.execute(count_query)
                total_count = count_result.scalar() or 0
                
                # 分页查询
                offset = (pagination.page - 1) * pagination.page_size
                query = (
                    query.order_by(AuditLog.timestamp.desc())
                    .offset(offset)
                    .limit(pagination.page_size)
                )
                
                result = await db.execute(query)
                audit_logs = result.scalars().all()
                
                # 构建结果
                items = [
                    {
                        'id': log.id,
                        'event_type': log.event_type,
                        'user_id': log.user_id,
                        'username': log.user.username if log.user else None,
                        'resource_type': log.resource_type,
                        'resource_id': log.resource_id,
                        'details': log.details,
                        'severity': log.severity,
                        'ip_address': log.ip_address,
                        'user_agent': log.user_agent,
                        'session_id': log.session_id,
                        'timestamp': log.timestamp.isoformat(),
                        'integrity_verified': await self.verify_integrity(log.id)
                    }
                    for log in audit_logs
                ]
                
                return PaginationResult(
                    items=items,
                    total=total_count,
                    page=pagination.page,
                    page_size=pagination.page_size,
                    total_pages=(total_count + pagination.page_size - 1) // pagination.page_size
                )
                
        except Exception as e:
            self.logger.error(f"搜索审计日志失败: {e}", exc_info=True)
            raise
    
    async def get_audit_statistics(
        self,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None
    ) -> Dict[str, Any]:
        """获取审计统计信息"""
        try:
            async with get_db() as db:
                # 基础查询
                base_query = select(AuditLog)
                
                if start_time:
                    base_query = base_query.where(AuditLog.timestamp >= start_time)
                
                if end_time:
                    base_query = base_query.where(AuditLog.timestamp <= end_time)
                
                # 总数统计
                total_query = select(func.count(AuditLog.id)).select_from(base_query.subquery())
                total_result = await db.execute(total_query)
                total_count = total_result.scalar() or 0
                
                # 事件类型统计
                event_query = (
                    select(AuditLog.event_type, func.count(AuditLog.id))
                    .select_from(base_query.subquery())
                    .group_by(AuditLog.event_type)
                    .order_by(func.count(AuditLog.id).desc())
                )
                event_result = await db.execute(event_query)
                event_stats = {row[0]: row[1] for row in event_result.fetchall()}
                
                # 严重级别统计
                severity_query = (
                    select(AuditLog.severity, func.count(AuditLog.id))
                    .select_from(base_query.subquery())
                    .group_by(AuditLog.severity)
                )
                severity_result = await db.execute(severity_query)
                severity_stats = {row[0]: row[1] for row in severity_result.fetchall()}
                
                # 用户活动统计
                user_query = (
                    select(User.username, func.count(AuditLog.id))
                    .select_from(
                        base_query.subquery().join(User, AuditLog.user_id == User.id)
                    )
                    .group_by(User.username)
                    .order_by(func.count(AuditLog.id).desc())
                    .limit(10)
                )
                user_result = await db.execute(user_query)
                user_stats = {row[0]: row[1] for row in user_result.fetchall()}
                
                return {
                    'total_events': total_count,
                    'event_type_distribution': event_stats,
                    'severity_distribution': severity_stats,
                    'top_active_users': user_stats,
                    'generated_at': datetime.utcnow().isoformat()
                }
                
        except Exception as e:
            self.logger.error(f"获取审计统计失败: {e}", exc_info=True)
            raise

# 全局审计服务实例
audit_service = AuditService()

# 审计装饰器
def audit_action(
    event_type: AuditEventType,
    resource_type: Optional[str] = None,
    severity: AuditSeverity = AuditSeverity.MEDIUM
):
    """审计动作装饰器"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            try:
                # 执行原函数
                result = await func(*args, **kwargs)
                
                # 记录审计事件
                await audit_service.log_event(
                    event_type=event_type,
                    resource_type=resource_type,
                    severity=severity,
                    details={'function': func.__name__, 'args': str(args), 'kwargs': str(kwargs)}
                )
                
                return result
            except Exception as e:
                # 记录错误审计事件
                await audit_service.log_event(
                    event_type=AuditEventType.SECURITY_VIOLATION,
                    resource_type=resource_type,
                    severity=AuditSeverity.HIGH,
                    details={
                        'function': func.__name__,
                        'error': str(e),
                        'args': str(args),
                        'kwargs': str(kwargs)
                    }
                )
                raise
        return wrapper
    return decorator
```

#### 3.3.7 缓存失效策略优化

##### 事件驱动缓存管理

```python
# utils/cache_manager.py
from typing import Dict, Any, Optional, List, Set, Callable
from datetime import datetime, timedelta
import asyncio
import json
import hashlib
from enum import Enum
from dataclasses import dataclass
from abc import ABC, abstractmethod
import redis.asyncio as redis
from utils.logging_config import get_logger
from utils.events import event_bus, Event

logger = get_logger(__name__)

class CacheEventType(Enum):
    """缓存事件类型"""
    INVALIDATE = "cache_invalidate"
    REFRESH = "cache_refresh"
    CLEAR = "cache_clear"
    EXPIRE = "cache_expire"

@dataclass
class CacheKey:
    """缓存键定义"""
    namespace: str
    key: str
    tags: Set[str]
    ttl: Optional[int] = None
    
    def full_key(self) -> str:
        """获取完整缓存键"""
        return f"{self.namespace}:{self.key}"
    
    def tag_keys(self) -> List[str]:
        """获取标签键列表"""
        return [f"tag:{tag}" for tag in self.tags]

class CacheStrategy(ABC):
    """缓存策略抽象基类"""
    
    @abstractmethod
    async def should_cache(self, key: CacheKey, data: Any) -> bool:
        """判断是否应该缓存"""
        pass
    
    @abstractmethod
    async def get_ttl(self, key: CacheKey, data: Any) -> Optional[int]:
        """获取TTL"""
        pass
    
    @abstractmethod
    async def on_hit(self, key: CacheKey, data: Any):
        """缓存命中回调"""
        pass
    
    @abstractmethod
    async def on_miss(self, key: CacheKey):
        """缓存未命中回调"""
        pass

class DefaultCacheStrategy(CacheStrategy):
    """默认缓存策略"""
    
    def __init__(self, default_ttl: int = 300):
        self.default_ttl = default_ttl
    
    async def should_cache(self, key: CacheKey, data: Any) -> bool:
        return data is not None
    
    async def get_ttl(self, key: CacheKey, data: Any) -> Optional[int]:
        return key.ttl or self.default_ttl
    
    async def on_hit(self, key: CacheKey, data: Any):
        logger.debug(f"缓存命中: {key.full_key()}")
    
    async def on_miss(self, key: CacheKey):
        logger.debug(f"缓存未命中: {key.full_key()}")

class SmartCacheStrategy(CacheStrategy):
    """智能缓存策略"""
    
    def __init__(self):
        self.hit_counts: Dict[str, int] = {}
        self.access_times: Dict[str, List[datetime]] = {}
    
    async def should_cache(self, key: CacheKey, data: Any) -> bool:
        if data is None:
            return False
        
        # 根据访问频率决定是否缓存
        access_count = len(self.access_times.get(key.full_key(), []))
        return access_count >= 2  # 至少访问2次才缓存
    
    async def get_ttl(self, key: CacheKey, data: Any) -> Optional[int]:
        full_key = key.full_key()
        
        # 根据访问频率动态调整TTL
        access_times = self.access_times.get(full_key, [])
        if len(access_times) < 2:
            return 60  # 低频访问，短TTL
        
        # 计算访问频率
        recent_accesses = [
            t for t in access_times 
            if t > datetime.utcnow() - timedelta(hours=1)
        ]
        
        if len(recent_accesses) >= 10:
            return 3600  # 高频访问，长TTL
        elif len(recent_accesses) >= 5:
            return 1800  # 中频访问，中等TTL
        else:
            return 300   # 低频访问，短TTL
    
    async def on_hit(self, key: CacheKey, data: Any):
        full_key = key.full_key()
        self.hit_counts[full_key] = self.hit_counts.get(full_key, 0) + 1
        
        # 记录访问时间
        if full_key not in self.access_times:
            self.access_times[full_key] = []
        self.access_times[full_key].append(datetime.utcnow())
        
        # 清理旧的访问记录
        cutoff_time = datetime.utcnow() - timedelta(hours=24)
        self.access_times[full_key] = [
            t for t in self.access_times[full_key] if t > cutoff_time
        ]
    
    async def on_miss(self, key: CacheKey):
        full_key = key.full_key()
        
        # 记录访问时间
        if full_key not in self.access_times:
            self.access_times[full_key] = []
        self.access_times[full_key].append(datetime.utcnow())

class EnhancedCacheManager:
    """增强缓存管理器"""
    
    def __init__(self, redis_url: str = "redis://localhost:6379"):
        self.redis_pool = None
        self.redis_url = redis_url
        self.strategies: Dict[str, CacheStrategy] = {
            'default': DefaultCacheStrategy(),
            'smart': SmartCacheStrategy()
        }
        self.tag_mappings: Dict[str, Set[str]] = {}  # tag -> keys
        self.key_tags: Dict[str, Set[str]] = {}      # key -> tags
        self._invalidation_handlers: Dict[str, List[Callable]] = {}
        
        # 注册事件监听器
        event_bus.subscribe('user_updated', self._handle_user_updated)
        event_bus.subscribe('license_updated', self._handle_license_updated)
        event_bus.subscribe('application_updated', self._handle_application_updated)
        event_bus.subscribe('announcement_updated', self._handle_announcement_updated)
    
    async def initialize(self):
        """初始化缓存管理器"""
        self.redis_pool = redis.ConnectionPool.from_url(self.redis_url)
        logger.info("缓存管理器初始化完成")
    
    async def get_redis(self) -> redis.Redis:
        """获取Redis连接"""
        if not self.redis_pool:
            await self.initialize()
        return redis.Redis(connection_pool=self.redis_pool)
    
    async def get(
        self, 
        key: CacheKey, 
        strategy: str = 'default'
    ) -> Optional[Any]:
        """获取缓存数据"""
        try:
            redis_client = await self.get_redis()
            
            # 获取缓存数据
            cached_data = await redis_client.get(key.full_key())
            
            if cached_data:
                data = json.loads(cached_data)
                
                # 执行策略回调
                cache_strategy = self.strategies.get(strategy, self.strategies['default'])
                await cache_strategy.on_hit(key, data)
                
                return data
            else:
                # 执行策略回调
                cache_strategy = self.strategies.get(strategy, self.strategies['default'])
                await cache_strategy.on_miss(key)
                
                return None
                
        except Exception as e:
            logger.error(f"获取缓存失败: {e}", exc_info=True)
            return None
    
    async def set(
        self, 
        key: CacheKey, 
        data: Any, 
        strategy: str = 'default'
    ) -> bool:
        """设置缓存数据"""
        try:
            cache_strategy = self.strategies.get(strategy, self.strategies['default'])
            
            # 检查是否应该缓存
            if not await cache_strategy.should_cache(key, data):
                return False
            
            redis_client = await self.get_redis()
            
            # 序列化数据
            serialized_data = json.dumps(data, ensure_ascii=False, default=str)
            
            # 获取TTL
            ttl = await cache_strategy.get_ttl(key, data)
            
            # 设置缓存
            if ttl:
                await redis_client.setex(key.full_key(), ttl, serialized_data)
            else:
                await redis_client.set(key.full_key(), serialized_data)
            
            # 更新标签映射
            await self._update_tag_mappings(key)
            
            logger.debug(f"设置缓存成功: {key.full_key()}, TTL: {ttl}")
            return True
            
        except Exception as e:
            logger.error(f"设置缓存失败: {e}", exc_info=True)
            return False
    
    async def delete(self, key: CacheKey) -> bool:
        """删除缓存"""
        try:
            redis_client = await self.get_redis()
            
            # 删除缓存
            result = await redis_client.delete(key.full_key())
            
            # 清理标签映射
            await self._cleanup_tag_mappings(key)
            
            logger.debug(f"删除缓存: {key.full_key()}")
            return result > 0
            
        except Exception as e:
            logger.error(f"删除缓存失败: {e}", exc_info=True)
            return False
    
    async def delete_by_pattern(self, pattern: str) -> int:
        """按模式删除缓存"""
        try:
            redis_client = await self.get_redis()
            
            # 查找匹配的键
            keys = await redis_client.keys(pattern)
            
            if keys:
                # 批量删除
                result = await redis_client.delete(*keys)
                logger.info(f"按模式删除缓存: {pattern}, 删除数量: {result}")
                return result
            
            return 0
            
        except Exception as e:
            logger.error(f"按模式删除缓存失败: {e}", exc_info=True)
            return 0
    
    async def delete_by_tags(self, tags: List[str]) -> int:
        """按标签删除缓存"""
        try:
            keys_to_delete = set()
            
            # 收集所有需要删除的键
            for tag in tags:
                if tag in self.tag_mappings:
                    keys_to_delete.update(self.tag_mappings[tag])
            
            if not keys_to_delete:
                return 0
            
            redis_client = await self.get_redis()
            
            # 批量删除
            result = await redis_client.delete(*keys_to_delete)
            
            # 清理标签映射
            for tag in tags:
                if tag in self.tag_mappings:
                    for key in self.tag_mappings[tag]:
                        if key in self.key_tags:
                            self.key_tags[key].discard(tag)
                            if not self.key_tags[key]:
                                del self.key_tags[key]
                    del self.tag_mappings[tag]
            
            logger.info(f"按标签删除缓存: {tags}, 删除数量: {result}")
            return result
            
        except Exception as e:
            logger.error(f"按标签删除缓存失败: {e}", exc_info=True)
            return 0
    
    async def _update_tag_mappings(self, key: CacheKey):
        """更新标签映射"""
        full_key = key.full_key()
        
        # 更新标签到键的映射
        for tag in key.tags:
            if tag not in self.tag_mappings:
                self.tag_mappings[tag] = set()
            self.tag_mappings[tag].add(full_key)
        
        # 更新键到标签的映射
        self.key_tags[full_key] = key.tags.copy()
    
    async def _cleanup_tag_mappings(self, key: CacheKey):
        """清理标签映射"""
        full_key = key.full_key()
        
        # 清理标签映射
        if full_key in self.key_tags:
            for tag in self.key_tags[full_key]:
                if tag in self.tag_mappings:
                    self.tag_mappings[tag].discard(full_key)
                    if not self.tag_mappings[tag]:
                        del self.tag_mappings[tag]
            del self.key_tags[full_key]
    
    # 事件处理器
    async def _handle_user_updated(self, event: Event):
        """处理用户更新事件"""
        user_id = event.data.get('user_id')
        if user_id:
            await self.delete_by_tags([f'user:{user_id}', 'users'])
    
    async def _handle_license_updated(self, event: Event):
        """处理卡密更新事件"""
        license_id = event.data.get('license_id')
        user_id = event.data.get('user_id')
        application_id = event.data.get('application_id')
        
        tags_to_invalidate = ['licenses']
        
        if license_id:
            tags_to_invalidate.append(f'license:{license_id}')
        
        if user_id:
            tags_to_invalidate.append(f'user:{user_id}')
        
        if application_id:
            tags_to_invalidate.append(f'application:{application_id}')
        
        await self.delete_by_tags(tags_to_invalidate)
    
    async def _handle_application_updated(self, event: Event):
        """处理应用更新事件"""
        application_id = event.data.get('application_id')
        if application_id:
            await self.delete_by_tags([f'application:{application_id}', 'applications'])
    
    async def _handle_announcement_updated(self, event: Event):
        """处理公告更新事件"""
        announcement_id = event.data.get('announcement_id')
        if announcement_id:
            await self.delete_by_tags([f'announcement:{announcement_id}', 'announcements'])
    
    def register_strategy(self, name: str, strategy: CacheStrategy):
        """注册缓存策略"""
        self.strategies[name] = strategy
        logger.info(f"注册缓存策略: {name}")
    
    async def get_cache_stats(self) -> Dict[str, Any]:
        """获取缓存统计信息"""
        try:
            redis_client = await self.get_redis()
            
            # 获取Redis信息
            info = await redis_client.info()
            
            # 获取键数量
            db_info = await redis_client.info('keyspace')
            key_count = 0
            if 'db0' in db_info:
                key_count = db_info['db0']['keys']
            
            return {
                'redis_version': info.get('redis_version'),
                'used_memory': info.get('used_memory_human'),
                'connected_clients': info.get('connected_clients'),
                'total_commands_processed': info.get('total_commands_processed'),
                'keyspace_hits': info.get('keyspace_hits'),
                'keyspace_misses': info.get('keyspace_misses'),
                'key_count': key_count,
                'tag_mappings_count': len(self.tag_mappings),
                'strategies_count': len(self.strategies)
            }
            
        except Exception as e:
            logger.error(f"获取缓存统计失败: {e}", exc_info=True)
            return {}

# 全局缓存管理器实例
cache_manager = EnhancedCacheManager()

# 便捷函数
async def cached(
    namespace: str,
    key: str,
    tags: Optional[List[str]] = None,
    ttl: Optional[int] = None,
    strategy: str = 'default'
):
    """缓存装饰器"""
    def decorator(func):
        async def wrapper(*args, **kwargs):
            # 构建缓存键
            cache_key = CacheKey(
                namespace=namespace,
                key=key,
                tags=set(tags or []),
                ttl=ttl
            )
            
            # 尝试从缓存获取
            cached_result = await cache_manager.get(cache_key, strategy)
            if cached_result is not None:
                return cached_result
            
            # 执行原函数
            result = await func(*args, **kwargs)
            
            # 设置缓存
            await cache_manager.set(cache_key, result, strategy)
            
            return result
        return wrapper
    return decorator
```

### 3.4 API接口文档

#### 认证相关接口

##### POST /api/v1/auth/login
用户登录接口

**请求参数：**
```json
{
  "username": "string",
  "password": "string"
}
```

**响应数据：**
```json
{
  "access_token": "string",
  "refresh_token": "string",
  "token_type": "bearer",
  "expires_in": 3600,
  "user": {
    "id": 1,
    "username": "admin",
    "role": "super_admin",
    "email": "admin@example.com"
  }
}
```

##### POST /api/v1/auth/activate
卡密激活接口

**请求参数：**
```json
{
  "license_code": "string",
  "device_id": "string",
  "device_info": {
    "os": "Windows 10",
    "cpu": "Intel i7",
    "memory": "16GB"
  }
}
```

**响应数据：**
```json
{
  "success": true,
  "message": "激活成功",
  "license": {
    "id": 123,
    "expire_at": "2024-12-31T23:59:59Z",
    "max_bind_devices": 1,
    "current_bind_devices": 1
  }
}
```

##### POST /api/v1/auth/verify
卡密验证接口

**请求参数：**
```json
{
  "license_code": "string",
  "device_id": "string"
}
```

**响应数据：**
```json
{
  "valid": true,
  "expire_at": "2024-12-31T23:59:59Z",
  "remaining_days": 365
}
```

#### 应用管理接口

##### GET /api/v1/applications
获取应用列表

**查询参数：**
- `page`: 页码（默认1）
- `size`: 每页数量（默认20）
- `status`: 应用状态筛选
- `search`: 搜索关键词

**响应数据：**
```json
{
  "items": [
    {
      "id": 1,
      "name": "应用名称",
      "description": "应用描述",
      "status": "active",
      "api_key": "app_key_xxx",
      "created_at": "2024-01-01T00:00:00Z",
      "license_count": 100,
      "active_license_count": 50
    }
  ],
  "total": 100,
  "page": 1,
  "size": 20,
  "pages": 5
}
```

##### POST /api/v1/applications
创建应用

**请求参数：**
```json
{
  "name": "string",
  "description": "string",
  "app_type": "desktop",
  "status": "active"
}
```

#### 卡密管理接口

##### GET /api/v1/licenses
获取卡密列表

**查询参数：**
- `page`: 页码
- `size`: 每页数量
- `application_id`: 应用ID筛选
- `status`: 状态筛选
- `batch_id`: 批次ID筛选

##### POST /api/v1/licenses/generate
批量生成卡密

**请求参数：**
```json
{
  "application_id": 1,
  "count": 100,
  "expire_days": 365,
  "max_bind_devices": 1,
  "batch_name": "批次名称"
}
```

#### 用户管理接口

##### GET /api/v1/users
获取用户列表

##### POST /api/v1/users
创建用户

##### PUT /api/v1/users/{id}
更新用户信息

##### DELETE /api/v1/users/{id}
删除用户

### 3.2 数据库设计

#### ER图

```mermaid
erDiagram
    USERS {
        int id PK
        string username UK
        string password_hash
        string email UK
        enum role
        boolean is_active
        datetime created_at
        datetime updated_at
    }
    
    APPLICATIONS {
        int id PK
        string name UK
        string description
        enum app_type
        enum status
        string api_key UK
        string api_secret
        datetime created_at
        datetime updated_at
    }
    
    LICENSE_CODES {
        int id PK
        string code_encrypt UK
        string code_hash UK
        int application_id FK
        enum status
        datetime expire_at
        datetime activated_at
        int max_bind_devices
        int current_bind_devices
        string batch_id
        datetime created_at
        datetime updated_at
    }
    
    DEVICE_BIND {
        int id PK
        int user_id FK
        int application_id FK
        int license_id FK
        string device_id
        string device_name
        text device_info
        string device_fingerprint
        datetime bind_time
        datetime last_verify_time
        boolean is_active
    }
    
    USER_LICENSE_BIND {
        int id PK
        int user_id FK
        int license_id FK
        datetime bind_time
        datetime unbind_time
        boolean is_active
    }
    
    LICENSE_AUDIT_LOG {
        int id PK
        int license_id FK
        int user_id FK
        string action
        text details
        string ip_address
        datetime created_at
    }
    
    USERS ||--o{ USER_LICENSE_BIND : "has"
    USERS ||--o{ DEVICE_BIND : "owns"
    APPLICATIONS ||--o{ LICENSE_CODES : "contains"
    APPLICATIONS ||--o{ DEVICE_BIND : "binds"
    LICENSE_CODES ||--o{ USER_LICENSE_BIND : "bound_to"
    LICENSE_CODES ||--o{ DEVICE_BIND : "activates"
    LICENSE_CODES ||--o{ LICENSE_AUDIT_LOG : "logs"
```

#### 主要表结构

##### users 表
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    email VARCHAR(100) UNIQUE,
    role VARCHAR(20) DEFAULT 'user',
    is_active BOOLEAN DEFAULT true,
    last_login_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
```

##### applications 表
```sql
CREATE TABLE applications (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    app_type VARCHAR(20) DEFAULT 'desktop',
    status VARCHAR(20) DEFAULT 'active',
    api_key VARCHAR(64) UNIQUE NOT NULL,
    api_secret VARCHAR(128) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_applications_name ON applications(name);
CREATE INDEX idx_applications_status ON applications(status);
CREATE INDEX idx_applications_api_key ON applications(api_key);
```

##### license_codes 表
```sql
CREATE TABLE license_codes (
    id SERIAL PRIMARY KEY,
    code_encrypt VARCHAR(255) UNIQUE NOT NULL,
    code_hash VARCHAR(64) UNIQUE NOT NULL,
    application_id INTEGER REFERENCES applications(id) ON DELETE CASCADE,
    status INTEGER DEFAULT 0,
    expire_at TIMESTAMP WITH TIME ZONE NOT NULL,
    activated_at TIMESTAMP WITH TIME ZONE,
    max_bind_devices INTEGER DEFAULT 1,
    current_bind_devices INTEGER DEFAULT 0,
    batch_id VARCHAR(36),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT ck_max_bind_devices_positive CHECK (max_bind_devices >= 1),
    CONSTRAINT ck_current_bind_devices_non_negative CHECK (current_bind_devices >= 0),
    CONSTRAINT ck_current_bind_within_max CHECK (current_bind_devices <= max_bind_devices)
);

CREATE INDEX idx_license_app_status ON license_codes(application_id, status);
CREATE INDEX idx_license_expire_status ON license_codes(expire_at, status);
CREATE INDEX idx_license_batch_status ON license_codes(batch_id, status);
```

### 3.3 业务逻辑流程图

#### 卡密激活流程

```mermaid
flowchart TD
    A[客户端请求激活] --> B[验证请求参数]
    B --> C{参数有效?}
    C -->|否| D[返回参数错误]
    C -->|是| E[查询卡密信息]
    E --> F{卡密存在?}
    F -->|否| G[返回卡密不存在]
    F -->|是| H{卡密状态检查}
    H -->|未激活| I[检查设备绑定]
    H -->|已激活| J{设备匹配?}
    H -->|已禁用| K[返回卡密已禁用]
    H -->|已过期| L[返回卡密已过期]
    
    I --> M{设备数量限制?}
    M -->|超限| N[返回设备数量超限]
    M -->|未超限| O[创建设备绑定]
    
    J -->|匹配| P[更新最后验证时间]
    J -->|不匹配| Q[返回设备不匹配]
    
    O --> R[更新卡密状态]
    R --> S[记录审计日志]
    S --> T[返回激活成功]
    
    P --> U[记录验证日志]
    U --> V[返回验证成功]
```

#### 用户权限验证流程

```mermaid
flowchart TD
    A[API请求] --> B[提取JWT Token]
    B --> C{Token存在?}
    C -->|否| D[返回401未授权]
    C -->|是| E[验证Token签名]
    E --> F{签名有效?}
    F -->|否| G[返回401 Token无效]
    F -->|是| H[检查Token过期]
    H --> I{Token过期?}
    I -->|是| J[返回401 Token过期]
    I -->|否| K[提取用户信息]
    K --> L[检查用户状态]
    L --> M{用户激活?}
    M -->|否| N[返回403用户已禁用]
    M -->|是| O[检查接口权限]
    O --> P{权限足够?}
    P -->|否| Q[返回403权限不足]
    P -->|是| R[继续处理请求]
```

### 3.4 认证授权机制

#### JWT Token 结构

```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "user_id": 1,
    "username": "admin",
    "role": "super_admin",
    "exp": 1640995200,
    "iat": 1640908800,
    "jti": "unique-token-id"
  },
  "signature": "HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)"
}
```

#### 权限控制矩阵

| 功能模块 | super_admin | admin | user |
|---------|-------------|-------|------|
| 仪表盘 | ✅ | ✅ | ✅ |
| 应用管理 | ✅ | ✅ | ❌ |
| 卡密管理 | ✅ | ✅ | ❌ |
| 用户管理 | ✅ | ✅ | ❌ |
| 安全控制 | ✅ | ❌ | ❌ |
| 系统设置 | ✅ | ❌ | ❌ |
| 个人资料 | ✅ | ✅ | ✅ |

#### 加密策略

```python
# 密码加密
from passlib.context import CryptContext
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# 卡密加密
from cryptography.fernet import Fernet
cipher_suite = Fernet(encryption_key)

# JWT签名
import jwt
token = jwt.encode(payload, secret_key, algorithm="HS256")
```

### 3.5 第三方服务集成说明

#### Redis 缓存服务

**用途：**
- Session存储
- API限流
- 热点数据缓存
- 分布式锁

**配置：**
```python
REDIS_CONFIG = {
    "host": "localhost",
    "port": 6379,
    "db": 0,
    "password": None,
    "decode_responses": True,
    "max_connections": 20
}
```

#### PostgreSQL 数据库

**连接配置：**
```python
DATABASE_CONFIG = {
    "host": "localhost",
    "port": 5432,
    "database": "license_system",
    "username": "postgres",
    "password": "password",
    "pool_size": 20,
    "max_overflow": 30
}
```

#### 邮件服务（可选）

**SMTP配置：**
```python
EMAIL_CONFIG = {
    "smtp_server": "smtp.gmail.com",
    "smtp_port": 587,
    "username": "your-email@gmail.com",
    "password": "your-app-password",
    "use_tls": True
}
```

---

## 4. 数据部分

### 4.1 数据模型定义

#### 用户模型 (User)

```python
class User(Base, TimestampMixin):
    """用户模型"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    email = Column(String(100), unique=True, nullable=True, index=True)
    role = Column(SQLEnum(UserRole), default=UserRole.USER, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    last_login_at = Column(DateTime(timezone=True), nullable=True)
    
    # 关系
    license_binds = relationship("UserLicenseBind", back_populates="user")
    device_binds = relationship("DeviceBind", back_populates="user")
```

#### 应用模型 (Application)

```python
class Application(Base, TimestampMixin):
    """应用模型"""
    __tablename__ = "applications"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), unique=True, nullable=False, index=True)
    description = Column(Text, nullable=True)
    app_type = Column(SQLEnum(AppType), default=AppType.DESKTOP, nullable=False)
    status = Column(SQLEnum(AppStatus), default=AppStatus.ACTIVE, nullable=False)
    api_key = Column(String(64), unique=True, nullable=False, index=True)
    api_secret = Column(String(128), nullable=False)
    
    # 关系
    licenses = relationship("LicenseCode", back_populates="application")
    device_binds = relationship("DeviceBind", back_populates="application")
```

#### 卡密模型 (LicenseCode)

```python
class LicenseCode(Base, TimestampMixin, SoftDeleteMixin):
    """卡密模型"""
    __tablename__ = "license_codes"
    
    id = Column(Integer, primary_key=True, index=True)
    code_encrypt = Column(String(255), unique=True, nullable=False, index=True)
    code_hash = Column(String(64), unique=True, nullable=False, index=True)
    application_id = Column(Integer, ForeignKey("applications.id"), nullable=False)
    status = Column(SQLEnum(LicenseStatus), default=LicenseStatus.INACTIVE)
    expire_at = Column(DateTime(timezone=True), nullable=False, index=True)
    activated_at = Column(DateTime(timezone=True), nullable=True)
    max_bind_devices = Column(Integer, default=1, nullable=False)
    current_bind_devices = Column(Integer, default=0, nullable=False)
    batch_id = Column(String(36), nullable=True, index=True)
    
    # 关系
    application = relationship("Application", back_populates="licenses")
    user_binds = relationship("UserLicenseBind", back_populates="license")
    device_binds = relationship("DeviceBind", back_populates="license")
```

### 4.2 数据流示意图

```mermaid
flowchart LR
    A[客户端请求] --> B[API网关]
    B --> C[认证中间件]
    C --> D[业务逻辑层]
    D --> E[数据访问层]
    E --> F[PostgreSQL]
    E --> G[Redis缓存]
    
    H[定时任务] --> I[数据清理]
    I --> F
    
    J[监控系统] --> K[日志收集]
    K --> L[日志存储]
    
    M[备份系统] --> N[数据备份]
    N --> O[备份存储]
    
    subgraph "数据层"
        F[PostgreSQL<br/>主数据存储]
        G[Redis<br/>缓存层]
        L[日志存储]
        O[备份存储]
    end
```

### 4.3 缓存策略

#### 缓存层级

1. **L1缓存（应用内存）**
   - 配置信息缓存
   - 用户会话缓存
   - 热点数据缓存

2. **L2缓存（Redis）**
   - 用户认证信息
   - API限流计数
   - 临时数据存储

#### 缓存策略配置

```python
CACHE_STRATEGIES = {
    # 用户信息缓存
    "user_info": {
        "ttl": 3600,  # 1小时
        "strategy": "write_through"
    },
    
    # 应用配置缓存
    "app_config": {
        "ttl": 7200,  # 2小时
        "strategy": "cache_aside"
    },
    
    # 卡密验证结果缓存
    "license_verify": {
        "ttl": 300,   # 5分钟
        "strategy": "write_behind"
    },
    
    # API限流缓存
    "rate_limit": {
        "ttl": 60,    # 1分钟
        "strategy": "time_based"
    }
}
```

#### 缓存更新策略

```python
class CacheManager:
    """缓存管理器"""
    
    async def get_or_set(self, key: str, fetch_func, ttl: int = 3600):
        """获取或设置缓存"""
        # 尝试从缓存获取
        cached_data = await self.redis.get(key)
        if cached_data:
            return json.loads(cached_data)
        
        # 缓存未命中，从数据源获取
        data = await fetch_func()
        if data:
            await self.redis.setex(key, ttl, json.dumps(data))
        
        return data
    
    async def invalidate(self, pattern: str):
        """批量失效缓存"""
        keys = await self.redis.keys(pattern)
        if keys:
            await self.redis.delete(*keys)
```

### 4.4 数据验证规则

#### 输入验证规则

```python
from pydantic import BaseModel, validator, Field
from typing import Optional
import re

class UserCreateSchema(BaseModel):
    """用户创建验证模式"""
    username: str = Field(..., min_length=3, max_length=50)
    password: str = Field(..., min_length=8, max_length=128)
    email: Optional[str] = Field(None, max_length=100)
    role: str = Field(default="user")
    
    @validator('username')
    def validate_username(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]+$', v):
            raise ValueError('用户名只能包含字母、数字和下划线')
        return v
    
    @validator('password')
    def validate_password(cls, v):
        if not re.search(r'[A-Z]', v):
            raise ValueError('密码必须包含至少一个大写字母')
        if not re.search(r'[a-z]', v):
            raise ValueError('密码必须包含至少一个小写字母')
        if not re.search(r'\d', v):
            raise ValueError('密码必须包含至少一个数字')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        if v and not re.match(r'^[\w\.-]+@[\w\.-]+\.\w+$', v):
            raise ValueError('邮箱格式不正确')
        return v

class LicenseActivateSchema(BaseModel):
    """卡密激活验证模式"""
    license_code: str = Field(..., min_length=16, max_length=64)
    device_id: str = Field(..., min_length=8, max_length=100)
    device_info: Optional[dict] = None
    
    @validator('license_code')
    def validate_license_code(cls, v):
        # 移除空格和特殊字符
        v = re.sub(r'[\s-]', '', v)
        if not re.match(r'^[A-Z0-9]+$', v):
            raise ValueError('卡密格式不正确')
        return v
    
    @validator('device_id')
    def validate_device_id(cls, v):
        if not re.match(r'^[a-zA-Z0-9_-]+$', v):
            raise ValueError('设备ID格式不正确')
        return v
```

#### 业务规则验证

```python
class BusinessRuleValidator:
    """业务规则验证器"""
    
    @staticmethod
    def validate_license_activation(license: LicenseCode, device_id: str) -> bool:
        """验证卡密激活规则"""
        # 检查卡密状态
        if license.status != LicenseStatus.INACTIVE:
            raise ValueError("卡密已被激活或已禁用")
        
        # 检查过期时间
        if license.expire_at < datetime.now(timezone.utc):
            raise ValueError("卡密已过期")
        
        # 检查设备绑定数量
        if license.current_bind_devices >= license.max_bind_devices:
            raise ValueError("设备绑定数量已达上限")
        
        return True
    
    @staticmethod
    def validate_device_binding(user_id: int, application_id: int, device_id: str) -> bool:
        """验证设备绑定规则"""
        # 检查设备是否已绑定
        existing_bind = DeviceBind.query.filter_by(
            user_id=user_id,
            application_id=application_id,
            device_id=device_id,
            is_active=True
        ).first()
        
        if existing_bind:
            raise ValueError("设备已绑定")
        
        return True
```

---

## 5. UI/UX设计部分

### 5.1 设计规范

#### 色彩系统

```css
/* 主色调 */
:root {
  /* Primary Colors */
  --color-primary-50: #eff6ff;
  --color-primary-100: #dbeafe;
  --color-primary-200: #bfdbfe;
  --color-primary-300: #93c5fd;
  --color-primary-400: #60a5fa;
  --color-primary-500: #3b82f6;  /* 主色 */
  --color-primary-600: #2563eb;
  --color-primary-700: #1d4ed8;
  --color-primary-800: #1e40af;
  --color-primary-900: #1e3a8a;
  
  /* Secondary Colors */
  --color-secondary-50: #f8fafc;
  --color-secondary-100: #f1f5f9;
  --color-secondary-200: #e2e8f0;
  --color-secondary-300: #cbd5e1;
  --color-secondary-400: #94a3b8;
  --color-secondary-500: #64748b;  /* 辅助色 */
  --color-secondary-600: #475569;
  --color-secondary-700: #334155;
  --color-secondary-800: #1e293b;
  --color-secondary-900: #0f172a;
  
  /* Status Colors */
  --color-success: #10b981;
  --color-warning: #f59e0b;
  --color-error: #ef4444;
  --color-info: #3b82f6;
  
  /* Neutral Colors */
  --color-gray-50: #f9fafb;
  --color-gray-100: #f3f4f6;
  --color-gray-200: #e5e7eb;
  --color-gray-300: #d1d5db;
  --color-gray-400: #9ca3af;
  --color-gray-500: #6b7280;
  --color-gray-600: #4b5563;
  --color-gray-700: #374151;
  --color-gray-800: #1f2937;
  --color-gray-900: #111827;
}

/* 深色模式 */
[data-theme="dark"] {
  --color-primary-dark: #1e40af;
  --color-background: #0f172a;
  --color-surface: #1e293b;
  --color-text-primary: #f8fafc;
  --color-text-secondary: #cbd5e1;
}
```

#### 字体系统

```css
/* 字体族 */
:root {
  --font-family-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-family-mono: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
  
  /* 字体大小 */
  --text-xs: 0.75rem;    /* 12px */
  --text-sm: 0.875rem;   /* 14px */
  --text-base: 1rem;     /* 16px */
  --text-lg: 1.125rem;   /* 18px */
  --text-xl: 1.25rem;    /* 20px */
  --text-2xl: 1.5rem;    /* 24px */
  --text-3xl: 1.875rem;  /* 30px */
  --text-4xl: 2.25rem;   /* 36px */
  
  /* 字重 */
  --font-weight-light: 300;
  --font-weight-normal: 400;
  --font-weight-medium: 500;
  --font-weight-semibold: 600;
  --font-weight-bold: 700;
  
  /* 行高 */
  --line-height-tight: 1.25;
  --line-height-normal: 1.5;
  --line-height-relaxed: 1.75;
}
```

#### 间距系统

```css
/* 间距规范 */
:root {
  --spacing-0: 0;
  --spacing-1: 0.25rem;  /* 4px */
  --spacing-2: 0.5rem;   /* 8px */
  --spacing-3: 0.75rem;  /* 12px */
  --spacing-4: 1rem;     /* 16px */
  --spacing-5: 1.25rem;  /* 20px */
  --spacing-6: 1.5rem;   /* 24px */
  --spacing-8: 2rem;     /* 32px */
  --spacing-10: 2.5rem;  /* 40px */
  --spacing-12: 3rem;    /* 48px */
  --spacing-16: 4rem;    /* 64px */
  --spacing-20: 5rem;    /* 80px */
  --spacing-24: 6rem;    /* 96px */
}
```

#### 圆角与阴影

```css
/* 圆角 */
:root {
  --radius-none: 0;
  --radius-sm: 0.125rem;   /* 2px */
  --radius-base: 0.25rem;  /* 4px */
  --radius-md: 0.375rem;   /* 6px */
  --radius-lg: 0.5rem;     /* 8px */
  --radius-xl: 0.75rem;    /* 12px */
  --radius-2xl: 1rem;      /* 16px */
  --radius-full: 9999px;
}

/* 阴影 */
:root {
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow-base: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);
}
```

### 5.2 高保真原型图链接

由于这是一个实际的开发项目，原型图已通过代码实现。主要界面包括：

1. **登录页面** (`/login`)
   - 简洁的登录表单
   - 支持深色/浅色模式切换
   - 响应式设计

2. **仪表盘** (`/dashboard`)
   - 数据统计卡片
   - 图表展示
   - 最近活动列表

3. **应用管理** (`/applications`)
   - 应用列表表格
   - 搜索和筛选功能
   - 应用详情模态框

4. **卡密管理** (`/licenses`)
   - 卡密列表和状态
   - 批量操作功能
   - 生成卡密向导

### 5.3 交互动效说明

#### 页面转场动效

```css
/* 页面淡入淡出 */
.page-transition-enter {
  opacity: 0;
  transform: translateY(20px);
}

.page-transition-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: opacity 300ms ease-out, transform 300ms ease-out;
}

.page-transition-exit {
  opacity: 1;
  transform: translateY(0);
}

.page-transition-exit-active {
  opacity: 0;
  transform: translateY(-20px);
  transition: opacity 200ms ease-in, transform 200ms ease-in;
}
```

#### 按钮交互动效

```css
/* 按钮悬停和点击效果 */
.button {
  transition: all 200ms ease;
  transform: scale(1);
}

.button:hover {
  transform: scale(1.05);
  box-shadow: var(--shadow-lg);
}

.button:active {
  transform: scale(0.95);
  transition: all 100ms ease;
}

/* 加载状态动画 */
.button-loading {
  position: relative;
  color: transparent;
}

.button-loading::after {
  content: '';
  position: absolute;
  width: 16px;
  height: 16px;
  top: 50%;
  left: 50%;
  margin-left: -8px;
  margin-top: -8px;
  border: 2px solid transparent;
  border-top-color: currentColor;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}
```

#### 模态框动效

```css
/* 模态框弹出动画 */
.modal-overlay {
  background: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(4px);
  transition: all 200ms ease;
}

.modal-content {
  transform: scale(0.95) translateY(-20px);
  opacity: 0;
  transition: all 200ms ease;
}

.modal-content.open {
  transform: scale(1) translateY(0);
  opacity: 1;
}
```

### 5.4 响应式设计规范

#### 断点系统

```css
/* 响应式断点 */
:root {
  --breakpoint-sm: 640px;   /* 小屏设备 */
  --breakpoint-md: 768px;   /* 平板设备 */
  --breakpoint-lg: 1024px;  /* 桌面设备 */
  --breakpoint-xl: 1280px;  /* 大屏设备 */
  --breakpoint-2xl: 1536px; /* 超大屏设备 */
}

/* 媒体查询 */
@media (max-width: 640px) {
  /* 移动端样式 */
  .container {
    padding: var(--spacing-4);
  }
  
  .sidebar {
    transform: translateX(-100%);
    transition: transform 300ms ease;
  }
  
  .sidebar.open {
    transform: translateX(0);
  }
}

@media (min-width: 641px) and (max-width: 1024px) {
  /* 平板样式 */
  .grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (min-width: 1025px) {
  /* 桌面样式 */
  .grid {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

#### 移动端优化

```css
/* 触摸友好的按钮尺寸 */
@media (max-width: 768px) {
  .button {
    min-height: 44px;
    min-width: 44px;
    padding: var(--spacing-3) var(--spacing-4);
  }
  
  .table {
    font-size: var(--text-sm);
  }
  
  .modal {
    margin: var(--spacing-4);
    max-height: calc(100vh - 2rem);
  }
}

/* 横屏适配 */
@media (orientation: landscape) and (max-height: 500px) {
  .header {
    height: 48px;
  }
  
  .sidebar {
    width: 200px;
  }
}
```

### 5.5 可访问性标准

#### WCAG 2.1 AA 级别合规

```css
/* 颜色对比度 */
:root {
  /* 确保文本对比度至少为 4.5:1 */
  --text-on-light: #1f2937;  /* 对比度 > 4.5:1 */
  --text-on-dark: #f9fafb;   /* 对比度 > 4.5:1 */
}

/* 焦点指示器 */
.focusable:focus {
  outline: 2px solid var(--color-primary-500);
  outline-offset: 2px;
}

/* 跳过链接 */
.skip-link {
  position: absolute;
  top: -40px;
  left: 6px;
  background: var(--color-primary-600);
  color: white;
  padding: 8px;
  text-decoration: none;
  border-radius: 4px;
  z-index: 1000;
}

.skip-link:focus {
  top: 6px;
}
```

#### 语义化HTML

```html
<!-- 正确的语义化结构 -->
<main role="main" aria-label="主要内容">
  <header>
    <h1>页面标题</h1>
    <nav aria-label="主导航">
      <ul role="menubar">
        <li role="none">
          <a href="/dashboard" role="menuitem" aria-current="page">
            仪表盘
          </a>
        </li>
      </ul>
    </nav>
  </header>
  
  <section aria-labelledby="content-heading">
    <h2 id="content-heading">内容区域</h2>
    <!-- 内容 -->
  </section>
</main>

<!-- 表单可访问性 -->
<form>
  <div class="form-group">
    <label for="username">用户名</label>
    <input 
      id="username" 
      type="text" 
      required 
      aria-describedby="username-help"
      aria-invalid="false"
    >
    <div id="username-help" class="help-text">
      请输入3-50个字符的用户名
    </div>
  </div>
</form>
```

#### 键盘导航支持

```typescript
// 键盘导航处理
const handleKeyDown = (event: KeyboardEvent) => {
  switch (event.key) {
    case 'Escape':
      closeModal();
      break;
    case 'Tab':
      // 焦点陷阱处理
      trapFocus(event);
      break;
    case 'Enter':
    case ' ':
      if (event.target === buttonRef.current) {
        event.preventDefault();
        handleClick();
      }
      break;
  }
};

// 焦点陷阱实现
const trapFocus = (event: KeyboardEvent) => {
  const focusableElements = modal.querySelectorAll(
    'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
  );
  
  const firstElement = focusableElements[0] as HTMLElement;
  const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
  
  if (event.shiftKey) {
    if (document.activeElement === firstElement) {
      lastElement.focus();
      event.preventDefault();
    }
  } else {
    if (document.activeElement === lastElement) {
      firstElement.focus();
      event.preventDefault();
    }
  }
};
```

---

## 6. 其他信息

### 6.1 开发环境配置

#### 系统要求

- **操作系统**：macOS 10.15+, Windows 10+, Ubuntu 18.04+
- **Node.js**：16.0.0+
- **Python**：3.9+
- **PostgreSQL**：13.0+
- **Redis**：6.0+

#### 前端环境配置

```bash
# 1. 克隆项目
git clone <repository-url>
cd frontend

# 2. 安装依赖
npm install

# 3. 配置环境变量
cp .env.example .env.local

# 4. 启动开发服务器
npm run dev
```

**环境变量配置 (.env.local)：**
```env
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_WS_URL=ws://localhost:8000
NEXT_PUBLIC_APP_NAME=金鱼智盒卡密授权系统
NEXT_PUBLIC_APP_VERSION=1.0.0
```

#### 后端环境配置

```bash
# 1. 进入后端目录
cd backend

# 2. 创建虚拟环境
python -m venv .venv
source .venv/bin/activate  # Linux/macOS
# 或
.venv\Scripts\activate     # Windows

# 3. 安装依赖
pip install -r requirements.txt

# 4. 配置环境变量
cp .env.example .env

# 5. 初始化数据库
python -c "from app.db.init_db import init_db; init_db()"

# 6. 启动服务器
python main.py
```

**环境变量配置 (.env)：**
```env
# 数据库配置
DATABASE_URL=postgresql://postgres:password@localhost:5432/license_system

# Redis配置
REDIS_URL=redis://localhost:6379/0

# JWT配置
JWT_SECRET_KEY=your-super-secret-jwt-key
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=60
JWT_REFRESH_TOKEN_EXPIRE_DAYS=30

# 服务器配置
SERVER_HOST=0.0.0.0
SERVER_PORT=8000
DEBUG=true

# 加密配置
ENCRYPTION_KEY=your-32-byte-encryption-key

# 管理员账号
FIRST_SUPERUSER=admin
FIRST_SUPERUSER_PASSWORD=admin1314159
```

#### 数据库配置

```bash
# PostgreSQL 安装和配置
# macOS
brew install postgresql
brew services start postgresql

# Ubuntu
sudo apt update
sudo apt install postgresql postgresql-contrib
sudo systemctl start postgresql

# 创建数据库
sudo -u postgres psql
CREATE DATABASE license_system;
CREATE USER license_user WITH PASSWORD 'your_password';
GRANT ALL PRIVILEGES ON DATABASE license_system TO license_user;
\q

# Redis 安装和配置
# macOS
brew install redis
brew services start redis

# Ubuntu
sudo apt update
sudo apt install redis-server
sudo systemctl start redis-server
```

#### 开发工具推荐

**前端开发：**
- **IDE**：VS Code + 相关插件
- **浏览器**：Chrome DevTools
- **调试**：React Developer Tools
- **API测试**：Postman 或 Insomnia

**后端开发：**
- **IDE**：PyCharm 或 VS Code
- **数据库管理**：pgAdmin 或 DBeaver
- **API文档**：自动生成的 FastAPI Swagger UI
- **日志查看**：内置日志系统

### 6.2 部署流程

#### 生产环境部署

**1. 服务器准备**
```bash
# 更新系统
sudo apt update && sudo apt upgrade -y

# 安装必要软件
sudo apt install -y nginx postgresql redis-server python3.9 python3.9-venv nodejs npm

# 配置防火墙
sudo ufw allow 22
sudo ufw allow 80
sudo ufw allow 443
sudo ufw enable
```

**2. 数据库配置**
```bash
# PostgreSQL 配置
sudo -u postgres createdb license_system_prod
sudo -u postgres createuser --interactive license_prod

# Redis 配置
sudo systemctl enable redis-server
sudo systemctl start redis-server
```

**3. 后端部署**
```bash
# 创建应用目录
sudo mkdir -p /opt/license-system
sudo chown $USER:$USER /opt/license-system
cd /opt/license-system

# 克隆代码
git clone <repository-url> .

# 配置Python环境
python3.9 -m venv venv
source venv/bin/activate
pip install -r backend/requirements.txt

# 配置环境变量
cp backend/.env.example backend/.env.prod
# 编辑生产环境配置

# 初始化数据库
cd backend
python -c "from app.db.init_db import init_db; init_db()"
```

**4. 前端部署**
```bash
# 构建前端
cd frontend
npm install
npm run build

# 配置Nginx
sudo cp deployment/nginx.conf /etc/nginx/sites-available/license-system
sudo ln -s /etc/nginx/sites-available/license-system /etc/nginx/sites-enabled/
sudo nginx -t
sudo systemctl reload nginx
```

**5. 进程管理**
```bash
# 使用systemd管理后端服务
sudo cp deployment/license-backend.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable license-backend
sudo systemctl start license-backend
```

#### Docker 部署

**docker-compose.yml：**
```yaml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NEXT_PUBLIC_API_URL=http://backend:8000
    depends_on:
      - backend

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/license_system
      - REDIS_URL=redis://redis:6379/0
    depends_on:
      - db
      - redis
    volumes:
      - ./backend/logs:/app/logs

  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=license_system
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backend/sql/init.sql:/docker-entrypoint-initdb.d/init.sql

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### 6.3 测试方案

#### 单元测试

**后端测试 (pytest)：**
```python
# tests/test_auth.py
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.core.config import settings

client = TestClient(app)

class TestAuth:
    def test_login_success(self):
        """测试登录成功"""
        response = client.post(
            "/api/v1/auth/login",
            json={
                "username": "admin",
                "password": "admin1314159"
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert "access_token" in data
        assert data["token_type"] == "bearer"
    
    def test_login_invalid_credentials(self):
        """测试登录失败"""
        response = client.post(
            "/api/v1/auth/login",
            json={
                "username": "admin",
                "password": "wrong_password"
            }
        )
        assert response.status_code == 401
    
    def test_license_activation(self):
        """测试卡密激活"""
        # 先创建测试卡密
        license_code = "TEST-1234-5678-ABCD"
        
        response = client.post(
            "/api/v1/auth/activate",
            json={
                "license_code": license_code,
                "device_id": "test-device-001",
                "device_info": {
                    "os": "Windows 10",
                    "cpu": "Intel i7"
                }
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
```

**前端测试 (Jest + React Testing Library)：**
```typescript
// __tests__/components/LoginForm.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { LoginForm } from '@/components/LoginForm';
import { AuthProvider } from '@/contexts/AuthContext';

describe('LoginForm', () => {
  it('renders login form correctly', () => {
    render(
      <AuthProvider>
        <LoginForm />
      </AuthProvider>
    );
    
    expect(screen.getByLabelText(/用户名/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/密码/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /登录/i })).toBeInTheDocument();
  });
  
  it('shows validation errors for empty fields', async () => {
    render(
      <AuthProvider>
        <LoginForm />
      </AuthProvider>
    );
    
    const submitButton = screen.getByRole('button', { name: /登录/i });
    fireEvent.click(submitButton);
    
    await waitFor(() => {
      expect(screen.getByText(/请输入用户名/i)).toBeInTheDocument();
      expect(screen.getByText(/请输入密码/i)).toBeInTheDocument();
    });
  });
  
  it('submits form with valid credentials', async () => {
    const mockLogin = jest.fn();
    
    render(
      <AuthProvider value={{ login: mockLogin }}>
        <LoginForm />
      </AuthProvider>
    );
    
    fireEvent.change(screen.getByLabelText(/用户名/i), {
      target: { value: 'admin' }
    });
    fireEvent.change(screen.getByLabelText(/密码/i), {
      target: { value: 'admin1314159' }
    });
    
    fireEvent.click(screen.getByRole('button', { name: /登录/i }));
    
    await waitFor(() => {
      expect(mockLogin).toHaveBeenCalledWith({
        username: 'admin',
        password: 'admin1314159'
      });
    });
  });
});
```

#### 集成测试

```python
# tests/test_integration.py
import pytest
from fastapi.testclient import TestClient
from app.main import app
from app.db.session import get_db
from app.models.user import User
from app.models.license import LicenseCode

client = TestClient(app)

class TestLicenseWorkflow:
    """测试完整的卡密工作流程"""
    
    def test_complete_license_workflow(self, db_session):
        """测试从创建到激活的完整流程"""
        # 1. 管理员登录
        login_response = client.post(
            "/api/v1/auth/login",
            json={"username": "admin", "password": "admin1314159"}
        )
        token = login_response.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # 2. 创建应用
        app_response = client.post(
            "/api/v1/applications",
            json={
                "name": "测试应用",
                "description": "用于测试的应用",
                "app_type": "desktop"
            },
            headers=headers
        )
        app_id = app_response.json()["id"]
        
        # 3. 生成卡密
        license_response = client.post(
            "/api/v1/licenses/generate",
            json={
                "application_id": app_id,
                "count": 1,
                "expire_days": 365,
                "max_bind_devices": 1
            },
            headers=headers
        )
        license_codes = license_response.json()["codes"]
        license_code = license_codes[0]
        
        # 4. 激活卡密
        activate_response = client.post(
            "/api/v1/auth/activate",
            json={
                "license_code": license_code,
                "device_id": "test-device-001"
            }
        )
        assert activate_response.status_code == 200
        
        # 5. 验证卡密
        verify_response = client.post(
            "/api/v1/auth/verify",
            json={
                "license_code": license_code,
                "device_id": "test-device-001"
            }
        )
        assert verify_response.status_code == 200
        assert verify_response.json()["valid"] is True
```

#### 性能测试

```python
# tests/test_performance.py
import time
import asyncio
from concurrent.futures import ThreadPoolExecutor
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

class TestPerformance:
    def test_api_response_time(self):
        """测试API响应时间"""
        start_time = time.time()
        
        response = client.get("/api/v1/applications")
        
        end_time = time.time()
        response_time = end_time - start_time
        
        assert response.status_code == 200
        assert response_time < 0.3  # 响应时间应小于300ms
    
    def test_concurrent_requests(self):
        """测试并发请求处理能力"""
        def make_request():
            return client.get("/api/v1/health")
        
        # 模拟100个并发请求
        with ThreadPoolExecutor(max_workers=100) as executor:
            futures = [executor.submit(make_request) for _ in range(100)]
            results = [future.result() for future in futures]
        
        # 所有请求都应该成功
        assert all(result.status_code == 200 for result in results)
```

### 6.4 性能优化建议

#### 前端性能优化

**1. 代码分割和懒加载**
```typescript
// 路由级别的代码分割
const Dashboard = lazy(() => import('@/pages/dashboard'));
const Applications = lazy(() => import('@/pages/applications'));
const Licenses = lazy(() => import('@/pages/licenses'));

// 组件级别的懒加载
const HeavyChart = lazy(() => import('@/components/HeavyChart'));

// 使用Suspense包装
<Suspense fallback={<LoadingSpinner />}>
  <HeavyChart data={chartData} />
</Suspense>
```

**2. 图片和资源优化**
```typescript
// next.config.js
module.exports = {
  images: {
    domains: ['example.com'],
    formats: ['image/webp', 'image/avif'],
  },
  
  // 启用压缩
  compress: true,
  
  // 优化字体加载
  optimizeFonts: true,
  
  // 启用实验性功能
  experimental: {
    optimizeCss: true,
    optimizeImages: true,
  }
};
```

**3. 状态管理优化**
```typescript
// 使用useMemo优化计算
const expensiveValue = useMemo(() => {
  return heavyCalculation(data);
}, [data]);

// 使用useCallback优化函数
const handleClick = useCallback((id: string) => {
  onItemClick(id);
}, [onItemClick]);

// 虚拟化长列表
import { FixedSizeList as List } from 'react-window';

const VirtualizedList = ({ items }) => (
  <List
    height={600}
    itemCount={items.length}
    itemSize={50}
    itemData={items}
  >
    {Row}
  </List>
);
```

#### 后端性能优化

**1. 数据库查询优化**
```python
# 使用索引优化查询
class LicenseCode(Base):
    # 复合索引
    __table_args__ = (
        Index('idx_app_status_expire', 'application_id', 'status', 'expire_at'),
        Index('idx_batch_status', 'batch_id', 'status'),
    )

# 查询优化
def get_licenses_optimized(db: Session, app_id: int, status: str):
    return db.query(LicenseCode)\
        .options(selectinload(LicenseCode.application))\
        .filter(
            LicenseCode.application_id == app_id,
            LicenseCode.status == status
        )\
        .order_by(LicenseCode.created_at.desc())\
        .limit(100)\
        .all()

# 使用原生SQL处理复杂查询
def get_license_statistics(db: Session):
    result = db.execute(
        text("""
        SELECT 
            application_id,
            COUNT(*) as total_licenses,
            COUNT(CASE WHEN status = 1 THEN 1 END) as active_licenses,
            COUNT(CASE WHEN expire_at < NOW() THEN 1 END) as expired_licenses
        FROM license_codes 
        GROUP BY application_id
        """)
    )
    return result.fetchall()
```

**2. 缓存策略优化**
```python
# 多级缓存
class CacheService:
    def __init__(self):
        self.local_cache = {}  # 本地缓存
        self.redis_client = redis.Redis()  # Redis缓存
    
    async def get_with_cache(self, key: str, fetch_func, ttl: int = 3600):
        # L1: 本地缓存
        if key in self.local_cache:
            return self.local_cache[key]
        
        # L2: Redis缓存
        cached_data = await self.redis_client.get(key)
        if cached_data:
            data = json.loads(cached_data)
            self.local_cache[key] = data
            return data
        
        # 缓存未命中，从数据源获取
        data = await fetch_func()
        if data:
            # 写入Redis
            await self.redis_client.setex(key, ttl, json.dumps(data))
            # 写入本地缓存
            self.local_cache[key] = data
        
        return data

# 缓存预热
async def warm_up_cache():
    """系统启动时预热缓存"""
    cache_service = CacheService()
    
    # 预热热点数据
    await cache_service.get_with_cache(
        "app_configs",
        lambda: get_all_app_configs()
    )
    
    await cache_service.get_with_cache(
        "user_roles",
        lambda: get_all_user_roles()
    )
```

**3. 异步处理优化**
```python
# 使用后台任务处理耗时操作
from fastapi import BackgroundTasks

@router.post("/licenses/generate")
async def generate_licenses(
    request: LicenseGenerateRequest,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db)
):
    # 立即返回任务ID
    task_id = str(uuid.uuid4())
    
    # 后台执行生成任务
    background_tasks.add_task(
        generate_licenses_task,
        task_id,
        request.dict(),
        db
    )
    
    return {"task_id": task_id, "status": "processing"}

async def generate_licenses_task(task_id: str, params: dict, db: Session):
    """后台生成卡密任务"""
    try:
        # 更新任务状态
        await update_task_status(task_id, "running")
        
        # 批量生成卡密
        licenses = []
        for i in range(params["count"]):
            license = create_license_code(params, db)
            licenses.append(license)
            
            # 每100个提交一次
            if len(licenses) % 100 == 0:
                db.commit()
        
        # 最终提交
        db.commit()
        
        # 更新任务完成状态
        await update_task_status(task_id, "completed", {
            "generated_count": len(licenses)
        })
        
    except Exception as e:
        await update_task_status(task_id, "failed", {
            "error": str(e)
        })
```

### 6.5 已知问题列表

#### 当前已知问题

**高优先级问题：**

1. **配置硬编码问题**
   - **描述**：部分配置信息硬编码在代码中
   - **影响**：难以在不同环境间切换
   - **解决方案**：将所有配置移至环境变量
   - **状态**：计划修复

2. **错误处理不完善**
   - **描述**：某些异常情况缺少适当的错误处理
   - **影响**：可能导致系统崩溃或用户体验差
   - **解决方案**：完善全局异常处理机制
   - **状态**：开发中

3. **数据库连接池配置**
   - **描述**：数据库连接池参数需要根据负载调优
   - **影响**：高并发时可能出现连接不足
   - **解决方案**：优化连接池配置
   - **状态**：待优化

**中优先级问题：**

4. **前端类型定义不完整**
   - **描述**：部分API响应缺少TypeScript类型定义
   - **影响**：开发时缺少类型检查
   - **解决方案**：补充完整的类型定义
   - **状态**：逐步完善

5. **日志系统待完善**
   - **描述**：缺少结构化日志和日志轮转
   - **影响**：难以进行问题排查和监控
   - **解决方案**：引入结构化日志框架
   - **状态**：计划中

6. **缓存失效策略**
   - **描述**：缓存失效策略需要进一步优化
   - **影响**：可能出现数据不一致
   - **解决方案**：实现更精确的缓存失效机制
   - **状态**：研究中

**低优先级问题：**

7. **国际化支持**
   - **描述**：目前只支持中文界面
   - **影响**：限制了国际化使用
   - **解决方案**：添加i18n支持
   - **状态**：未来版本

8. **移动端适配**
   - **描述**：移动端体验有待优化
   - **影响**：移动设备使用体验不佳
   - **解决方案**：优化移动端界面
   - **状态**：未来版本

#### 性能瓶颈

1. **大量卡密查询性能**
   - **场景**：当卡密数量超过10万时查询变慢
   - **临时方案**：添加分页和索引
   - **长期方案**：考虑分库分表

2. **实时通知性能**
   - **场景**：大量用户同时在线时WebSocket连接压力大
   - **临时方案**：限制连接数
   - **长期方案**：使用消息队列优化

#### 3.3.8 实时通知性能优化

**文件路径：`services/notification_service.py`**

```python
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import asyncio
import json
import redis.asyncio as redis
from fastapi import WebSocket
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.database import get_db
from app.core.logger import get_logger
from app.services.event_bus import event_bus
from app.models.user import User
from app.models.application import Application

logger = get_logger(__name__)

class NotificationType(str, Enum):
    """通知类型枚举"""
    LICENSE_EXPIRY = "license_expiry"
    LICENSE_ACTIVATED = "license_activated"
    LICENSE_DEACTIVATED = "license_deactivated"
    APPLICATION_UPDATE = "application_update"
    SYSTEM_ANNOUNCEMENT = "system_announcement"
    SECURITY_ALERT = "security_alert"
    MAINTENANCE_NOTICE = "maintenance_notice"
    USER_LOGIN = "user_login"
    DEVICE_BINDING = "device_binding"
    QUOTA_WARNING = "quota_warning"

class NotificationPriority(str, Enum):
    """通知优先级"""
    LOW = "low"
    NORMAL = "normal"
    HIGH = "high"
    URGENT = "urgent"

class DeliveryChannel(str, Enum):
    """投递渠道"""
    WEBSOCKET = "websocket"
    EMAIL = "email"
    SMS = "sms"
    PUSH = "push"
    IN_APP = "in_app"

@dataclass
class NotificationMessage:
    """通知消息数据结构"""
    id: str
    type: NotificationType
    priority: NotificationPriority
    title: str
    content: str
    recipient_id: Optional[str] = None
    recipient_type: str = "user"  # user, application, broadcast
    channels: List[DeliveryChannel] = field(default_factory=lambda: [DeliveryChannel.WEBSOCKET])
    metadata: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None
    retry_count: int = 0
    max_retries: int = 3
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典格式"""
        return {
            "id": self.id,
            "type": self.type.value,
            "priority": self.priority.value,
            "title": self.title,
            "content": self.content,
            "recipient_id": self.recipient_id,
            "recipient_type": self.recipient_type,
            "channels": [ch.value for ch in self.channels],
            "metadata": self.metadata,
            "created_at": self.created_at.isoformat(),
            "expires_at": self.expires_at.isoformat() if self.expires_at else None,
            "retry_count": self.retry_count,
            "max_retries": self.max_retries
        }

class MessageQueue:
    """基于Redis的消息队列"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.queues = {
            NotificationPriority.URGENT: "notifications:urgent",
            NotificationPriority.HIGH: "notifications:high",
            NotificationPriority.NORMAL: "notifications:normal",
            NotificationPriority.LOW: "notifications:low"
        }
        self.processing_queue = "notifications:processing"
        self.failed_queue = "notifications:failed"
        self.dead_letter_queue = "notifications:dead_letter"
    
    async def enqueue(self, message: NotificationMessage) -> bool:
        """将消息加入队列"""
        try:
            queue_name = self.queues[message.priority]
            message_data = json.dumps(message.to_dict())
            
            # 使用Redis的LPUSH添加到队列头部（高优先级先处理）
            await self.redis.lpush(queue_name, message_data)
            
            # 设置消息过期时间
            if message.expires_at:
                ttl = int((message.expires_at - datetime.utcnow()).total_seconds())
                await self.redis.expire(f"msg:{message.id}", ttl)
            
            logger.info(f"Message {message.id} enqueued to {queue_name}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to enqueue message {message.id}: {e}")
            return False
    
    async def dequeue(self, timeout: int = 10) -> Optional[NotificationMessage]:
        """从队列中取出消息（按优先级顺序）"""
        try:
            # 按优先级顺序检查队列
            queue_names = [
                self.queues[NotificationPriority.URGENT],
                self.queues[NotificationPriority.HIGH],
                self.queues[NotificationPriority.NORMAL],
                self.queues[NotificationPriority.LOW]
            ]
            
            # 使用BRPOP阻塞式弹出（从队列尾部取出）
            result = await self.redis.brpop(queue_names, timeout=timeout)
            
            if result:
                queue_name, message_data = result
                message_dict = json.loads(message_data)
                
                # 重构NotificationMessage对象
                message = NotificationMessage(
                    id=message_dict["id"],
                    type=NotificationType(message_dict["type"]),
                    priority=NotificationPriority(message_dict["priority"]),
                    title=message_dict["title"],
                    content=message_dict["content"],
                    recipient_id=message_dict.get("recipient_id"),
                    recipient_type=message_dict.get("recipient_type", "user"),
                    channels=[DeliveryChannel(ch) for ch in message_dict.get("channels", [])],
                    metadata=message_dict.get("metadata", {}),
                    created_at=datetime.fromisoformat(message_dict["created_at"]),
                    expires_at=datetime.fromisoformat(message_dict["expires_at"]) if message_dict.get("expires_at") else None,
                    retry_count=message_dict.get("retry_count", 0),
                    max_retries=message_dict.get("max_retries", 3)
                )
                
                # 移动到处理队列
                await self.redis.lpush(self.processing_queue, message_data)
                
                return message
            
            return None
            
        except Exception as e:
            logger.error(f"Failed to dequeue message: {e}")
            return None
    
    async def mark_completed(self, message_id: str) -> bool:
        """标记消息处理完成"""
        try:
            # 从处理队列中移除
            processing_messages = await self.redis.lrange(self.processing_queue, 0, -1)
            for msg_data in processing_messages:
                msg_dict = json.loads(msg_data)
                if msg_dict["id"] == message_id:
                    await self.redis.lrem(self.processing_queue, 1, msg_data)
                    logger.info(f"Message {message_id} marked as completed")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Failed to mark message {message_id} as completed: {e}")
            return False
    
    async def mark_failed(self, message: NotificationMessage) -> bool:
        """标记消息处理失败"""
        try:
            message.retry_count += 1
            
            if message.retry_count <= message.max_retries:
                # 重新加入队列重试
                await self.enqueue(message)
                logger.warning(f"Message {message.id} failed, retry {message.retry_count}/{message.max_retries}")
            else:
                # 移动到死信队列
                await self.redis.lpush(self.dead_letter_queue, json.dumps(message.to_dict()))
                logger.error(f"Message {message.id} moved to dead letter queue after {message.max_retries} retries")
            
            # 从处理队列中移除
            await self.mark_completed(message.id)
            return True
            
        except Exception as e:
            logger.error(f"Failed to mark message {message.id} as failed: {e}")
            return False
    
    async def get_queue_stats(self) -> Dict[str, int]:
        """获取队列统计信息"""
        stats = {}
        
        for priority, queue_name in self.queues.items():
            stats[f"{priority.value}_queue"] = await self.redis.llen(queue_name)
        
        stats["processing_queue"] = await self.redis.llen(self.processing_queue)
        stats["failed_queue"] = await self.redis.llen(self.failed_queue)
        stats["dead_letter_queue"] = await self.redis.llen(self.dead_letter_queue)
        
        return stats

class WebSocketManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        # 用户连接映射：user_id -> List[WebSocket]
        self.user_connections: Dict[str, List[WebSocket]] = {}
        # 应用连接映射：app_id -> List[WebSocket]
        self.app_connections: Dict[str, List[WebSocket]] = {}
        # 广播连接列表
        self.broadcast_connections: List[WebSocket] = []
        # 连接元数据：WebSocket -> Dict
        self.connection_metadata: Dict[WebSocket, Dict[str, Any]] = {}
    
    async def connect(self, websocket: WebSocket, user_id: Optional[str] = None, 
                     app_id: Optional[str] = None, metadata: Optional[Dict] = None):
        """建立WebSocket连接"""
        await websocket.accept()
        
        # 存储连接元数据
        self.connection_metadata[websocket] = {
            "user_id": user_id,
            "app_id": app_id,
            "connected_at": datetime.utcnow(),
            "metadata": metadata or {}
        }
        
        # 根据类型添加到相应的连接池
        if user_id:
            if user_id not in self.user_connections:
                self.user_connections[user_id] = []
            self.user_connections[user_id].append(websocket)
        
        if app_id:
            if app_id not in self.app_connections:
                self.app_connections[app_id] = []
            self.app_connections[app_id].append(websocket)
        
        # 添加到广播连接池
        self.broadcast_connections.append(websocket)
        
        logger.info(f"WebSocket connected: user_id={user_id}, app_id={app_id}")
    
    async def disconnect(self, websocket: WebSocket):
        """断开WebSocket连接"""
        metadata = self.connection_metadata.get(websocket, {})
        user_id = metadata.get("user_id")
        app_id = metadata.get("app_id")
        
        # 从各个连接池中移除
        if user_id and user_id in self.user_connections:
            self.user_connections[user_id] = [
                ws for ws in self.user_connections[user_id] if ws != websocket
            ]
            if not self.user_connections[user_id]:
                del self.user_connections[user_id]
        
        if app_id and app_id in self.app_connections:
            self.app_connections[app_id] = [
                ws for ws in self.app_connections[app_id] if ws != websocket
            ]
            if not self.app_connections[app_id]:
                del self.app_connections[app_id]
        
        if websocket in self.broadcast_connections:
            self.broadcast_connections.remove(websocket)
        
        if websocket in self.connection_metadata:
            del self.connection_metadata[websocket]
        
        logger.info(f"WebSocket disconnected: user_id={user_id}, app_id={app_id}")
    
    async def send_to_user(self, user_id: str, message: Dict[str, Any]) -> int:
        """发送消息给特定用户"""
        sent_count = 0
        
        if user_id in self.user_connections:
            connections = self.user_connections[user_id].copy()
            
            for websocket in connections:
                try:
                    await websocket.send_json(message)
                    sent_count += 1
                except Exception as e:
                    logger.warning(f"Failed to send message to user {user_id}: {e}")
                    await self.disconnect(websocket)
        
        return sent_count
    
    async def send_to_app(self, app_id: str, message: Dict[str, Any]) -> int:
        """发送消息给特定应用的所有连接"""
        sent_count = 0
        
        if app_id in self.app_connections:
            connections = self.app_connections[app_id].copy()
            
            for websocket in connections:
                try:
                    await websocket.send_json(message)
                    sent_count += 1
                except Exception as e:
                    logger.warning(f"Failed to send message to app {app_id}: {e}")
                    await self.disconnect(websocket)
        
        return sent_count
    
    async def broadcast(self, message: Dict[str, Any]) -> int:
        """广播消息给所有连接"""
        sent_count = 0
        connections = self.broadcast_connections.copy()
        
        for websocket in connections:
            try:
                await websocket.send_json(message)
                sent_count += 1
            except Exception as e:
                logger.warning(f"Failed to broadcast message: {e}")
                await self.disconnect(websocket)
        
        return sent_count
    
    def get_connection_stats(self) -> Dict[str, Any]:
        """获取连接统计信息"""
        return {
            "total_connections": len(self.broadcast_connections),
            "user_connections": len(self.user_connections),
            "app_connections": len(self.app_connections),
            "users_online": list(self.user_connections.keys()),
            "apps_connected": list(self.app_connections.keys())
        }

class NotificationService:
    """通知服务主类"""
    
    def __init__(self, redis_client: redis.Redis):
        self.message_queue = MessageQueue(redis_client)
        self.websocket_manager = WebSocketManager()
        self.delivery_handlers: Dict[DeliveryChannel, Callable] = {}
        self.is_running = False
        self.worker_tasks: List[asyncio.Task] = []
        
        # 注册默认投递处理器
        self.register_delivery_handler(DeliveryChannel.WEBSOCKET, self._handle_websocket_delivery)
    
    def register_delivery_handler(self, channel: DeliveryChannel, handler: Callable):
        """注册投递渠道处理器"""
        self.delivery_handlers[channel] = handler
        logger.info(f"Registered delivery handler for {channel.value}")
    
    async def send_notification(self, message: NotificationMessage) -> bool:
        """发送通知（加入队列）"""
        return await self.message_queue.enqueue(message)
    
    async def _handle_websocket_delivery(self, message: NotificationMessage) -> bool:
        """处理WebSocket投递"""
        try:
            notification_data = {
                "id": message.id,
                "type": message.type.value,
                "priority": message.priority.value,
                "title": message.title,
                "content": message.content,
                "metadata": message.metadata,
                "timestamp": message.created_at.isoformat()
            }
            
            sent_count = 0
            
            if message.recipient_type == "user" and message.recipient_id:
                sent_count = await self.websocket_manager.send_to_user(
                    message.recipient_id, notification_data
                )
            elif message.recipient_type == "application" and message.recipient_id:
                sent_count = await self.websocket_manager.send_to_app(
                    message.recipient_id, notification_data
                )
            elif message.recipient_type == "broadcast":
                sent_count = await self.websocket_manager.broadcast(notification_data)
            
            logger.info(f"WebSocket notification {message.id} sent to {sent_count} connections")
            return sent_count > 0
            
        except Exception as e:
            logger.error(f"Failed to handle WebSocket delivery for {message.id}: {e}")
            return False
    
    async def _process_message(self, message: NotificationMessage) -> bool:
        """处理单个消息"""
        try:
            # 检查消息是否过期
            if message.expires_at and datetime.utcnow() > message.expires_at:
                logger.warning(f"Message {message.id} expired, skipping")
                return True
            
            success = True
            
            # 按渠道投递消息
            for channel in message.channels:
                if channel in self.delivery_handlers:
                    try:
                        result = await self.delivery_handlers[channel](message)
                        if not result:
                            success = False
                            logger.warning(f"Failed to deliver message {message.id} via {channel.value}")
                    except Exception as e:
                        success = False
                        logger.error(f"Error delivering message {message.id} via {channel.value}: {e}")
                else:
                    logger.warning(f"No handler registered for delivery channel {channel.value}")
            
            return success
            
        except Exception as e:
            logger.error(f"Error processing message {message.id}: {e}")
            return False
    
    async def _worker(self, worker_id: int):
        """消息处理工作线程"""
        logger.info(f"Notification worker {worker_id} started")
        
        while self.is_running:
            try:
                # 从队列中获取消息
                message = await self.message_queue.dequeue(timeout=5)
                
                if message:
                    logger.debug(f"Worker {worker_id} processing message {message.id}")
                    
                    # 处理消息
                    success = await self._process_message(message)
                    
                    if success:
                        await self.message_queue.mark_completed(message.id)
                        logger.debug(f"Message {message.id} processed successfully")
                    else:
                        await self.message_queue.mark_failed(message)
                        logger.warning(f"Message {message.id} processing failed")
                
            except asyncio.CancelledError:
                logger.info(f"Worker {worker_id} cancelled")
                break
            except Exception as e:
                logger.error(f"Worker {worker_id} error: {e}")
                await asyncio.sleep(1)  # 避免错误循环
        
        logger.info(f"Notification worker {worker_id} stopped")
    
    async def start(self, worker_count: int = 3):
        """启动通知服务"""
        if self.is_running:
            logger.warning("Notification service is already running")
            return
        
        self.is_running = True
        
        # 启动工作线程
        for i in range(worker_count):
            task = asyncio.create_task(self._worker(i))
            self.worker_tasks.append(task)
        
        logger.info(f"Notification service started with {worker_count} workers")
    
    async def stop(self):
        """停止通知服务"""
        if not self.is_running:
            return
        
        self.is_running = False
        
        # 取消所有工作任务
        for task in self.worker_tasks:
            task.cancel()
        
        # 等待任务完成
        if self.worker_tasks:
            await asyncio.gather(*self.worker_tasks, return_exceptions=True)
        
        self.worker_tasks.clear()
        logger.info("Notification service stopped")
    
    async def get_service_stats(self) -> Dict[str, Any]:
        """获取服务统计信息"""
        queue_stats = await self.message_queue.get_queue_stats()
        connection_stats = self.websocket_manager.get_connection_stats()
        
        return {
            "service_status": "running" if self.is_running else "stopped",
            "worker_count": len(self.worker_tasks),
            "queue_stats": queue_stats,
            "connection_stats": connection_stats,
            "delivery_channels": list(self.delivery_handlers.keys())
        }

# 全局通知服务实例
notification_service: Optional[NotificationService] = None

def get_notification_service() -> NotificationService:
    """获取通知服务实例"""
    global notification_service
    if notification_service is None:
        raise RuntimeError("Notification service not initialized")
    return notification_service

def init_notification_service(redis_client: redis.Redis) -> NotificationService:
    """初始化通知服务"""
    global notification_service
    notification_service = NotificationService(redis_client)
    return notification_service
```

**文件路径：`api/websocket.py`**

```python
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, HTTPException
from typing import Optional
import json
from app.core.auth import get_current_user_websocket
from app.services.notification_service import get_notification_service
from app.core.logger import get_logger

logger = get_logger(__name__)
router = APIRouter()

@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """通用WebSocket端点"""
    notification_service = get_notification_service()
    
    try:
        # 建立连接
        await notification_service.websocket_manager.connect(websocket)
        
        while True:
            # 接收客户端消息
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # 处理认证消息
            if message.get("type") == "auth":
                token = message.get("token")
                if token:
                    try:
                        # 验证token并获取用户信息
                        user = await get_current_user_websocket(token)
                        if user:
                            # 重新连接并关联用户
                            await notification_service.websocket_manager.disconnect(websocket)
                            await notification_service.websocket_manager.connect(
                                websocket, 
                                user_id=str(user.id),
                                metadata={"username": user.username, "role": user.role}
                            )
                            
                            await websocket.send_json({
                                "type": "auth_success",
                                "user_id": str(user.id),
                                "username": user.username
                            })
                        else:
                            await websocket.send_json({
                                "type": "auth_error",
                                "message": "Invalid token"
                            })
                    except Exception as e:
                        await websocket.send_json({
                            "type": "auth_error",
                            "message": str(e)
                        })
            
            # 处理心跳消息
            elif message.get("type") == "ping":
                await websocket.send_json({"type": "pong"})
            
            # 处理其他消息类型
            else:
                logger.debug(f"Received WebSocket message: {message}")
    
    except WebSocketDisconnect:
        logger.info("WebSocket disconnected")
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
    finally:
        await notification_service.websocket_manager.disconnect(websocket)

@router.websocket("/ws/app/{app_id}")
async def app_websocket_endpoint(websocket: WebSocket, app_id: str):
    """应用专用WebSocket端点"""
    notification_service = get_notification_service()
    
    try:
        # 建立应用连接
        await notification_service.websocket_manager.connect(
            websocket, 
            app_id=app_id,
            metadata={"app_id": app_id}
        )
        
        while True:
            data = await websocket.receive_text()
            message = json.loads(data)
            
            # 处理应用消息
            if message.get("type") == "app_status":
                await websocket.send_json({
                    "type": "status_ack",
                    "app_id": app_id,
                    "timestamp": message.get("timestamp")
                })
            
            elif message.get("type") == "ping":
                await websocket.send_json({"type": "pong"})
    
    except WebSocketDisconnect:
        logger.info(f"App WebSocket disconnected: {app_id}")
    except Exception as e:
        logger.error(f"App WebSocket error for {app_id}: {e}")
    finally:
        await notification_service.websocket_manager.disconnect(websocket)
```

#### 安全考虑

1. **密钥轮换机制**
   - **现状**：JWT密钥和加密密钥为静态配置
   - **风险**：长期使用同一密钥存在安全风险
   - **建议**：实现定期密钥轮换机制

2. **API限流策略**
   - **现状**：基础的IP限流
   - **改进**：实现更精细的用户级别限流

3. **审计日志完整性**
   - **现状**：基本的操作日志记录
   - **改进**：增加日志完整性校验和防篡改机制

---

## 部署指南

### 4.1 环境准备

**系统要求：**
- 操作系统：Ubuntu 20.04+ / CentOS 8+ / macOS 10.15+
- Python：3.9+
- Node.js：18+
- PostgreSQL：13+
- Redis：6+
- Nginx：1.18+

**依赖安装：**

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install python3.9 python3.9-venv python3.9-dev
sudo apt install nodejs npm
sudo apt install postgresql postgresql-contrib
sudo apt install redis-server
sudo apt install nginx

# CentOS/RHEL
sudo yum update
sudo yum install python39 python39-devel
sudo yum install nodejs npm
sudo yum install postgresql postgresql-server postgresql-contrib
sudo yum install redis
sudo yum install nginx

# macOS
brew install python@3.9
brew install node
brew install postgresql
brew install redis
brew install nginx
```

### 4.2 数据库配置

**PostgreSQL配置：**

```sql
-- 创建数据库和用户
CREATE DATABASE goldfish_license_system;
CREATE USER goldfish_user WITH PASSWORD 'your_secure_password';
GRANT ALL PRIVILEGES ON DATABASE goldfish_license_system TO goldfish_user;

-- 配置连接参数
ALTER SYSTEM SET max_connections = 200;
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET work_mem = '4MB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
SELECT pg_reload_conf();
```

**Redis配置：**

```bash
# 编辑 /etc/redis/redis.conf
maxmemory 512mb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
appendonly yes
appendfsync everysec

# 重启Redis服务
sudo systemctl restart redis
```

### 4.3 后端部署

**1. 克隆代码并安装依赖：**

```bash
git clone <repository_url>
cd goldfish-license-system/backend

# 创建虚拟环境
python3.9 -m venv venv
source venv/bin/activate

# 安装依赖
pip install -r requirements.txt
```

**2. 环境配置：**

```bash
# 复制环境配置文件
cp .env.example .env

# 编辑配置文件
vim .env
```

**3. 数据库迁移：**

```bash
# 运行数据库迁移
alembic upgrade head

# 创建初始管理员用户
python scripts/create_admin.py
```

**4. 启动服务：**

```bash
# 开发环境
uvicorn main:app --host 0.0.0.0 --port 8000 --reload

# 生产环境
gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

### 4.4 前端部署

**1. 安装依赖并构建：**

```bash
cd ../frontend
npm install

# 配置环境变量
cp .env.example .env.local
vim .env.local

# 构建生产版本
npm run build
```

**2. 启动服务：**

```bash
# 开发环境
npm run dev

# 生产环境
npm run start
```

### 4.5 Nginx配置

**配置文件：`/etc/nginx/sites-available/goldfish-license`**

```nginx
server {
    listen 80;
    server_name your-domain.com;
    
    # 重定向到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    # SSL配置
    ssl_certificate /path/to/ssl/cert.pem;
    ssl_certificate_key /path/to/ssl/private.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # 前端静态文件
    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
    
    # 后端API
    location /api/ {
        proxy_pass http://127.0.0.1:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # API限流
        limit_req zone=api burst=20 nodelay;
    }
    
    # WebSocket
    location /ws {
        proxy_pass http://127.0.0.1:8000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header X-Content-Type-Options nosniff;
    }
    
    # 安全头
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
}

# 限流配置
http {
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=login:10m rate=5r/m;
}
```

### 4.6 系统服务配置

**后端服务：`/etc/systemd/system/goldfish-backend.service`**

```ini
[Unit]
Description=Goldfish License System Backend
After=network.target postgresql.service redis.service

[Service]
Type=exec
User=www-data
Group=www-data
WorkingDirectory=/opt/goldfish-license-system/backend
Environment=PATH=/opt/goldfish-license-system/backend/venv/bin
ExecStart=/opt/goldfish-license-system/backend/venv/bin/gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker --bind 127.0.0.1:8000
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

**前端服务：`/etc/systemd/system/goldfish-frontend.service`**

```ini
[Unit]
Description=Goldfish License System Frontend
After=network.target

[Service]
Type=exec
User=www-data
Group=www-data
WorkingDirectory=/opt/goldfish-license-system/frontend
Environment=NODE_ENV=production
ExecStart=/usr/bin/npm start
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

**启用服务：**

```bash
sudo systemctl enable goldfish-backend
sudo systemctl enable goldfish-frontend
sudo systemctl enable nginx
sudo systemctl enable postgresql
sudo systemctl enable redis

sudo systemctl start goldfish-backend
sudo systemctl start goldfish-frontend
sudo systemctl start nginx
```

## 测试方案

### 5.1 单元测试

**后端测试框架：pytest**

```python
# tests/test_license_service.py
import pytest
from datetime import datetime, timedelta
from app.services.license_service import LicenseService
from app.models.license import License, LicenseStatus

@pytest.fixture
def license_service():
    return LicenseService()

@pytest.fixture
def sample_license():
    return License(
        key="TEST-1234-5678-9ABC",
        type="standard",
        status=LicenseStatus.INACTIVE,
        expires_at=datetime.utcnow() + timedelta(days=30),
        max_devices=1,
        application_id=1
    )

class TestLicenseService:
    
    async def test_generate_license_key(self, license_service):
        """测试卡密生成"""
        key = await license_service.generate_license_key()
        assert len(key) == 19  # 格式：XXXX-XXXX-XXXX-XXXX
        assert key.count('-') == 3
    
    async def test_activate_license(self, license_service, sample_license):
        """测试卡密激活"""
        device_id = "test-device-001"
        user_id = 1
        
        result = await license_service.activate_license(
            sample_license.key, device_id, user_id
        )
        
        assert result.success is True
        assert result.license.status == LicenseStatus.ACTIVE
        assert len(result.license.devices) == 1
    
    async def test_activate_expired_license(self, license_service):
        """测试激活过期卡密"""
        expired_license = License(
            key="EXPIRED-TEST-KEY",
            type="standard",
            status=LicenseStatus.INACTIVE,
            expires_at=datetime.utcnow() - timedelta(days=1),
            max_devices=1,
            application_id=1
        )
        
        result = await license_service.activate_license(
            expired_license.key, "device-001", 1
        )
        
        assert result.success is False
        assert "expired" in result.error_message.lower()
    
    async def test_device_limit_exceeded(self, license_service):
        """测试设备数量限制"""
        # 创建已达到设备限制的卡密
        license_with_max_devices = License(
            key="MAX-DEVICE-TEST",
            type="standard",
            status=LicenseStatus.ACTIVE,
            expires_at=datetime.utcnow() + timedelta(days=30),
            max_devices=1,
            application_id=1
        )
        # 假设已有一个设备绑定
        
        result = await license_service.activate_license(
            license_with_max_devices.key, "new-device", 1
        )
        
        assert result.success is False
        assert "device limit" in result.error_message.lower()
```

**前端测试框架：Jest + React Testing Library**

```typescript
// __tests__/components/LicenseForm.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { LicenseForm } from '@/components/LicenseForm';
import { LicenseService } from '@/services/license-service';

// Mock服务
jest.mock('@/services/license-service');
const mockLicenseService = LicenseService as jest.Mocked<typeof LicenseService>;

describe('LicenseForm', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test('renders license form correctly', () => {
    render(<LicenseForm />);
    
    expect(screen.getByLabelText(/license key/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/device id/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /activate/i })).toBeInTheDocument();
  });

  test('validates required fields', async () => {
    render(<LicenseForm />);
    
    const activateButton = screen.getByRole('button', { name: /activate/i });
    fireEvent.click(activateButton);
    
    await waitFor(() => {
      expect(screen.getByText(/license key is required/i)).toBeInTheDocument();
      expect(screen.getByText(/device id is required/i)).toBeInTheDocument();
    });
  });

  test('submits form with valid data', async () => {
    const mockActivate = jest.fn().mockResolvedValue({
      success: true,
      license: { id: 1, key: 'TEST-KEY', status: 'active' }
    });
    mockLicenseService.activate = mockActivate;
    
    render(<LicenseForm />);
    
    fireEvent.change(screen.getByLabelText(/license key/i), {
      target: { value: 'TEST-1234-5678-9ABC' }
    });
    fireEvent.change(screen.getByLabelText(/device id/i), {
      target: { value: 'device-001' }
    });
    
    fireEvent.click(screen.getByRole('button', { name: /activate/i }));
    
    await waitFor(() => {
      expect(mockActivate).toHaveBeenCalledWith('TEST-1234-5678-9ABC', 'device-001');
    });
  });

  test('displays error message on activation failure', async () => {
    const mockActivate = jest.fn().mockResolvedValue({
      success: false,
      error_message: 'License key not found'
    });
    mockLicenseService.activate = mockActivate;
    
    render(<LicenseForm />);
    
    fireEvent.change(screen.getByLabelText(/license key/i), {
      target: { value: 'INVALID-KEY' }
    });
    fireEvent.change(screen.getByLabelText(/device id/i), {
      target: { value: 'device-001' }
    });
    
    fireEvent.click(screen.getByRole('button', { name: /activate/i }));
    
    await waitFor(() => {
      expect(screen.getByText(/license key not found/i)).toBeInTheDocument();
    });
  });
});
```

### 5.2 集成测试

**API集成测试：**

```python
# tests/test_api_integration.py
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
class TestLicenseAPI:
    
    async def test_license_lifecycle(self):
        """测试卡密完整生命周期"""
        async with AsyncClient(app=app, base_url="http://test") as client:
            # 1. 管理员登录
            login_response = await client.post("/api/auth/login", json={
                "username": "admin",
                "password": "admin1314159"
            })
            assert login_response.status_code == 200
            token = login_response.json()["access_token"]
            headers = {"Authorization": f"Bearer {token}"}
            
            # 2. 创建应用
            app_response = await client.post("/api/applications", json={
                "name": "Test Application",
                "version": "1.0.0",
                "description": "Test app for integration testing"
            }, headers=headers)
            assert app_response.status_code == 201
            app_id = app_response.json()["id"]
            
            # 3. 生成卡密
            license_response = await client.post("/api/licenses", json={
                "type": "standard",
                "duration_days": 30,
                "max_devices": 1,
                "application_id": app_id
            }, headers=headers)
            assert license_response.status_code == 201
            license_key = license_response.json()["key"]
            
            # 4. 用户注册
            register_response = await client.post("/api/auth/register", json={
                "username": "testuser",
                "email": "test@example.com",
                "password": "testpass123"
            })
            assert register_response.status_code == 201
            
            # 5. 用户登录
            user_login_response = await client.post("/api/auth/login", json={
                "username": "testuser",
                "password": "testpass123"
            })
            assert user_login_response.status_code == 200
            user_token = user_login_response.json()["access_token"]
            user_headers = {"Authorization": f"Bearer {user_token}"}
            
            # 6. 激活卡密
            activate_response = await client.post("/api/licenses/activate", json={
                "license_key": license_key,
                "device_id": "test-device-001"
            }, headers=user_headers)
            assert activate_response.status_code == 200
            assert activate_response.json()["success"] is True
            
            # 7. 验证卡密状态
            verify_response = await client.post("/api/licenses/verify", json={
                "license_key": license_key,
                "device_id": "test-device-001"
            }, headers=user_headers)
            assert verify_response.status_code == 200
            assert verify_response.json()["valid"] is True
            
            # 8. 停用卡密
            deactivate_response = await client.post(
                f"/api/licenses/{license_key}/deactivate",
                headers=headers
            )
            assert deactivate_response.status_code == 200
            
            # 9. 验证卡密已停用
            verify_deactivated_response = await client.post("/api/licenses/verify", json={
                "license_key": license_key,
                "device_id": "test-device-001"
            }, headers=user_headers)
            assert verify_deactivated_response.status_code == 200
            assert verify_deactivated_response.json()["valid"] is False
```

### 5.3 性能测试

**负载测试脚本：**

```python
# tests/performance/load_test.py
import asyncio
import aiohttp
import time
from typing import List, Dict
import statistics

class LoadTester:
    def __init__(self, base_url: str, concurrent_users: int = 100):
        self.base_url = base_url
        self.concurrent_users = concurrent_users
        self.results: List[Dict] = []
    
    async def make_request(self, session: aiohttp.ClientSession, endpoint: str, 
                          method: str = 'GET', data: dict = None) -> Dict:
        """发送单个请求并记录性能指标"""
        start_time = time.time()
        try:
            async with session.request(method, f"{self.base_url}{endpoint}", 
                                     json=data) as response:
                await response.text()
                end_time = time.time()
                return {
                    'endpoint': endpoint,
                    'method': method,
                    'status_code': response.status,
                    'response_time': end_time - start_time,
                    'success': 200 <= response.status < 400
                }
        except Exception as e:
            end_time = time.time()
            return {
                'endpoint': endpoint,
                'method': method,
                'status_code': 0,
                'response_time': end_time - start_time,
                'success': False,
                'error': str(e)
            }
    
    async def simulate_user_session(self, session: aiohttp.ClientSession, user_id: int):
        """模拟用户会话"""
        # 1. 登录
        login_result = await self.make_request(
            session, '/api/auth/login', 'POST',
            {'username': f'user{user_id}', 'password': 'testpass123'}
        )
        self.results.append(login_result)
        
        if not login_result['success']:
            return
        
        # 2. 获取用户信息
        profile_result = await self.make_request(session, '/api/users/profile')
        self.results.append(profile_result)
        
        # 3. 查询卡密列表
        licenses_result = await self.make_request(session, '/api/licenses')
        self.results.append(licenses_result)
        
        # 4. 验证卡密
        verify_result = await self.make_request(
            session, '/api/licenses/verify', 'POST',
            {'license_key': 'TEST-KEY', 'device_id': f'device-{user_id}'}
        )
        self.results.append(verify_result)
    
    async def run_load_test(self, duration_seconds: int = 60):
        """运行负载测试"""
        print(f"Starting load test with {self.concurrent_users} concurrent users for {duration_seconds} seconds")
        
        connector = aiohttp.TCPConnector(limit=self.concurrent_users * 2)
        async with aiohttp.ClientSession(connector=connector) as session:
            start_time = time.time()
            tasks = []
            
            while time.time() - start_time < duration_seconds:
                # 创建并发用户任务
                for user_id in range(self.concurrent_users):
                    task = asyncio.create_task(
                        self.simulate_user_session(session, user_id)
                    )
                    tasks.append(task)
                
                # 等待当前批次完成
                await asyncio.gather(*tasks, return_exceptions=True)
                tasks.clear()
                
                # 短暂休息
                await asyncio.sleep(1)
    
    def generate_report(self) -> Dict:
        """生成性能测试报告"""
        if not self.results:
            return {'error': 'No test results available'}
        
        # 按端点分组统计
        endpoint_stats = {}
        for result in self.results:
            endpoint = result['endpoint']
            if endpoint not in endpoint_stats:
                endpoint_stats[endpoint] = {
                    'total_requests': 0,
                    'successful_requests': 0,
                    'failed_requests': 0,
                    'response_times': [],
                    'error_rate': 0
                }
            
            stats = endpoint_stats[endpoint]
            stats['total_requests'] += 1
            stats['response_times'].append(result['response_time'])
            
            if result['success']:
                stats['successful_requests'] += 1
            else:
                stats['failed_requests'] += 1
        
        # 计算统计指标
        for endpoint, stats in endpoint_stats.items():
            response_times = stats['response_times']
            stats['avg_response_time'] = statistics.mean(response_times)
            stats['min_response_time'] = min(response_times)
            stats['max_response_time'] = max(response_times)
            stats['p95_response_time'] = statistics.quantiles(response_times, n=20)[18]  # 95th percentile
            stats['error_rate'] = (stats['failed_requests'] / stats['total_requests']) * 100
            stats['throughput'] = stats['total_requests'] / 60  # requests per second
        
        return {
            'total_requests': len(self.results),
            'concurrent_users': self.concurrent_users,
            'endpoint_statistics': endpoint_stats,
            'overall_error_rate': (sum(1 for r in self.results if not r['success']) / len(self.results)) * 100
        }

# 运行负载测试
if __name__ == '__main__':
    async def main():
        tester = LoadTester('http://localhost:8000', concurrent_users=50)
        await tester.run_load_test(duration_seconds=120)
        report = tester.generate_report()
        
        print("\n=== Load Test Report ===")
        print(f"Total Requests: {report['total_requests']}")
        print(f"Concurrent Users: {report['concurrent_users']}")
        print(f"Overall Error Rate: {report['overall_error_rate']:.2f}%")
        
        print("\n=== Endpoint Statistics ===")
        for endpoint, stats in report['endpoint_statistics'].items():
            print(f"\n{endpoint}:")
            print(f"  Total Requests: {stats['total_requests']}")
            print(f"  Success Rate: {((stats['successful_requests']/stats['total_requests'])*100):.2f}%")
            print(f"  Avg Response Time: {stats['avg_response_time']*1000:.2f}ms")
            print(f"  P95 Response Time: {stats['p95_response_time']*1000:.2f}ms")
            print(f"  Throughput: {stats['throughput']:.2f} req/s")
    
    asyncio.run(main())
```

### 5.4 安全测试

**安全测试检查清单：**

```python
# tests/security/security_test.py
import pytest
import requests
from sqlalchemy import text
from app.core.database import get_db

class SecurityTester:
    def __init__(self, base_url: str):
        self.base_url = base_url
    
    def test_sql_injection(self):
        """测试SQL注入防护"""
        malicious_payloads = [
            "'; DROP TABLE users; --",
            "' OR '1'='1",
            "' UNION SELECT * FROM users --",
            "'; INSERT INTO users (username) VALUES ('hacker'); --"
        ]
        
        for payload in malicious_payloads:
            response = requests.post(f"{self.base_url}/api/auth/login", json={
                "username": payload,
                "password": "test"
            })
            
            # 应该返回认证失败，而不是服务器错误
            assert response.status_code in [400, 401, 422]
            assert "error" not in response.text.lower() or "sql" not in response.text.lower()
    
    def test_xss_protection(self):
        """测试XSS防护"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>"
        ]
        
        # 获取管理员token
        login_response = requests.post(f"{self.base_url}/api/auth/login", json={
            "username": "admin",
            "password": "admin1314159"
        })
        token = login_response.json()["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        for payload in xss_payloads:
            response = requests.post(f"{self.base_url}/api/applications", json={
                "name": payload,
                "version": "1.0.0",
                "description": "Test app"
            }, headers=headers)
            
            if response.status_code == 201:
                # 检查返回的数据是否被正确转义
                app_data = response.json()
                assert "<script>" not in app_data["name"]
                assert "javascript:" not in app_data["name"]
    
    def test_authentication_bypass(self):
        """测试认证绕过"""
        protected_endpoints = [
            "/api/users",
            "/api/licenses",
            "/api/applications",
            "/api/admin/dashboard"
        ]
        
        for endpoint in protected_endpoints:
            # 无token访问
            response = requests.get(f"{self.base_url}{endpoint}")
            assert response.status_code == 401
            
            # 无效token访问
            headers = {"Authorization": "Bearer invalid_token"}
            response = requests.get(f"{self.base_url}{endpoint}", headers=headers)
            assert response.status_code == 401
    
    def test_rate_limiting(self):
        """测试API限流"""
        # 快速发送多个登录请求
        for i in range(20):
            response = requests.post(f"{self.base_url}/api/auth/login", json={
                "username": "admin",
                "password": "wrong_password"
            })
            
            if i > 10:  # 超过限制后应该被限流
                assert response.status_code == 429
    
    def test_sensitive_data_exposure(self):
        """测试敏感数据泄露"""
        # 正常登录
        response = requests.post(f"{self.base_url}/api/auth/login", json={
            "username": "admin",
            "password": "admin1314159"
        })
        
        user_data = response.json()
        
        # 确保密码等敏感信息不在响应中
        assert "password" not in user_data
        assert "password_hash" not in user_data
        assert "secret_key" not in user_data
    
    def test_csrf_protection(self):
        """测试CSRF防护"""
        # 获取token
        login_response = requests.post(f"{self.base_url}/api/auth/login", json={
            "username": "admin",
            "password": "admin1314159"
        })
        token = login_response.json()["access_token"]
        
        # 尝试从不同来源发送请求
        headers = {
            "Authorization": f"Bearer {token}",
            "Origin": "http://malicious-site.com",
            "Referer": "http://malicious-site.com"
        }
        
        response = requests.post(f"{self.base_url}/api/applications", json={
            "name": "Test App",
            "version": "1.0.0"
        }, headers=headers)
        
        # 应该被CORS策略阻止
        assert response.status_code in [403, 400]
```

### 5.5 测试执行

**测试命令：**

```bash
# 后端测试
cd backend

# 运行单元测试
pytest tests/unit/ -v --cov=app --cov-report=html

# 运行集成测试
pytest tests/integration/ -v

# 运行性能测试
python tests/performance/load_test.py

# 运行安全测试
pytest tests/security/ -v

# 前端测试
cd ../frontend

# 运行单元测试
npm test

# 运行E2E测试
npm run test:e2e

# 生成测试覆盖率报告
npm run test:coverage
```

**持续集成配置：`.github/workflows/ci.yml`**

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  backend-tests:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        cd backend
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio
    
    - name: Run tests
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost/test_db
        REDIS_URL: redis://localhost:6379
      run: |
        cd backend
        pytest tests/ -v --cov=app --cov-report=xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./backend/coverage.xml
  
  frontend-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    
    - name: Install dependencies
      run: |
        cd frontend
        npm ci
    
    - name: Run tests
      run: |
        cd frontend
        npm test -- --coverage --watchAll=false
    
    - name: Build
      run: |
        cd frontend
        npm run build
  
  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Run security scan
      uses: securecodewarrior/github-action-add-sarif@v1
      with:
        sarif-file: 'security-scan-results.sarif'
```

---

## 总结

本文档详细描述了金鱼智盒卡密授权系统的完整开发信息，涵盖了前端、后端、数据、UI/UX设计等各个方面。系统采用现代化的技术栈，具备良好的可扩展性和维护性。

**主要特点：**
- 前后端分离架构，技术栈先进
- 完善的权限控制和安全机制
- 响应式设计，支持多设备访问
- 详细的API文档和测试覆盖
- 完整的部署和运维方案

**后续发展方向：**
- 持续优化性能和用户体验
- 完善监控和告警系统
- 增加更多企业级功能
- 提升系统安全性和稳定性

本文档将随着系统的发展持续更新，为开发团队提供最新的技术指导。



