# 金鱼智盒卡密授权系统 - 完整开发文档

## 📋 文档目录

- [1. 系统概述](#1-系统概述)
  - [1.1 项目简介](#11-项目简介)
  - [1.2 核心功能](#12-核心功能)
  - [1.3 技术架构](#13-技术架构)
  - [1.4 系统特色](#14-系统特色)
- [2. 技术栈与架构设计](#2-技术栈与架构设计)
  - [2.1 前端技术栈](#21-前端技术栈)
  - [2.2 后端技术栈](#22-后端技术栈)
  - [2.3 数据库设计](#23-数据库设计)
  - [2.4 系统架构图](#24-系统架构图)
- [3. 核心功能模块](#3-核心功能模块)
  - [3.1 用户认证系统](#31-用户认证系统)
  - [3.2 应用管理模块](#32-应用管理模块)
  - [3.3 卡密管理系统](#33-卡密管理系统)
  - [3.4 设备绑定机制](#34-设备绑定机制)
  - [3.5 应用公告功能](#35-应用公告功能)
  - [3.6 实时通知系统](#36-实时通知系统)
- [4. 模块联动机制](#4-模块联动机制)
  - [4.1 事件驱动架构](#41-事件驱动架构)
  - [4.2 状态同步机制](#42-状态同步机制)
  - [4.3 缓存一致性](#43-缓存一致性)
- [5. 安全与性能优化](#5-安全与性能优化)
  - [5.1 安全策略](#51-安全策略)
  - [5.2 性能优化](#52-性能优化)
  - [5.3 监控审计](#53-监控审计)
- [6. API接口规范](#6-api接口规范)
  - [6.1 接口设计原则](#61-接口设计原则)
  - [6.2 认证授权](#62-认证授权)
  - [6.3 核心接口](#63-核心接口)
- [7. 前端实现指南](#7-前端实现指南)
  - [7.1 组件架构](#71-组件架构)
  - [7.2 状态管理](#72-状态管理)
  - [7.3 UI/UX设计](#73-uiux设计)
- [8. 后端实现指南](#8-后端实现指南)
  - [8.1 服务架构](#81-服务架构)
  - [8.2 数据访问层](#82-数据访问层)
  - [8.3 业务逻辑层](#83-业务逻辑层)
- [9. 部署与运维](#9-部署与运维)
  - [9.1 环境配置](#91-环境配置)
  - [9.2 部署指南](#92-部署指南)
  - [9.3 监控运维](#93-监控运维)
- [10. 测试方案](#10-测试方案)
  - [10.1 测试策略](#101-测试策略)
  - [10.2 测试用例](#102-测试用例)
  - [10.3 性能测试](#103-性能测试)
- [11. 附录](#11-附录)
  - [11.1 配置参考](#111-配置参考)
  - [11.2 错误码规范](#112-错误码规范)
  - [11.3 开发规范](#113-开发规范)

---

## 1. 系统概述

### 1.1 项目简介

金鱼智盒卡密授权系统是一个企业级的软件授权管理平台，专为Python桌面应用设计。系统采用前后端分离架构，支持账号密码+卡密双重验证机制，提供完整的授权生命周期管理。

**核心价值：**
- 🔐 **双重验证**：账号密码+卡密双重安全保障
- 🏢 **企业级**：支持多应用、多租户管理
- 🛡️ **安全可靠**：AES-256加密、JWT认证、设备绑定
- 📊 **数据驱动**：完整的统计分析和审计日志
- 🚀 **高性能**：Redis缓存、连接池优化、异步处理

### 1.2 核心功能

#### 应用管理
- **多应用支持**：独立的授权策略和配置
- **版本控制**：应用版本管理和兼容性检查
- **状态管理**：正常/维护/停用状态控制
- **Webhook集成**：事件通知和第三方系统集成

#### 卡密管理
- **批量生成**：支持大批量卡密生成和导出
- **激活控制**：设备绑定、时间限制、使用次数
- **到期管理**：自动到期检查和通知提醒
- **规则引擎**：灵活的授权规则配置

#### 用户管理
- **角色权限**：超级管理员/管理员/普通用户
- **权限控制**：基于RBAC的细粒度权限管理
- **操作审计**：完整的用户操作记录
- **安全策略**：密码策略、登录限制、IP白名单

#### 设备绑定
- **硬件指纹**：CPU、主板、硬盘等硬件信息识别
- **设备限制**：单卡密支持的最大设备数量
- **设备管理**：设备解绑、黑名单管理
- **异常检测**：设备变更检测和安全告警

### 1.3 技术架构

```mermaid
graph TB
    subgraph "客户端层"
        A[Python桌面应用]
        B[Web管理界面]
        C[移动端应用]
    end
    
    subgraph "网关层"
        D[Nginx反向代理]
        E[API网关]
        F[负载均衡]
    end
    
    subgraph "应用层"
        G[前端 React+Next.js]
        H[后端 FastAPI]
        I[WebSocket服务]
    end
    
    subgraph "服务层"
        J[认证服务]
        K[授权服务]
        L[通知服务]
        M[审计服务]
    end
    
    subgraph "数据层"
        N[PostgreSQL主库]
        O[Redis缓存]
        P[文件存储]
        Q[日志存储]
    end
    
    A --> D
    B --> D
    C --> D
    D --> E
    E --> F
    F --> G
    F --> H
    F --> I
    
    H --> J
    H --> K
    H --> L
    H --> M
    
    J --> N
    K --> N
    L --> O
    M --> Q
    
    H --> N
    H --> O
    H --> P
```

### 1.4 系统特色

#### 高可用性
- **99.9%可用性**：系统年度可用性保障
- **故障恢复**：自动故障检测和快速恢复
- **数据备份**：定时备份和灾难恢复方案
- **监控告警**：实时监控和智能告警

#### 高性能
- **响应时间**：API接口响应时间≤300ms
- **并发处理**：支持1000+并发用户
- **缓存策略**：多级缓存和智能预加载
- **数据库优化**：索引优化和查询优化

#### 高安全性
- **数据加密**：AES-256数据加密存储
- **传输安全**：HTTPS/WSS加密传输
- **访问控制**：多因子认证和权限控制
- **安全审计**：完整的安全日志和审计

#### 易扩展性
- **模块化设计**：松耦合的模块化架构
- **插件机制**：支持功能插件扩展
- **API开放**：完整的RESTful API
- **微服务就绪**：支持微服务架构演进

---

## 2. 技术栈与架构设计

### 2.1 前端技术栈

#### 核心框架
```json
{
  "react": "18.2.0",
  "next": "13.4.19",
  "typescript": "5.1.6"
}
```

**选型理由：**
- **React 18**：最新的并发特性，更好的性能
- **Next.js 13**：App Router、服务端组件、优化的构建
- **TypeScript**：类型安全，减少运行时错误

#### UI组件库
```json
{
  "antd": "5.8.6",
  "@heroicons/react": "2.0.18",
  "@headlessui/react": "1.7.17"
}
```

**特性说明：**
- **Ant Design 5**：企业级UI设计语言，组件丰富
- **Heroicons**：高质量SVG图标，支持多种样式
- **Headless UI**：无样式组件，高度可定制

#### 状态管理
```json
{
  "zustand": "4.4.1",
  "swr": "2.2.2",
  "react-hook-form": "7.45.4"
}
```

**架构优势：**
- **Zustand**：轻量级状态管理，TypeScript友好
- **SWR**：数据获取和缓存，自动重新验证
- **React Hook Form**：高性能表单库，最少重渲染

#### 样式与动画
```json
{
  "tailwindcss": "3.3.3",
  "framer-motion": "10.16.4",
  "class-variance-authority": "0.7.0"
}
```

### 2.2 后端技术栈

#### 核心框架
```python
# pyproject.toml
[tool.poetry.dependencies]
python = "^3.9"
fastapi = "^0.103.0"
uvicorn = {extras = ["standard"], version = "^0.23.0"}
pydantic = "^2.3.0"
```

**技术优势：**
- **FastAPI**：高性能异步框架，自动API文档
- **Uvicorn**：ASGI服务器，支持HTTP/2和WebSocket
- **Pydantic**：数据验证和序列化，类型安全

#### 数据库与缓存
```python
# 数据库
sqlalchemy = "^2.0.20"
alembic = "^1.12.0"
asyncpg = "^0.28.0"

# 缓存
redis = "^4.6.0"
aioredis = "^2.0.1"
```

#### 安全与认证
```python
# 认证
python-jose = {extras = ["cryptography"], version = "^3.3.0"}
passlib = {extras = ["bcrypt"], version = "^1.7.4"}
python-multipart = "^0.0.6"

# 安全
cryptography = "^41.0.4"
```

### 2.3 数据库设计

#### 主数据库（PostgreSQL）

**核心表结构：**

```sql
-- 用户表
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) DEFAULT 'user',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 应用表
CREATE TABLE applications (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    version VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    webhook_url VARCHAR(500),
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 卡密表
CREATE TABLE licenses (
    id SERIAL PRIMARY KEY,
    license_key VARCHAR(100) UNIQUE NOT NULL,
    application_id INTEGER REFERENCES applications(id),
    license_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'inactive',
    max_devices INTEGER DEFAULT 1,
    expires_at TIMESTAMP,
    activated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 设备表
CREATE TABLE devices (
    id SERIAL PRIMARY KEY,
    device_id VARCHAR(255) UNIQUE NOT NULL,
    device_name VARCHAR(100),
    device_type VARCHAR(50),
    os_info VARCHAR(200),
    hardware_info JSONB,
    license_id INTEGER REFERENCES licenses(id),
    status VARCHAR(20) DEFAULT 'active',
    first_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 缓存设计（Redis）

**缓存策略：**

```python
# 缓存键命名规范
CACHE_KEYS = {
    'user_session': 'session:{user_id}',
    'license_info': 'license:{license_key}',
    'device_info': 'device:{device_id}',
    'app_config': 'app:{app_id}:config',
    'rate_limit': 'rate_limit:{ip}:{endpoint}',
    'notification': 'notification:{user_id}'
}

# 缓存过期时间
CACHE_TTL = {
    'session': 3600 * 24,      # 24小时
    'license': 3600 * 2,       # 2小时
    'device': 3600,            # 1小时
    'config': 3600 * 12,       # 12小时
    'rate_limit': 60,          # 1分钟
    'notification': 3600 * 6   # 6小时
}
```

### 2.4 系统架构图

#### 部署架构

```mermaid
graph TB
    subgraph "负载均衡层"
        LB[Nginx负载均衡]
    end
    
    subgraph "应用服务器集群"
        APP1[应用服务器1]
        APP2[应用服务器2]
        APP3[应用服务器3]
    end
    
    subgraph "数据库集群"
        DB_MASTER[PostgreSQL主库]
        DB_SLAVE1[PostgreSQL从库1]
        DB_SLAVE2[PostgreSQL从库2]
    end
    
    subgraph "缓存集群"
        REDIS_MASTER[Redis主节点]
        REDIS_SLAVE1[Redis从节点1]
        REDIS_SLAVE2[Redis从节点2]
    end
    
    subgraph "监控系统"
        MONITOR[Prometheus]
        GRAFANA[Grafana]
        ALERT[AlertManager]
    end
    
    LB --> APP1
    LB --> APP2
    LB --> APP3
    
    APP1 --> DB_MASTER
    APP2 --> DB_MASTER
    APP3 --> DB_MASTER
    
    DB_MASTER --> DB_SLAVE1
    DB_MASTER --> DB_SLAVE2
    
    APP1 --> REDIS_MASTER
    APP2 --> REDIS_MASTER
    APP3 --> REDIS_MASTER
    
    REDIS_MASTER --> REDIS_SLAVE1
    REDIS_MASTER --> REDIS_SLAVE2
    
    APP1 --> MONITOR
    APP2 --> MONITOR
    APP3 --> MONITOR
    
    MONITOR --> GRAFANA
    MONITOR --> ALERT
```

---

## 3. 核心功能模块

### 3.1 用户认证系统

#### 认证流程

```mermaid
sequenceDiagram
    participant C as 客户端
    participant A as 认证服务
    participant D as 数据库
    participant R as Redis缓存
    
    C->>A: 登录请求(用户名/密码)
    A->>D: 验证用户凭据
    D-->>A: 返回用户信息
    A->>A: 生成JWT Token
    A->>R: 存储会话信息
    A-->>C: 返回Token和用户信息
    
    Note over C,R: 后续请求携带Token
    
    C->>A: API请求(携带Token)
    A->>A: 验证Token签名
    A->>R: 检查会话状态
    R-->>A: 返回会话信息
    A-->>C: 返回API响应
```

#### 权限控制

**角色定义：**

```python
# models/user.py
class UserRole(str, Enum):
    SUPER_ADMIN = "super_admin"  # 超级管理员
    ADMIN = "admin"              # 管理员
    USER = "user"                # 普通用户

# 权限映射
ROLE_PERMISSIONS = {
    UserRole.SUPER_ADMIN: [
        "user:*", "application:*", "license:*", 
        "device:*", "system:*", "audit:*"
    ],
    UserRole.ADMIN: [
        "user:read", "user:create", "user:update",
        "application:*", "license:*", "device:*",
        "audit:read"
    ],
    UserRole.USER: [
        "user:read:self", "license:read", "device:read"
    ]
}
```

**权限装饰器：**

```python
# decorators/auth.py
from functools import wraps
from fastapi import HTTPException, status

def require_permission(permission: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # 从请求中获取当前用户
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="未认证"
                )
            
            # 检查权限
            if not has_permission(current_user.role, permission):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="权限不足"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

def has_permission(user_role: UserRole, required_permission: str) -> bool:
    """检查用户是否具有指定权限"""
    user_permissions = ROLE_PERMISSIONS.get(user_role, [])
    
    for permission in user_permissions:
        if permission == "*" or permission == required_permission:
            return True
        
        # 支持通配符权限
        if permission.endswith(":*"):
            prefix = permission[:-2]
            if required_permission.startswith(prefix + ":"):
                return True
    
    return False
```

### 3.2 应用管理模块

#### 应用生命周期

```mermaid
stateDiagram-v2
    [*] --> 创建中
    创建中 --> 活跃
    活跃 --> 维护中
    维护中 --> 活跃
    活跃 --> 停用
    停用 --> 活跃
    停用 --> [*]
    
    note right of 活跃
        正常提供服务
        可以激活卡密
    end note
    
    note right of 维护中
        暂停新激活
        现有授权继续有效
    end note
    
    note right of 停用
        停止所有服务
        撤销所有授权
    end note
```

#### 应用配置管理

```python
# schemas/application.py
class ApplicationSettings(BaseModel):
    """应用设置"""
    max_devices_per_license: int = 1
    allow_device_transfer: bool = False
    require_online_verification: bool = True
    verification_interval_hours: int = 24
    auto_ban_on_violation: bool = True
    webhook_events: List[str] = []
    custom_fields: Dict[str, Any] = {}
    
    # 安全设置
    ip_whitelist: List[str] = []
    allowed_countries: List[str] = []
    block_vpn: bool = False
    
    # 功能开关
    enable_device_binding: bool = True
    enable_time_limit: bool = True
    enable_usage_tracking: bool = True

class Application(BaseModel):
    id: int
    name: str
    description: Optional[str]
    version: str
    status: ApplicationStatus
    webhook_url: Optional[str]
    settings: ApplicationSettings
    created_at: datetime
    updated_at: datetime
    
    # 统计信息
    total_licenses: int = 0
    active_licenses: int = 0
    total_devices: int = 0
```

#### Webhook集成

```python
# services/webhook.py
class WebhookService:
    """Webhook服务"""
    
    async def send_webhook(self, app_id: int, event: str, data: dict):
        """发送Webhook通知"""
        app = await self.get_application(app_id)
        if not app.webhook_url:
            return
        
        payload = {
            "event": event,
            "timestamp": datetime.utcnow().isoformat(),
            "application_id": app_id,
            "data": data
        }
        
        # 添加签名
        signature = self._generate_signature(payload, app.webhook_secret)
        headers = {
            "Content-Type": "application/json",
            "X-Webhook-Signature": signature,
            "User-Agent": "GoldfishLicense-Webhook/1.0"
        }
        
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.post(
                    app.webhook_url,
                    json=payload,
                    headers=headers
                )
                
                # 记录Webhook调用日志
                await self._log_webhook_call(
                    app_id, event, response.status_code, 
                    response.text[:1000]
                )
                
        except Exception as e:
            logger.error(f"Webhook调用失败: {e}")
            await self._log_webhook_call(
                app_id, event, 0, str(e)
            )
    
    def _generate_signature(self, payload: dict, secret: str) -> str:
        """生成Webhook签名"""
        import hmac
        import hashlib
        
        message = json.dumps(payload, sort_keys=True)
        signature = hmac.new(
            secret.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return f"sha256={signature}"
```

### 3.3 卡密管理系统

#### 卡密生成算法

```python
# services/license_generator.py
class LicenseGenerator:
    """卡密生成器"""
    
    def __init__(self):
        self.charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        self.segment_length = 4
        self.segments = 4
    
    def generate_license_key(self, app_id: int, license_type: str) -> str:
        """生成卡密"""
        # 生成随机部分
        random_part = self._generate_random_string()
        
        # 添加校验码
        checksum = self._calculate_checksum(random_part, app_id)
        
        # 组合最终卡密
        license_key = f"{random_part}-{checksum}"
        
        return license_key
    
    def _generate_random_string(self) -> str:
        """生成随机字符串"""
        segments = []
        for _ in range(self.segments):
            segment = ''.join(
                secrets.choice(self.charset) 
                for _ in range(self.segment_length)
            )
            segments.append(segment)
        
        return '-'.join(segments)
    
    def _calculate_checksum(self, key: str, app_id: int) -> str:
        """计算校验码"""
        import hashlib
        
        # 组合键值和应用ID
        data = f"{key}-{app_id}"
        
        # 计算MD5哈希
        hash_obj = hashlib.md5(data.encode())
        hash_hex = hash_obj.hexdigest()
        
        # 取前4位并转换为大写字母和数字
        checksum = ''.join(
            self.charset[int(hash_hex[i:i+2], 16) % len(self.charset)]
            for i in range(0, 8, 2)
        )
        
        return checksum
    
    def validate_license_key(self, license_key: str, app_id: int) -> bool:
        """验证卡密格式"""
        try:
            parts = license_key.split('-')
            if len(parts) != self.segments + 1:
                return False
            
            # 重新计算校验码
            random_part = '-'.join(parts[:-1])
            expected_checksum = self._calculate_checksum(random_part, app_id)
            
            return parts[-1] == expected_checksum
            
        except Exception:
            return False
```

#### 批量操作

```python
# services/license_batch.py
class LicenseBatchService:
    """卡密批量操作服务"""
    
    async def batch_generate(self, request: BatchGenerateRequest) -> BatchResult:
        """批量生成卡密"""
        results = []
        errors = []
        
        # 分批处理，避免内存溢出
        batch_size = 1000
        total_batches = (request.quantity + batch_size - 1) // batch_size
        
        for batch_num in range(total_batches):
            start_idx = batch_num * batch_size
            end_idx = min(start_idx + batch_size, request.quantity)
            batch_quantity = end_idx - start_idx
            
            try:
                batch_licenses = await self._generate_batch(
                    request.application_id,
                    request.license_type,
                    batch_quantity,
                    request.expires_at
                )
                results.extend(batch_licenses)
                
            except Exception as e:
                error_msg = f"批次 {batch_num + 1} 生成失败: {str(e)}"
                errors.append(error_msg)
                logger.error(error_msg)
        
        return BatchResult(
            total_requested=request.quantity,
            total_generated=len(results),
            licenses=results,
            errors=errors
        )
    
    async def _generate_batch(
        self, 
        app_id: int, 
        license_type: str, 
        quantity: int,
        expires_at: Optional[datetime]
    ) -> List[License]:
        """生成单个批次的卡密"""
        licenses = []
        
        # 生成卡密数据
        for _ in range(quantity):
            license_key = self.generator.generate_license_key(app_id, license_type)
            
            license_data = {
                "license_key": license_key,
                "application_id": app_id,
                "license_type": license_type,
                "status": "inactive",
                "expires_at": expires_at,
                "created_at": datetime.utcnow()
            }
            
            licenses.append(license_data)
        
        # 批量插入数据库
        async with self.db.begin() as transaction:
            try:
                result = await self.db.execute(
                    insert(License).values(licenses)
                )
                await transaction.commit()
                
                # 返回生成的卡密对象
                return await self._fetch_generated_licenses(
                    [data["license_key"] for data in licenses]
                )
                
            except Exception as e:
                await transaction.rollback()
                raise e
```

### 3.4 设备绑定机制

#### 硬件指纹算法

```python
# utils/hardware_fingerprint.py
class HardwareFingerprint:
    """硬件指纹生成器"""
    
    @staticmethod
    def generate_device_id(hardware_info: dict) -> str:
        """生成设备ID"""
        # 提取关键硬件信息
        key_components = [
            hardware_info.get('cpu_id', ''),
            hardware_info.get('motherboard_serial', ''),
            hardware_info.get('disk_serial', ''),
            hardware_info.get('mac_address', ''),
            hardware_info.get('bios_uuid', '')
        ]
        
        # 过滤空值
        key_components = [comp for comp in key_components if comp]
        
        if not key_components:
            raise ValueError("无法获取有效的硬件信息")
        
        # 生成指纹
        combined = '|'.join(sorted(key_components))
        fingerprint = hashlib.sha256(combined.encode()).hexdigest()
        
        return fingerprint[:32].upper()
    
    @staticmethod
    def calculate_similarity(device1: dict, device2: dict) -> float:
        """计算设备相似度"""
        components = ['cpu_id', 'motherboard_serial', 'disk_serial', 'mac_address']
        
        matches = 0
        total = 0
        
        for component in components:
            val1 = device1.get(component)
            val2 = device2.get(component)
            
            if val1 and val2:
                total += 1
                if val1 == val2:
                    matches += 1
        
        return matches / total if total > 0 else 0.0
    
    @staticmethod
    def is_device_changed(old_info: dict, new_info: dict, threshold: float = 0.7) -> bool:
        """检测设备是否发生重大变更"""
        similarity = HardwareFingerprint.calculate_similarity(old_info, new_info)
        return similarity < threshold
```

#### 设备验证流程

```python
# services/device_verification.py
class DeviceVerificationService:
    """设备验证服务"""
    
    async def verify_device(
        self, 
        license_key: str, 
        device_info: DeviceInfo
    ) -> VerificationResult:
        """验证设备"""
        # 1. 验证卡密
        license = await self.license_service.get_by_key(license_key)
        if not license or license.status != 'active':
            return VerificationResult(
                success=False,
                error_code="INVALID_LICENSE",
                message="无效的卡密"
            )
        
        # 2. 检查卡密是否过期
        if license.expires_at and license.expires_at < datetime.utcnow():
            return VerificationResult(
                success=False,
                error_code="LICENSE_EXPIRED",
                message="卡密已过期"
            )
        
        # 3. 生成设备ID
        device_id = HardwareFingerprint.generate_device_id(
            device_info.hardware_info
        )
        
        # 4. 检查设备是否已绑定
        existing_device = await self.device_service.get_by_device_id(device_id)
        
        if existing_device:
            # 设备已存在，验证是否绑定到当前卡密
            if existing_device.license_id != license.id:
                return VerificationResult(
                    success=False,
                    error_code="DEVICE_BOUND_TO_OTHER_LICENSE",
                    message="设备已绑定到其他卡密"
                )
            
            # 更新设备信息
            await self._update_device_info(existing_device, device_info)
            
        else:
            # 新设备，检查卡密设备数量限制
            device_count = await self.device_service.count_by_license(license.id)
            
            if device_count >= license.max_devices:
                return VerificationResult(
                    success=False,
                    error_code="MAX_DEVICES_EXCEEDED",
                    message=f"超出最大设备数量限制({license.max_devices})"
                )
            
            # 创建新设备记录
            await self._create_device_record(license.id, device_id, device_info)
        
        # 5. 记录验证日志
        await self._log_verification(license.id, device_id, "SUCCESS")
        
        return VerificationResult(
            success=True,
            device_id=device_id,
            license_info=license
        )
    
    async def _detect_device_changes(
        self, 
        device: Device, 
        new_info: DeviceInfo
    ) -> List[str]:
        """检测设备变更"""
        changes = []
        
        # 检查硬件变更
        if HardwareFingerprint.is_device_changed(
            device.hardware_info, 
            new_info.hardware_info
        ):
            changes.append("硬件配置发生重大变更")
        
        # 检查操作系统变更
        if device.os_info != new_info.os_info:
            changes.append(f"操作系统变更: {device.os_info} -> {new_info.os_info}")
        
        # 检查设备名称变更
        if device.device_name != new_info.device_name:
            changes.append(f"设备名称变更: {device.device_name} -> {new_info.device_name}")
        
        return changes
```

### 3.5 应用公告功能

#### 公告系统架构

```mermaid
graph TB
    subgraph "公告管理"
        A[公告创建]
        B[公告编辑]
        C[公告发布]
        D[公告归档]
    end
    
    subgraph "目标管理"
        E[用户筛选]
        F[应用筛选]
        G[角色筛选]
        H[自定义条件]
    end
    
    subgraph "推送渠道"
        I[Web通知]
        J[邮件推送]
        K[短信推送]
        L[WebSocket实时]
    end
    
    subgraph "效果统计"
        M[阅读统计]
        N[点击统计]
        O[转化统计]
        P[反馈收集]
    end
    
    A --> E
    B --> F
    C --> G
    D --> H
    
    E --> I
    F --> J
    G --> K
    H --> L
    
    I --> M
    J --> N
    K --> O
    L --> P
```

#### 公告数据模型

```python
# models/announcement.py
class AnnouncementType(str, Enum):
    INFO = "info"        # 信息公告
    WARNING = "warning"  # 警告公告
    ERROR = "error"      # 错误公告
    SUCCESS = "success"  # 成功公告
    MAINTENANCE = "maintenance"  # 维护公告

class AnnouncementPriority(str, Enum):
    LOW = "low"          # 低优先级
    MEDIUM = "medium"    # 中优先级
    HIGH = "high"        # 高优先级
    URGENT = "urgent"    # 紧急

class AnnouncementStatus(str, Enum):
    DRAFT = "draft"          # 草稿
    SCHEDULED = "scheduled"  # 已安排
    PUBLISHED = "published"  # 已发布
    EXPIRED = "expired"      # 已过期
    ARCHIVED = "archived"    # 已归档

class Announcement(BaseModel):
    id: int
    title: str
    content: str
    type: AnnouncementType
    priority: AnnouncementPriority
    status: AnnouncementStatus
    
    # 目标设置
    target_type: str  # 'all', 'users', 'applications', 'roles'
    target_ids: List[int] = []
    
    # 显示设置
    display_type: str  # 'banner', 'modal', 'notification'
    is_sticky: bool = False
    is_dismissible: bool = True
    
    # 时间设置
    publish_at: Optional[datetime]
    expires_at: Optional[datetime]
    
    # 附件
    attachments: List[AnnouncementAttachment] = []
    
    # 统计信息
    view_count: int = 0
    click_count: int = 0
    
    # 元数据
    created_by: int
    created_at: datetime
    updated_at: datetime

class AnnouncementAttachment(BaseModel):
    id: int
    announcement_id: int
    filename: str
    file_url: str
    file_size: int
    mime_type: str
    created_at: datetime
```

#### 公告推送服务

```python
# services/announcement_push.py
class AnnouncementPushService:
    """公告推送服务"""
    
    def __init__(self):
        self.notification_service = NotificationService()
        self.email_service = EmailService()
        self.websocket_manager = WebSocketManager()
    
    async def push_announcement(self, announcement: Announcement):
        """推送公告"""
        # 1. 获取目标用户列表
        target_users = await self._get_target_users(announcement)
        
        # 2. 根据优先级选择推送渠道
        channels = self._get_push_channels(announcement.priority)
        
        # 3. 批量推送
        tasks = []
        
        for channel in channels:
            if channel == 'websocket':
                tasks.append(self._push_websocket(announcement, target_users))
            elif channel == 'email':
                tasks.append(self._push_email(announcement, target_users))
            elif channel == 'notification':
                tasks.append(self._push_notification(announcement, target_users))
        
        # 并发执行推送任务
        await asyncio.gather(*tasks, return_exceptions=True)
        
        # 4. 记录推送日志
        await self._log_push_result(announcement.id, target_users, channels)
    
    async def _get_target_users(self, announcement: Announcement) -> List[User]:
        """获取目标用户"""
        if announcement.target_type == 'all':
            return await self.user_service.get_all_active_users()
        
        elif announcement.target_type == 'users':
            return await self.user_service.get_users_by_ids(announcement.target_ids)
        
        elif announcement.target_type == 'roles':
            return await self.user_service.get_users_by_roles(announcement.target_ids)
        
        elif announcement.target_type == 'applications':
            # 获取使用指定应用的用户
            return await self.user_service.get_users_by_applications(
                announcement.target_ids
            )
        
        return []
    
    def _get_push_channels(self, priority: AnnouncementPriority) -> List[str]:
        """根据优先级获取推送渠道"""
        channel_map = {
            AnnouncementPriority.LOW: ['notification'],
            AnnouncementPriority.MEDIUM: ['notification', 'websocket'],
            AnnouncementPriority.HIGH: ['notification', 'websocket', 'email'],
            AnnouncementPriority.URGENT: ['notification', 'websocket', 'email', 'sms']
        }
        
        return channel_map.get(priority, ['notification'])
    
    async def _push_websocket(self, announcement: Announcement, users: List[User]):
        """WebSocket推送"""
        message = {
            "type": "announcement",
            "data": {
                "id": announcement.id,
                "title": announcement.title,
                "content": announcement.content,
                "type": announcement.type,
                "priority": announcement.priority,
                "display_type": announcement.display_type
            }
        }
        
        for user in users:
            await self.websocket_manager.send_to_user(user.id, message)
    
    async def _push_notification(self, announcement: Announcement, users: List[User]):
        """应用内通知推送"""
        for user in users:
            await self.notification_service.create_notification(
                user_id=user.id,
                title=announcement.title,
                content=announcement.content[:200],  # 限制长度
                type=announcement.type,
                data={
                    "announcement_id": announcement.id,
                    "action_url": f"/announcements/{announcement.id}"
                }
            )
```

### 3.6 实时通知系统

#### WebSocket连接管理

```python
# services/websocket_manager.py
class WebSocketManager:
    """WebSocket连接管理器"""
    
    def __init__(self):
        # 用户连接映射 {user_id: [websocket1, websocket2, ...]}
        self.user_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # 应用连接映射 {app_id: [websocket1, websocket2, ...]}
        self.app_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # 连接元数据 {websocket: ConnectionInfo}
        self.connection_info: Dict[WebSocket, ConnectionInfo] = {}
        
        # 连接统计
        self.stats = {
            "total_connections": 0,
            "user_connections": 0,
            "app_connections": 0,
            "messages_sent": 0,
            "messages_received": 0
        }
    
    async def connect_user(self, websocket: WebSocket, user_id: int, token: str):
        """用户连接"""
        await websocket.accept()
        
        # 验证token
        if not await self._verify_token(token, user_id):
            await websocket.close(code=4001, reason="Invalid token")
            return
        
        # 添加连接
        self.user_connections[user_id].append(websocket)
        self.connection_info[websocket] = ConnectionInfo(
            type="user",
            user_id=user_id,
            connected_at=datetime.utcnow(),
            last_ping=datetime.utcnow()
        )
        
        self.stats["total_connections"] += 1
        self.stats["user_connections"] += 1
        
        logger.info(f"用户 {user_id} WebSocket连接建立")
        
        # 发送连接确认
        await self.send_to_websocket(websocket, {
            "type": "connection_established",
            "user_id": user_id,
            "timestamp": datetime.utcnow().isoformat()
        })
    
    async def connect_application(
        self, 
        websocket: WebSocket, 
        app_id: int, 
        api_key: str
    ):
        """应用连接"""
        await websocket.accept()
        
        # 验证API密钥
        if not await self._verify_api_key(api_key, app_id):
            await websocket.close(code=4001, reason="Invalid API key")
            return
        
        # 添加连接
        self.app_connections[app_id].append(websocket)
        self.connection_info[websocket] = ConnectionInfo(
            type="application",
            app_id=app_id,
            connected_at=datetime.utcnow(),
            last_ping=datetime.utcnow()
        )
        
        self.stats["total_connections"] += 1
        self.stats["app_connections"] += 1
        
        logger.info(f"应用 {app_id} WebSocket连接建立")
    
    async def disconnect(self, websocket: WebSocket):
        """断开连接"""
        if websocket not in self.connection_info:
            return
        
        conn_info = self.connection_info[websocket]
        
        # 从连接映射中移除
        if conn_info.type == "user" and conn_info.user_id:
            self.user_connections[conn_info.user_id].remove(websocket)
            if not self.user_connections[conn_info.user_id]:
                del self.user_connections[conn_info.user_id]
            self.stats["user_connections"] -= 1
            
        elif conn_info.type == "application" and conn_info.app_id:
            self.app_connections[conn_info.app_id].remove(websocket)
            if not self.app_connections[conn_info.app_id]:
                del self.app_connections[conn_info.app_id]
            self.stats["app_connections"] -= 1
        
        # 移除连接信息
        del self.connection_info[websocket]
        self.stats["total_connections"] -= 1
        
        logger.info(f"WebSocket连接断开: {conn_info.type}")
    
    async def send_to_user(self, user_id: int, message: dict):
        """发送消息给指定用户"""
        if user_id not in self.user_connections:
            return
        
        # 发送给用户的所有连接
        disconnected = []
        for websocket in self.user_connections[user_id]:
            try:
                await self.send_to_websocket(websocket, message)
            except Exception as e:
                logger.error(f"发送消息失败: {e}")
                disconnected.append(websocket)
        
        # 清理断开的连接
        for websocket in disconnected:
            await self.disconnect(websocket)
    
    async def send_to_application(self, app_id: int, message: dict):
        """发送消息给指定应用"""
        if app_id not in self.app_connections:
            return
        
        disconnected = []
        for websocket in self.app_connections[app_id]:
            try:
                await self.send_to_websocket(websocket, message)
            except Exception as e:
                logger.error(f"发送消息失败: {e}")
                disconnected.append(websocket)
        
        # 清理断开的连接
        for websocket in disconnected:
            await self.disconnect(websocket)
    
    async def broadcast_to_all(self, message: dict):
        """广播消息给所有连接"""
        all_websockets = list(self.connection_info.keys())
        
        tasks = [
            self.send_to_websocket(ws, message) 
            for ws in all_websockets
        ]
        
        # 并发发送
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 统计发送结果
        success_count = sum(1 for r in results if not isinstance(r, Exception))
        error_count = len(results) - success_count
        
        logger.info(f"广播消息完成: 成功 {success_count}, 失败 {error_count}")
    
    async def send_to_websocket(self, websocket: WebSocket, message: dict):
        """发送消息到WebSocket"""
        try:
            await websocket.send_json(message)
            self.stats["messages_sent"] += 1
        except Exception as e:
            logger.error(f"WebSocket发送失败: {e}")
            raise
    
    async def handle_ping(self, websocket: WebSocket):
        """处理心跳"""
        if websocket in self.connection_info:
            self.connection_info[websocket].last_ping = datetime.utcnow()
            await self.send_to_websocket(websocket, {"type": "pong"})
    
    async def cleanup_stale_connections(self):
        """清理过期连接"""
        now = datetime.utcnow()
        stale_connections = []
        
        for websocket, info in self.connection_info.items():
            # 超过5分钟没有心跳的连接视为过期
            if (now - info.last_ping).total_seconds() > 300:
                stale_connections.append(websocket)
        
        for websocket in stale_connections:
            await self.disconnect(websocket)
            try:
                await websocket.close(code=4000, reason="Connection timeout")
            except Exception:
                pass
        
        if stale_connections:
            logger.info(f"清理了 {len(stale_connections)} 个过期连接")
```

---

## 4. 模块联动机制

### 4.1 事件驱动架构

#### 事件总线设计

```python
# core/event_bus.py
class EventBus:
    """事件总线"""
    
    def __init__(self):
        self._handlers: Dict[str, List[Callable]] = defaultdict(list)
        self._middleware: List[Callable] = []
        self._logger = logging.getLogger(__name__)
    
    def subscribe(self, event_type: str, handler: Callable):
        """订阅事件"""
        self._handlers[event_type].append(handler)
        self._logger.debug(f"订阅事件: {event_type} -> {handler.__name__}")
    
    def unsubscribe(self, event_type: str, handler: Callable):
        """取消订阅"""
        if handler in self._handlers[event_type]:
            self._handlers[event_type].remove(handler)
            self._logger.debug(f"取消订阅: {event_type} -> {handler.__name__}")
    
    async def publish(self, event: Event):
        """发布事件"""
        self._logger.info(f"发布事件: {event.type} - {event.data}")
        
        # 执行中间件
        for middleware in self._middleware:
            event = await middleware(event)
            if event is None:
                return  # 中间件拦截了事件
        
        # 执行事件处理器
        handlers = self._handlers.get(event.type, [])
        
        if not handlers:
            self._logger.warning(f"没有找到事件处理器: {event.type}")
            return
        
        # 并发执行所有处理器
        tasks = [self._execute_handler(handler, event) for handler in handlers]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 记录执行结果
        success_count = sum(1 for r in results if not isinstance(r, Exception))
        error_count = len(results) - success_count
        
        self._logger.info(
            f"事件处理完成: {event.type} - 成功: {success_count}, 失败: {error_count}"
        )
        
        # 记录错误
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                handler_name = handlers[i].__name__
                self._logger.error(
                    f"事件处理器执行失败: {handler_name} - {result}"
                )
    
    async def _execute_handler(self, handler: Callable, event: Event):
        """执行事件处理器"""
        try:
            if asyncio.iscoroutinefunction(handler):
                await handler(event)
            else:
                handler(event)
        except Exception as e:
            self._logger.error(f"事件处理器异常: {handler.__name__} - {e}")
            raise
    
    def add_middleware(self, middleware: Callable):
        """添加中间件"""
        self._middleware.append(middleware)

# 全局事件总线实例
event_bus = EventBus()
```

#### 事件定义

```python
# events/base.py
class Event:
    """基础事件类"""
    
    def __init__(self, event_type: str, data: dict, source: str = None):
        self.type = event_type
        self.data = data
        self.source = source or "system"
        self.timestamp = datetime.utcnow()
        self.id = str(uuid.uuid4())
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "type": self.type,
            "data": self.data,
            "source": self.source,
            "timestamp": self.timestamp.isoformat()
        }

# events/license_events.py
class LicenseActivatedEvent(Event):
    """卡密激活事件"""
    
    def __init__(self, license_id: int, device_id: str, user_id: int = None):
        super().__init__(
            event_type="license.activated",
            data={
                "license_id": license_id,
                "device_id": device_id,
                "user_id": user_id
            }
        )

class LicenseExpiredEvent(Event):
    """卡密过期事件"""
    
    def __init__(self, license_id: int, license_key: str):
        super().__init__(
            event_type="license.expired",
            data={
                "license_id": license_id,
                "license_key": license_key
            }
        )

class DeviceBindingEvent(Event):
    """设备绑定事件"""
    
    def __init__(self, device_id: str, license_id: int, action: str):
        super().__init__(
            event_type="device.binding",
            data={
                "device_id": device_id,
                "license_id": license_id,
                "action": action  # 'bind' or 'unbind'
            }
        )

# events/application_events.py
class ApplicationStatusChangedEvent(Event):
    """应用状态变更事件"""
    
    def __init__(self, app_id: int, old_status: str, new_status: str):
        super().__init__(
            event_type="application.status_changed",
            data={
                "app_id": app_id,
                "old_status": old_status,
                "new_status": new_status
            }
        )

class ApplicationMaintenanceEvent(Event):
    """应用维护事件"""
    
    def __init__(self, app_id: int, maintenance_type: str, message: str):
        super().__init__(
            event_type="application.maintenance",
            data={
                "app_id": app_id,
                "maintenance_type": maintenance_type,
                "message": message
            }
        )
```

#### 4.2.2 事件处理器

```python
# handlers/license_handlers.py
from events.event_bus import EventBus
from services.notification_service import NotificationService
from services.announcement_service import AnnouncementService

class LicenseEventHandler:
    """卡密事件处理器"""
    
    def __init__(self, notification_service: NotificationService, 
                 announcement_service: AnnouncementService):
        self.notification_service = notification_service
        self.announcement_service = announcement_service
        self._register_handlers()
    
    def _register_handlers(self):
        """注册事件处理器"""
        EventBus.subscribe("license.activated", self.handle_license_activated)
        EventBus.subscribe("license.expired", self.handle_license_expired)
        EventBus.subscribe("device.binding", self.handle_device_binding)
    
    async def handle_license_activated(self, event):
        """处理卡密激活事件"""
        data = event.data
        
        # 发送激活成功通知
        await self.notification_service.send_notification(
            user_id=data.get("user_id"),
            device_id=data["device_id"],
            message=f"卡密激活成功，设备ID: {data['device_id']}",
            notification_type="license_activated"
        )
        
        # 记录激活日志
        logger.info(f"License {data['license_id']} activated for device {data['device_id']}")
    
    async def handle_license_expired(self, event):
        """处理卡密过期事件"""
        data = event.data
        
        # 创建过期公告
        await self.announcement_service.create_announcement(
            title="卡密过期提醒",
            content=f"您的卡密 {data['license_key']} 已过期，请及时续费",
            announcement_type="warning",
            target_licenses=[data["license_id"]]
        )
        
        # 发送过期通知
        await self.notification_service.broadcast_to_license(
            license_id=data["license_id"],
            message="您的卡密已过期，请联系管理员续费",
            notification_type="license_expired"
        )
    
    async def handle_device_binding(self, event):
        """处理设备绑定事件"""
        data = event.data
        action = data["action"]
        
        if action == "bind":
            message = f"设备 {data['device_id']} 已成功绑定到卡密"
        else:
            message = f"设备 {data['device_id']} 已解除绑定"
        
        await self.notification_service.send_to_device(
            device_id=data["device_id"],
            message=message,
            notification_type="device_binding"
        )

# handlers/application_handlers.py
class ApplicationEventHandler:
    """应用事件处理器"""
    
    def __init__(self, notification_service: NotificationService):
        self.notification_service = notification_service
        self._register_handlers()
    
    def _register_handlers(self):
        EventBus.subscribe("application.status_changed", self.handle_status_changed)
        EventBus.subscribe("application.maintenance", self.handle_maintenance)
    
    async def handle_status_changed(self, event):
        """处理应用状态变更事件"""
        data = event.data
        
        if data["new_status"] == "maintenance":
            # 应用进入维护状态，通知所有用户
            await self.notification_service.broadcast_to_application(
                app_id=data["app_id"],
                message="应用正在维护中，暂时无法使用",
                notification_type="maintenance"
            )
        elif data["old_status"] == "maintenance" and data["new_status"] == "active":
            # 应用维护结束
            await self.notification_service.broadcast_to_application(
                app_id=data["app_id"],
                message="应用维护完成，现已恢复正常使用",
                notification_type="maintenance_complete"
            )
    
    async def handle_maintenance(self, event):
        """处理应用维护事件"""
        data = event.data
        
        await self.notification_service.broadcast_to_application(
            app_id=data["app_id"],
            message=data["message"],
            notification_type="maintenance_notice"
        )
```

#### 4.2.3 联动流程示例

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Auth as 认证服务
    participant License as 卡密服务
    participant Device as 设备服务
    participant Event as 事件总线
    participant Notify as 通知服务
    participant Announce as 公告服务
    
    Client->>Auth: 登录请求
    Auth->>License: 验证卡密
    License->>Device: 检查设备绑定
    Device-->>License: 设备验证通过
    License-->>Auth: 卡密验证通过
    Auth-->>Client: 登录成功
    
    License->>Event: 发布卡密激活事件
    Event->>Notify: 触发通知处理器
    Event->>Announce: 触发公告处理器
    
    Notify->>Client: 推送激活通知
    Announce->>Client: 推送相关公告
```

## 5. 安全与性能优化

### 5.1 安全措施

#### 5.1.1 密钥轮换机制

```python
# security/key_rotation.py
import secrets
import hashlib
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from config.settings import settings

class KeyRotationManager:
    """密钥轮换管理器"""
    
    def __init__(self):
        self.current_key = None
        self.previous_key = None
        self.rotation_interval = timedelta(days=30)  # 30天轮换一次
        self.last_rotation = None
    
    def generate_new_key(self) -> bytes:
        """生成新的加密密钥"""
        return Fernet.generate_key()
    
    def rotate_keys(self):
        """执行密钥轮换"""
        if self.should_rotate():
            self.previous_key = self.current_key
            self.current_key = self.generate_new_key()
            self.last_rotation = datetime.utcnow()
            
            # 保存到安全存储
            self._save_keys_to_storage()
            
            logger.info("Encryption keys rotated successfully")
            return True
        return False
    
    def should_rotate(self) -> bool:
        """检查是否需要轮换密钥"""
        if not self.last_rotation:
            return True
        
        return datetime.utcnow() - self.last_rotation > self.rotation_interval
    
    def encrypt_data(self, data: str) -> str:
        """使用当前密钥加密数据"""
        if not self.current_key:
            self.rotate_keys()
        
        fernet = Fernet(self.current_key)
        encrypted_data = fernet.encrypt(data.encode())
        return encrypted_data.decode()
    
    def decrypt_data(self, encrypted_data: str) -> str:
        """解密数据（支持当前和历史密钥）"""
        try:
            # 尝试使用当前密钥解密
            fernet = Fernet(self.current_key)
            return fernet.decrypt(encrypted_data.encode()).decode()
        except Exception:
            if self.previous_key:
                try:
                    # 尝试使用历史密钥解密
                    fernet = Fernet(self.previous_key)
                    decrypted = fernet.decrypt(encrypted_data.encode()).decode()
                    
                    # 使用新密钥重新加密
                    self._re_encrypt_with_current_key(encrypted_data, decrypted)
                    return decrypted
                except Exception:
                    pass
            
            raise ValueError("Unable to decrypt data with available keys")
    
    def _save_keys_to_storage(self):
        """保存密钥到安全存储"""
        # 实际实现中应该使用HSM或密钥管理服务
        pass
    
    def _re_encrypt_with_current_key(self, old_encrypted: str, decrypted: str):
        """使用当前密钥重新加密数据"""
        # 异步任务：使用新密钥重新加密历史数据
        pass

# 全局密钥管理器实例
key_manager = KeyRotationManager()
```

#### 5.1.2 API防护策略

```python
# security/api_protection.py
from fastapi import Request, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from starlette.middleware.base import BaseHTTPMiddleware
import time
import hashlib
from collections import defaultdict
from datetime import datetime, timedelta

class RateLimitMiddleware(BaseHTTPMiddleware):
    """API限流中间件"""
    
    def __init__(self, app, calls_per_minute: int = 60):
        super().__init__(app)
        self.calls_per_minute = calls_per_minute
        self.requests = defaultdict(list)
    
    async def dispatch(self, request: Request, call_next):
        client_ip = self._get_client_ip(request)
        current_time = time.time()
        
        # 清理过期记录
        self._cleanup_expired_requests(client_ip, current_time)
        
        # 检查限流
        if len(self.requests[client_ip]) >= self.calls_per_minute:
            raise HTTPException(
                status_code=429,
                detail="Rate limit exceeded. Please try again later."
            )
        
        # 记录请求
        self.requests[client_ip].append(current_time)
        
        response = await call_next(request)
        return response
    
    def _get_client_ip(self, request: Request) -> str:
        """获取客户端IP"""
        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return forwarded.split(",")[0].strip()
        return request.client.host
    
    def _cleanup_expired_requests(self, client_ip: str, current_time: float):
        """清理过期的请求记录"""
        minute_ago = current_time - 60
        self.requests[client_ip] = [
            req_time for req_time in self.requests[client_ip]
            if req_time > minute_ago
        ]

class APIKeyValidator:
    """API密钥验证器"""
    
    def __init__(self):
        self.valid_keys = set()  # 实际应从数据库加载
        self.key_usage = defaultdict(int)
        self.key_last_used = defaultdict(datetime)
    
    def validate_api_key(self, api_key: str) -> bool:
        """验证API密钥"""
        if not api_key or api_key not in self.valid_keys:
            return False
        
        # 记录使用情况
        self.key_usage[api_key] += 1
        self.key_last_used[api_key] = datetime.utcnow()
        
        return True
    
    def generate_api_key(self, user_id: int) -> str:
        """生成API密钥"""
        timestamp = str(int(time.time()))
        random_data = secrets.token_hex(16)
        raw_key = f"{user_id}:{timestamp}:{random_data}"
        
        api_key = hashlib.sha256(raw_key.encode()).hexdigest()
        self.valid_keys.add(api_key)
        
        return api_key
    
    def revoke_api_key(self, api_key: str):
        """撤销API密钥"""
        self.valid_keys.discard(api_key)
        self.key_usage.pop(api_key, None)
        self.key_last_used.pop(api_key, None)

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """安全头中间件"""
    
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        
        # 添加安全头
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
        
        return response
```

### 5.2 性能优化

#### 5.2.1 数据库连接池配置

```python
# database/connection_pool.py
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool
from config.settings import settings

class DatabaseConnectionPool:
    """数据库连接池管理器"""
    
    def __init__(self):
        self.engine = self._create_engine()
    
    def _create_engine(self):
        """创建数据库引擎"""
        return create_engine(
            settings.DATABASE_URL,
            poolclass=QueuePool,
            pool_size=20,  # 连接池大小
            max_overflow=30,  # 最大溢出连接数
            pool_pre_ping=True,  # 连接前检查
            pool_recycle=3600,  # 连接回收时间（秒）
            pool_timeout=30,  # 获取连接超时时间
            echo=settings.DEBUG,  # 是否打印SQL
            connect_args={
                "connect_timeout": 10,
                "application_name": "license_system"
            }
        )
    
    def get_connection(self):
        """获取数据库连接"""
        return self.engine.connect()
    
    def get_pool_status(self):
        """获取连接池状态"""
        pool = self.engine.pool
        return {
            "size": pool.size(),
            "checked_in": pool.checkedin(),
            "checked_out": pool.checkedout(),
            "overflow": pool.overflow(),
            "invalid": pool.invalid()
        }

# 全局连接池实例
db_pool = DatabaseConnectionPool()
```

#### 5.2.2 缓存优化策略

```python
# cache/cache_manager.py
import redis
import json
import pickle
from typing import Any, Optional
from datetime import timedelta
from config.settings import settings

class CacheManager:
    """缓存管理器"""
    
    def __init__(self):
        self.redis_client = redis.Redis(
            host=settings.REDIS_HOST,
            port=settings.REDIS_PORT,
            password=settings.REDIS_PASSWORD,
            db=0,
            decode_responses=False,
            socket_connect_timeout=5,
            socket_timeout=5,
            retry_on_timeout=True,
            health_check_interval=30
        )
        
        # 缓存键前缀
        self.KEY_PREFIXES = {
            "license": "license:",
            "user": "user:",
            "device": "device:",
            "application": "app:",
            "session": "session:"
        }
        
        # 默认过期时间
        self.DEFAULT_EXPIRY = {
            "license": timedelta(hours=1),
            "user": timedelta(minutes=30),
            "device": timedelta(hours=2),
            "application": timedelta(hours=6),
            "session": timedelta(hours=24)
        }
    
    def _build_key(self, category: str, identifier: str) -> str:
        """构建缓存键"""
        prefix = self.KEY_PREFIXES.get(category, "")
        return f"{prefix}{identifier}"
    
    def set(self, category: str, identifier: str, value: Any, 
            expiry: Optional[timedelta] = None) -> bool:
        """设置缓存"""
        try:
            key = self._build_key(category, identifier)
            serialized_value = pickle.dumps(value)
            
            if expiry is None:
                expiry = self.DEFAULT_EXPIRY.get(category, timedelta(hours=1))
            
            return self.redis_client.setex(
                key, 
                int(expiry.total_seconds()), 
                serialized_value
            )
        except Exception as e:
            logger.error(f"Cache set error: {e}")
            return False
    
    def get(self, category: str, identifier: str) -> Optional[Any]:
        """获取缓存"""
        try:
            key = self._build_key(category, identifier)
            cached_value = self.redis_client.get(key)
            
            if cached_value is None:
                return None
            
            return pickle.loads(cached_value)
        except Exception as e:
            logger.error(f"Cache get error: {e}")
            return None
    
    def delete(self, category: str, identifier: str) -> bool:
        """删除缓存"""
        try:
            key = self._build_key(category, identifier)
            return bool(self.redis_client.delete(key))
        except Exception as e:
            logger.error(f"Cache delete error: {e}")
            return False
    
    def invalidate_pattern(self, pattern: str) -> int:
        """批量删除匹配模式的缓存"""
        try:
            keys = self.redis_client.keys(pattern)
            if keys:
                return self.redis_client.delete(*keys)
            return 0
        except Exception as e:
            logger.error(f"Cache pattern invalidation error: {e}")
            return 0
    
    def get_cache_stats(self) -> dict:
        """获取缓存统计信息"""
        try:
            info = self.redis_client.info()
            return {
                "used_memory": info.get("used_memory_human"),
                "connected_clients": info.get("connected_clients"),
                "total_commands_processed": info.get("total_commands_processed"),
                "keyspace_hits": info.get("keyspace_hits"),
                "keyspace_misses": info.get("keyspace_misses"),
                "hit_rate": info.get("keyspace_hits", 0) / 
                           max(info.get("keyspace_hits", 0) + info.get("keyspace_misses", 0), 1)
            }
        except Exception as e:
            logger.error(f"Cache stats error: {e}")
            return {}

# 全局缓存管理器实例
cache_manager = CacheManager()
```

#### 5.2.3 查询性能优化

```python
# database/query_optimizer.py
from sqlalchemy import Index, text
from sqlalchemy.orm import sessionmaker
from models.license import License
from models.device import Device
from models.user import User

class QueryOptimizer:
    """查询优化器"""
    
    @staticmethod
    def create_indexes():
        """创建性能优化索引"""
        indexes = [
            # 卡密相关索引
            Index('idx_license_key_status', License.license_key, License.status),
            Index('idx_license_expires_at', License.expires_at),
            Index('idx_license_created_at', License.created_at),
            Index('idx_license_app_id', License.application_id),
            
            # 设备相关索引
            Index('idx_device_hardware_id', Device.hardware_id),
            Index('idx_device_license_id', Device.license_id),
            Index('idx_device_last_seen', Device.last_seen_at),
            
            # 用户相关索引
            Index('idx_user_username', User.username),
            Index('idx_user_email', User.email),
            Index('idx_user_created_at', User.created_at),
            
            # 复合索引
            Index('idx_license_app_status_expires', 
                  License.application_id, License.status, License.expires_at),
            Index('idx_device_license_status', 
                  Device.license_id, Device.status)
        ]
        
        return indexes
    
    @staticmethod
    def optimize_license_queries():
        """优化卡密查询"""
        # 使用原生SQL进行复杂查询优化
        optimized_queries = {
            "active_licenses_by_app": text("""
                SELECT l.*, u.username 
                FROM licenses l 
                JOIN users u ON l.user_id = u.id 
                WHERE l.application_id = :app_id 
                AND l.status = 'active' 
                AND l.expires_at > NOW() 
                ORDER BY l.created_at DESC 
                LIMIT :limit OFFSET :offset
            """),
            
            "license_usage_stats": text("""
                SELECT 
                    l.application_id,
                    COUNT(*) as total_licenses,
                    COUNT(CASE WHEN l.status = 'active' THEN 1 END) as active_licenses,
                    COUNT(CASE WHEN l.expires_at < NOW() THEN 1 END) as expired_licenses,
                    AVG(EXTRACT(EPOCH FROM (l.expires_at - l.created_at))/86400) as avg_duration_days
                FROM licenses l 
                GROUP BY l.application_id
            ""),
            
            "device_binding_summary": text("""
                SELECT 
                    d.license_id,
                    COUNT(*) as device_count,
                    MAX(d.last_seen_at) as last_activity,
                    STRING_AGG(d.hardware_id, ',') as device_ids
                FROM devices d 
                WHERE d.status = 'active' 
                GROUP BY d.license_id
                HAVING COUNT(*) > 0
            """)
        }
        
        return optimized_queries

# 查询优化器实例
query_optimizer = QueryOptimizer()
```

## 6. API接口规范

### 6.1 RESTful API设计

#### 6.1.1 接口命名规范

```python
# api/v1/routes.py
from fastapi import APIRouter, Depends, HTTPException, Query
from typing import List, Optional
from schemas.license import LicenseResponse, CreateLicenseRequest
from schemas.common import PaginationParams, ResponseModel

# API版本前缀
API_V1_PREFIX = "/api/v1"

# 路由定义
router = APIRouter(prefix=API_V1_PREFIX)

# 卡密管理接口
@router.post("/licenses", response_model=ResponseModel[LicenseResponse])
async def create_license(request: CreateLicenseRequest):
    """创建卡密"""
    pass

@router.get("/licenses", response_model=ResponseModel[List[LicenseResponse]])
async def list_licenses(
    pagination: PaginationParams = Depends(),
    app_id: Optional[int] = Query(None, description="应用ID筛选"),
    status: Optional[str] = Query(None, description="状态筛选")
):
    """获取卡密列表"""
    pass

@router.get("/licenses/{license_id}", response_model=ResponseModel[LicenseResponse])
async def get_license(license_id: int):
    """获取单个卡密详情"""
    pass

@router.put("/licenses/{license_id}", response_model=ResponseModel[LicenseResponse])
async def update_license(license_id: int, request: UpdateLicenseRequest):
    """更新卡密信息"""
    pass

@router.delete("/licenses/{license_id}", response_model=ResponseModel[dict])
async def delete_license(license_id: int):
    """删除卡密"""
    pass

# 卡密激活接口
@router.post("/licenses/activate", response_model=ResponseModel[dict])
async def activate_license(request: ActivateLicenseRequest):
    """激活卡密"""
    pass

@router.post("/licenses/verify", response_model=ResponseModel[dict])
async def verify_license(request: VerifyLicenseRequest):
    """验证卡密"""
    pass
```

#### 6.1.2 响应格式规范

```python
# schemas/common.py
from pydantic import BaseModel
from typing import Generic, TypeVar, Optional, List
from datetime import datetime

T = TypeVar('T')

class ResponseModel(BaseModel, Generic[T]):
    """统一响应格式"""
    success: bool = True
    message: str = "操作成功"
    data: Optional[T] = None
    error_code: Optional[str] = None
    timestamp: datetime = datetime.utcnow()
    request_id: Optional[str] = None

class PaginationParams(BaseModel):
    """分页参数"""
    page: int = 1
    page_size: int = 20
    
    @property
    def offset(self) -> int:
        return (self.page - 1) * self.page_size

class PaginationResponse(BaseModel, Generic[T]):
    """分页响应格式"""
    items: List[T]
    total: int
    page: int
    page_size: int
    total_pages: int
    
    @classmethod
    def create(cls, items: List[T], total: int, page: int, page_size: int):
        return cls(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=(total + page_size - 1) // page_size
        )

class ErrorResponse(BaseModel):
    """错误响应格式"""
    success: bool = False
    message: str
    error_code: str
    details: Optional[dict] = None
    timestamp: datetime = datetime.utcnow()
    request_id: Optional[str] = None
```

#### 6.1.3 错误码规范

```python
# constants/error_codes.py
class ErrorCodes:
    """错误码定义"""
    
    # 通用错误 (1000-1999)
    INVALID_REQUEST = "1001"
    UNAUTHORIZED = "1002"
    FORBIDDEN = "1003"
    NOT_FOUND = "1004"
    METHOD_NOT_ALLOWED = "1005"
    RATE_LIMIT_EXCEEDED = "1006"
    INTERNAL_SERVER_ERROR = "1007"
    
    # 认证相关错误 (2000-2999)
    INVALID_CREDENTIALS = "2001"
    TOKEN_EXPIRED = "2002"
    TOKEN_INVALID = "2003"
    ACCOUNT_LOCKED = "2004"
    PASSWORD_EXPIRED = "2005"
    
    # 卡密相关错误 (3000-3999)
    LICENSE_NOT_FOUND = "3001"
    LICENSE_EXPIRED = "3002"
    LICENSE_ALREADY_ACTIVATED = "3003"
    LICENSE_INVALID = "3004"
    LICENSE_QUOTA_EXCEEDED = "3005"
    
    # 设备相关错误 (4000-4999)
    DEVICE_NOT_FOUND = "4001"
    DEVICE_ALREADY_BOUND = "4002"
    DEVICE_LIMIT_EXCEEDED = "4003"
    DEVICE_UNAUTHORIZED = "4004"
    
    # 应用相关错误 (5000-5999)
    APPLICATION_NOT_FOUND = "5001"
    APPLICATION_INACTIVE = "5002"
    APPLICATION_MAINTENANCE = "5003"
    
class ErrorMessages:
    """错误消息定义"""
    
    ERROR_MESSAGES = {
        ErrorCodes.INVALID_REQUEST: "请求参数无效",
        ErrorCodes.UNAUTHORIZED: "未授权访问",
        ErrorCodes.FORBIDDEN: "禁止访问",
        ErrorCodes.NOT_FOUND: "资源不存在",
        ErrorCodes.RATE_LIMIT_EXCEEDED: "请求频率超限",
        
        ErrorCodes.INVALID_CREDENTIALS: "用户名或密码错误",
        ErrorCodes.TOKEN_EXPIRED: "访问令牌已过期",
        ErrorCodes.TOKEN_INVALID: "访问令牌无效",
        
        ErrorCodes.LICENSE_NOT_FOUND: "卡密不存在",
        ErrorCodes.LICENSE_EXPIRED: "卡密已过期",
        ErrorCodes.LICENSE_ALREADY_ACTIVATED: "卡密已被激活",
        ErrorCodes.LICENSE_INVALID: "卡密无效",
        
        ErrorCodes.DEVICE_NOT_FOUND: "设备不存在",
        ErrorCodes.DEVICE_ALREADY_BOUND: "设备已绑定",
        ErrorCodes.DEVICE_LIMIT_EXCEEDED: "设备绑定数量超限",
        
        ErrorCodes.APPLICATION_NOT_FOUND: "应用不存在",
        ErrorCodes.APPLICATION_INACTIVE: "应用未激活",
        ErrorCodes.APPLICATION_MAINTENANCE: "应用维护中"
    }
    
    @classmethod
    def get_message(cls, error_code: str) -> str:
        return cls.ERROR_MESSAGES.get(error_code, "未知错误")
```

## 7. 前端实现指南

### 7.1 项目结构

```
frontend/
├── src/
│   ├── components/          # 通用组件
│   │   ├── common/         # 基础组件
│   │   ├── forms/          # 表单组件
│   │   └── layout/         # 布局组件
│   ├── pages/              # 页面组件
│   │   ├── auth/           # 认证页面
│   │   ├── dashboard/      # 仪表板
│   │   ├── licenses/       # 卡密管理
│   │   ├── applications/   # 应用管理
│   │   └── settings/       # 系统设置
│   ├── hooks/              # 自定义Hooks
│   ├── services/           # API服务
│   ├── store/              # 状态管理
│   ├── types/              # TypeScript类型定义
│   ├── utils/              # 工具函数
│   └── styles/             # 样式文件
├── public/                 # 静态资源
└── package.json           # 依赖配置
```

### 7.2 TypeScript类型定义

```typescript
// types/api.ts
export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  error_code?: string;
  timestamp: string;
  request_id?: string;
}

export interface PaginationParams {
  page: number;
  page_size: number;
}

export interface PaginationResponse<T> {
  items: T[];
  total: number;
  page: number;
  page_size: number;
  total_pages: number;
}

// types/license.ts
export interface License {
  id: number;
  license_key: string;
  application_id: number;
  application_name?: string;
  user_id?: number;
  username?: string;
  status: 'active' | 'expired' | 'suspended' | 'pending';
  expires_at: string;
  created_at: string;
  updated_at: string;
  device_limit: number;
  bound_devices: number;
  metadata?: Record<string, any>;
}

export interface CreateLicenseRequest {
  application_id: number;
  duration_days: number;
  device_limit: number;
  user_id?: number;
  metadata?: Record<string, any>;
}

export interface ActivateLicenseRequest {
  license_key: string;
  device_id: string;
  device_info?: Record<string, any>;
}

// types/application.ts
export interface Application {
  id: number;
  name: string;
  description?: string;
  status: 'active' | 'inactive' | 'maintenance';
  version: string;
  api_key: string;
  settings: ApplicationSettings;
  created_at: string;
  updated_at: string;
}

export interface ApplicationSettings {
  max_devices_per_license: number;
  allow_device_transfer: boolean;
  require_device_verification: boolean;
  auto_extend_licenses: boolean;
  notification_settings: {
    email_notifications: boolean;
    webhook_url?: string;
  };
}

// types/user.ts
export interface User {
  id: number;
  username: string;
  email: string;
  role: 'admin' | 'user';
  is_active: boolean;
  created_at: string;
  last_login?: string;
}

export interface LoginRequest {
  username: string;
  password: string;
}

export interface AuthResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  user: User;
}
```

### 7.3 API服务层

```typescript
// services/api.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { ApiResponse } from '../types/api';

class ApiService {
  private client: AxiosInstance;
  
  constructor() {
    this.client = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // 请求拦截器
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('access_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // 响应拦截器
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          localStorage.removeItem('access_token');
          window.location.href = '/auth/login';
        }
        return Promise.reject(error);
      }
    );
  }
  
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.get(url, config);
    return response.data;
  }
  
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.post(url, data, config);
    return response.data;
  }
  
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.put(url, data, config);
    return response.data;
  }
  
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.delete(url, config);
    return response.data;
  }
}

export const apiService = new ApiService();

// services/licenseService.ts
import { apiService } from './api';
import { License, CreateLicenseRequest, ActivateLicenseRequest } from '../types/license';
import { PaginationParams, PaginationResponse } from '../types/api';

export class LicenseService {
  static async getLicenses(params: PaginationParams & {
    app_id?: number;
    status?: string;
  }) {
    return apiService.get<PaginationResponse<License>>('/api/v1/licenses', {
      params
    });
  }
  
  static async getLicense(id: number) {
    return apiService.get<License>(`/api/v1/licenses/${id}`);
  }
  
  static async createLicense(data: CreateLicenseRequest) {
    return apiService.post<License>('/api/v1/licenses', data);
  }
  
  static async updateLicense(id: number, data: Partial<License>) {
    return apiService.put<License>(`/api/v1/licenses/${id}`, data);
  }
  
  static async deleteLicense(id: number) {
    return apiService.delete(`/api/v1/licenses/${id}`);
  }
  
  static async activateLicense(data: ActivateLicenseRequest) {
    return apiService.post('/api/v1/licenses/activate', data);
  }
  
  static async verifyLicense(licenseKey: string, deviceId: string) {
    return apiService.post('/api/v1/licenses/verify', {
      license_key: licenseKey,
      device_id: deviceId
    });
  }
}

// services/authService.ts
import { apiService } from './api';
import { LoginRequest, AuthResponse, User } from '../types/user';

export class AuthService {
  static async login(credentials: LoginRequest): Promise<AuthResponse> {
    const response = await apiService.post<AuthResponse>('/api/v1/auth/login', credentials);
    
    if (response.success && response.data) {
      localStorage.setItem('access_token', response.data.access_token);
      localStorage.setItem('user', JSON.stringify(response.data.user));
    }
    
    return response.data!;
  }
  
  static async logout() {
    try {
      await apiService.post('/api/v1/auth/logout');
    } finally {
      localStorage.removeItem('access_token');
      localStorage.removeItem('user');
    }
  }
  
  static async getCurrentUser(): Promise<User | null> {
    try {
      const response = await apiService.get<User>('/api/v1/auth/me');
      return response.data || null;
    } catch {
      return null;
    }
  }
  
  static getStoredUser(): User | null {
    const userStr = localStorage.getItem('user');
    return userStr ? JSON.parse(userStr) : null;
  }
  
  static isAuthenticated(): boolean {
    return !!localStorage.getItem('access_token');
  }
}
```

### 7.4 状态管理

```typescript
// store/authStore.ts
import { create } from 'zustand';
import { User } from '../types/user';
import { AuthService } from '../services/authService';

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
  setUser: (user: User | null) => void;
}

export const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  
  login: async (username: string, password: string) => {
    try {
      const authResponse = await AuthService.login({ username, password });
      set({ 
        user: authResponse.user, 
        isAuthenticated: true,
        isLoading: false 
      });
    } catch (error) {
      set({ user: null, isAuthenticated: false, isLoading: false });
      throw error;
    }
  },
  
  logout: async () => {
    try {
      await AuthService.logout();
    } finally {
      set({ user: null, isAuthenticated: false, isLoading: false });
    }
  },
  
  checkAuth: async () => {
    set({ isLoading: true });
    
    if (!AuthService.isAuthenticated()) {
      set({ user: null, isAuthenticated: false, isLoading: false });
      return;
    }
    
    try {
      const user = await AuthService.getCurrentUser();
      if (user) {
        set({ user, isAuthenticated: true, isLoading: false });
      } else {
        set({ user: null, isAuthenticated: false, isLoading: false });
      }
    } catch {
      set({ user: null, isAuthenticated: false, isLoading: false });
    }
  },
  
  setUser: (user: User | null) => {
    set({ user, isAuthenticated: !!user });
  }
}));

// store/licenseStore.ts
import { create } from 'zustand';
import { License } from '../types/license';
import { LicenseService } from '../services/licenseService';
import { PaginationParams } from '../types/api';

interface LicenseState {
  licenses: License[];
  currentLicense: License | null;
  total: number;
  isLoading: boolean;
  error: string | null;
  
  fetchLicenses: (params: PaginationParams & { app_id?: number; status?: string }) => Promise<void>;
  fetchLicense: (id: number) => Promise<void>;
  createLicense: (data: any) => Promise<void>;
  updateLicense: (id: number, data: any) => Promise<void>;
  deleteLicense: (id: number) => Promise<void>;
  clearError: () => void;
}

export const useLicenseStore = create<LicenseState>((set, get) => ({
  licenses: [],
  currentLicense: null,
  total: 0,
  isLoading: false,
  error: null,
  
  fetchLicenses: async (params) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.getLicenses(params);
      if (response.success && response.data) {
        set({ 
          licenses: response.data.items, 
          total: response.data.total,
          isLoading: false 
        });
      }
    } catch (error: any) {
      set({ 
        error: error.message || '获取卡密列表失败', 
        isLoading: false 
      });
    }
  },
  
  fetchLicense: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.getLicense(id);
      if (response.success && response.data) {
        set({ currentLicense: response.data, isLoading: false });
      }
    } catch (error: any) {
      set({ 
        error: error.message || '获取卡密详情失败', 
        isLoading: false 
      });
    }
  },
  
  createLicense: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.createLicense(data);
      if (response.success && response.data) {
        const { licenses } = get();
        set({ 
          licenses: [response.data, ...licenses],
          isLoading: false 
        });
      }
    } catch (error: any) {
      set({ 
        error: error.message || '创建卡密失败', 
        isLoading: false 
      });
      throw error;
    }
  },
  
  updateLicense: async (id, data) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.updateLicense(id, data);
      if (response.success && response.data) {
        const { licenses } = get();
        const updatedLicenses = licenses.map(license => 
          license.id === id ? response.data! : license
        );
        set({ 
          licenses: updatedLicenses,
          currentLicense: response.data,
          isLoading: false 
        });
      }
    } catch (error: any) {
      set({ 
        error: error.message || '更新卡密失败', 
        isLoading: false 
      });
      throw error;
    }
  },
  
  deleteLicense: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await LicenseService.deleteLicense(id);
      const { licenses } = get();
      const filteredLicenses = licenses.filter(license => license.id !== id);
      set({ 
        licenses: filteredLicenses,
        isLoading: false 
      });
    } catch (error: any) {
      set({ 
        error: error.message || '删除卡密失败', 
        isLoading: false 
      });
      throw error;
    }
  },
  
  clearError: () => set({ error: null })
}));
```

### 7.5 核心组件实现

#### 7.5.1 登录组件

```tsx
// components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useRouter } from 'next/router';
import { useAuthStore } from '../../store/authStore';
import { Button } from '../common/Button';
import { Input } from '../common/Input';
import { Card } from '../common/Card';

export const LoginForm: React.FC = () => {
  const [credentials, setCredentials] = useState({
    username: '',
    password: ''
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  
  const { login } = useAuthStore();
  const router = useRouter();
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');
    
    try {
      await login(credentials.username, credentials.password);
      router.push('/dashboard');
    } catch (err: any) {
      setError(err.message || '登录失败，请检查用户名和密码');
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleInputChange = (field: string) => (value: string) => {
    setCredentials(prev => ({ ...prev, [field]: value }));
  };
  
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md p-8">
        <div className="text-center mb-8">
          <h1 className="text-2xl font-bold text-gray-900">金鱼智盒授权系统</h1>
          <p className="text-gray-600 mt-2">请登录您的管理账户</p>
        </div>
        
        <form onSubmit={handleSubmit} className="space-y-6">
          <Input
            label="用户名"
            type="text"
            value={credentials.username}
            onChange={handleInputChange('username')}
            placeholder="请输入用户名"
            required
          />
          
          <Input
            label="密码"
            type="password"
            value={credentials.password}
            onChange={handleInputChange('password')}
            placeholder="请输入密码"
            required
          />
          
          {error && (
            <div className="text-red-600 text-sm text-center">
              {error}
            </div>
          )}
          
          <Button
            type="submit"
            variant="primary"
            size="large"
            className="w-full"
            loading={isLoading}
          >
            登录
          </Button>
        </form>
        
        <div className="mt-6 text-center text-sm text-gray-500">
          <p>默认管理员账户：admin / admin1314159</p>
        </div>
      </Card>
    </div>
   );
 };
 ```

## 8. 后端实现指南

### 8.1 项目结构

```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI应用入口
│   ├── config.py              # 配置管理
│   ├── database.py            # 数据库连接
│   ├── dependencies.py        # 依赖注入
│   ├── middleware/            # 中间件
│   │   ├── __init__.py
│   │   ├── auth.py           # 认证中间件
│   │   ├── cors.py           # CORS中间件
│   │   └── rate_limit.py     # 限流中间件
│   ├── models/               # 数据模型
│   │   ├── __init__.py
│   │   ├── base.py          # 基础模型
│   │   ├── user.py          # 用户模型
│   │   ├── application.py   # 应用模型
│   │   ├── license.py       # 卡密模型
│   │   ├── device.py        # 设备模型
│   │   └── announcement.py  # 公告模型
│   ├── schemas/             # Pydantic模式
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── application.py
│   │   ├── license.py
│   │   ├── device.py
│   │   └── announcement.py
│   ├── api/                 # API路由
│   │   ├── __init__.py
│   │   ├── v1/
│   │   │   ├── __init__.py
│   │   │   ├── auth.py
│   │   │   ├── users.py
│   │   │   ├── applications.py
│   │   │   ├── licenses.py
│   │   │   ├── devices.py
│   │   │   └── announcements.py
│   ├── services/            # 业务逻辑
│   │   ├── __init__.py
│   │   ├── auth_service.py
│   │   ├── license_service.py
│   │   ├── device_service.py
│   │   ├── notification_service.py
│   │   └── announcement_service.py
│   ├── utils/               # 工具函数
│   │   ├── __init__.py
│   │   ├── security.py      # 安全工具
│   │   ├── crypto.py        # 加密工具
│   │   ├── validators.py    # 验证器
│   │   └── helpers.py       # 辅助函数
│   └── core/               # 核心模块
│       ├── __init__.py
│       ├── events.py       # 事件系统
│       ├── cache.py        # 缓存管理
│       ├── logging.py      # 日志配置
│       └── exceptions.py   # 异常处理
├── tests/                  # 测试文件
├── alembic/               # 数据库迁移
├── requirements.txt       # 依赖包
├── .env.example          # 环境变量示例
└── docker-compose.yml    # Docker配置
```

### 8.2 核心模型定义

```python
# models/base.py
from sqlalchemy import Column, Integer, DateTime, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session

Base = declarative_base()

class BaseModel(Base):
    __abstract__ = True
    
    id = Column(Integer, primary_key=True, index=True)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    def to_dict(self):
        """转换为字典"""
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }
    
    @classmethod
    def create(cls, db: Session, **kwargs):
        """创建实例"""
        instance = cls(**kwargs)
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance
    
    def update(self, db: Session, **kwargs):
        """更新实例"""
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
        db.commit()
        db.refresh(self)
        return self
    
    def delete(self, db: Session):
        """删除实例"""
        db.delete(self)
        db.commit()

# models/license.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, Text
from sqlalchemy.orm import relationship
from .base import BaseModel

class License(BaseModel):
    __tablename__ = "licenses"
    
    license_key = Column(String(64), unique=True, index=True, nullable=False)
    application_id = Column(Integer, ForeignKey("applications.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    device_limit = Column(Integer, default=1, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    status = Column(String(20), default="pending", nullable=False)  # pending, active, expired, suspended
    activation_data = Column(Text, nullable=True)  # JSON格式的激活数据
    
    # 关联关系
    application = relationship("Application", back_populates="licenses")
    user = relationship("User", back_populates="licenses")
    devices = relationship("Device", back_populates="license")
    
    @property
    def bound_devices(self):
        """已绑定设备数量"""
        return len([d for d in self.devices if d.is_active])
    
    @property
    def is_expired(self):
        """是否已过期"""
        from datetime import datetime
        return datetime.utcnow() > self.expires_at
    
    @property
    def can_bind_device(self):
        """是否可以绑定新设备"""
        return self.bound_devices < self.device_limit and not self.is_expired

# models/device.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, Text
from sqlalchemy.orm import relationship
from .base import BaseModel

class Device(BaseModel):
    __tablename__ = "devices"
    
    hardware_id = Column(String(128), index=True, nullable=False)
    license_id = Column(Integer, ForeignKey("licenses.id"), nullable=False)
    device_name = Column(String(100), nullable=True)
    device_info = Column(Text, nullable=True)  # JSON格式的设备信息
    last_seen = Column(DateTime, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    
    # 关联关系
    license = relationship("License", back_populates="devices")
    
    @property
    def is_online(self):
        """设备是否在线"""
        from datetime import datetime, timedelta
        if not self.last_seen:
            return False
        return datetime.utcnow() - self.last_seen < timedelta(minutes=5)
```

### 8.3 业务服务层

```python
# services/license_service.py
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
from datetime import datetime, timedelta
import secrets
import string

from ..models.license import License
from ..models.device import Device
from ..models.application import Application
from ..core.events import EventBus
from ..core.cache import CacheManager
from ..utils.crypto import encrypt_data, decrypt_data
from ..core.exceptions import BusinessException

class LicenseService:
    def __init__(self, db: Session, event_bus: EventBus, cache: CacheManager):
        self.db = db
        self.event_bus = event_bus
        self.cache = cache
    
    def generate_license_key(self, length: int = 32) -> str:
        """生成卡密"""
        alphabet = string.ascii_uppercase + string.digits
        # 排除容易混淆的字符
        alphabet = alphabet.replace('0', '').replace('O', '').replace('I', '').replace('1')
        
        while True:
            key = ''.join(secrets.choice(alphabet) for _ in range(length))
            # 添加分隔符提高可读性
            formatted_key = '-'.join([key[i:i+4] for i in range(0, len(key), 4)])
            
            # 检查是否已存在
            if not self.db.query(License).filter(License.license_key == formatted_key).first():
                return formatted_key
    
    def create_license(self, application_id: int, duration_days: int, 
                      device_limit: int = 1, user_id: Optional[int] = None) -> License:
        """创建卡密"""
        # 验证应用是否存在
        application = self.db.query(Application).filter(Application.id == application_id).first()
        if not application:
            raise BusinessException("应用不存在")
        
        # 生成卡密和过期时间
        license_key = self.generate_license_key()
        expires_at = datetime.utcnow() + timedelta(days=duration_days)
        
        # 创建卡密记录
        license = License.create(
            self.db,
            license_key=license_key,
            application_id=application_id,
            user_id=user_id,
            device_limit=device_limit,
            expires_at=expires_at,
            status="pending"
        )
        
        # 清除相关缓存
        self.cache.delete_pattern(f"license:*")
        
        return license
    
    def activate_license(self, license_key: str, device_id: str, 
                        device_info: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """激活卡密"""
        # 查找卡密
        license = self.db.query(License).filter(License.license_key == license_key).first()
        if not license:
            raise BusinessException("卡密不存在")
        
        # 检查卡密状态
        if license.status == "expired":
            raise BusinessException("卡密已过期")
        elif license.status == "suspended":
            raise BusinessException("卡密已被暂停")
        elif license.is_expired:
            license.status = "expired"
            self.db.commit()
            raise BusinessException("卡密已过期")
        
        # 检查设备是否已绑定
        existing_device = self.db.query(Device).filter(
            and_(Device.hardware_id == device_id, Device.license_id == license.id)
        ).first()
        
        if existing_device:
            if existing_device.is_active:
                # 更新最后见到时间
                existing_device.last_seen = datetime.utcnow()
                self.db.commit()
                
                return {
                    "success": True,
                    "message": "设备已激活",
                    "license_info": {
                        "expires_at": license.expires_at.isoformat(),
                        "device_limit": license.device_limit,
                        "bound_devices": license.bound_devices
                    }
                }
            else:
                raise BusinessException("设备已被禁用")
        
        # 检查设备绑定限制
        if not license.can_bind_device:
            raise BusinessException(f"设备绑定数量已达上限({license.device_limit})")
        
        # 创建设备绑定记录
        device = Device.create(
            self.db,
            hardware_id=device_id,
            license_id=license.id,
            device_info=encrypt_data(device_info) if device_info else None,
            last_seen=datetime.utcnow(),
            is_active=True
        )
        
        # 更新卡密状态
        if license.status == "pending":
            license.status = "active"
            self.db.commit()
        
        # 发布事件
        self.event_bus.publish("license.activated", {
            "license_id": license.id,
            "license_key": license.license_key,
            "device_id": device_id,
            "application_id": license.application_id
        })
        
        # 清除缓存
        self.cache.delete(f"license:{license_key}")
        
        return {
            "success": True,
            "message": "激活成功",
            "license_info": {
                "expires_at": license.expires_at.isoformat(),
                "device_limit": license.device_limit,
                "bound_devices": license.bound_devices
            }
        }
    
    def verify_license(self, license_key: str, device_id: str) -> Dict[str, Any]:
        """验证卡密"""
        # 尝试从缓存获取
        cache_key = f"license:{license_key}:{device_id}"
        cached_result = self.cache.get(cache_key)
        if cached_result:
            return cached_result
        
        # 查找卡密和设备
        license = self.db.query(License).filter(License.license_key == license_key).first()
        if not license:
            result = {"valid": False, "reason": "卡密不存在"}
            self.cache.set(cache_key, result, 300)  # 缓存5分钟
            return result
        
        device = self.db.query(Device).filter(
            and_(Device.hardware_id == device_id, Device.license_id == license.id)
        ).first()
        
        if not device or not device.is_active:
            result = {"valid": False, "reason": "设备未绑定或已禁用"}
            self.cache.set(cache_key, result, 300)
            return result
        
        # 检查卡密状态和过期时间
        if license.status != "active" or license.is_expired:
            result = {"valid": False, "reason": "卡密已过期或被暂停"}
            self.cache.set(cache_key, result, 300)
            return result
        
        # 更新设备最后见到时间
        device.last_seen = datetime.utcnow()
        self.db.commit()
        
        result = {
            "valid": True,
            "license_info": {
                "expires_at": license.expires_at.isoformat(),
                "application_id": license.application_id,
                "device_limit": license.device_limit,
                "bound_devices": license.bound_devices
            }
        }
        
        # 缓存验证结果（较短时间）
        self.cache.set(cache_key, result, 60)  # 缓存1分钟
        
        return result
    
    def get_license_statistics(self, application_id: Optional[int] = None) -> Dict[str, Any]:
        """获取卡密统计信息"""
        query = self.db.query(License)
        if application_id:
            query = query.filter(License.application_id == application_id)
        
        total = query.count()
        active = query.filter(License.status == "active").count()
        expired = query.filter(License.status == "expired").count()
        pending = query.filter(License.status == "pending").count()
        suspended = query.filter(License.status == "suspended").count()
        
        return {
            "total": total,
            "active": active,
            "expired": expired,
            "pending": pending,
            "suspended": suspended,
            "usage_rate": round((active / total * 100) if total > 0 else 0, 2)
        }
```

### 8.4 API路由实现

```python
# api/v1/licenses.py
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from ...database import get_db
from ...dependencies import get_current_user, get_license_service
from ...schemas.license import (
    LicenseCreate, LicenseUpdate, LicenseResponse, 
    LicenseActivate, LicenseVerify, LicenseList
)
from ...schemas.common import PaginationParams, ResponseModel
from ...models.user import User
from ...services.license_service import LicenseService
from ...core.exceptions import BusinessException

router = APIRouter(prefix="/licenses", tags=["licenses"])

@router.post("/", response_model=ResponseModel[LicenseResponse])
async def create_license(
    license_data: LicenseCreate,
    current_user: User = Depends(get_current_user),
    license_service: LicenseService = Depends(get_license_service)
):
    """创建卡密"""
    try:
        license = license_service.create_license(
            application_id=license_data.application_id,
            duration_days=license_data.duration_days,
            device_limit=license_data.device_limit,
            user_id=license_data.user_id
        )
        
        return ResponseModel(
            success=True,
            message="卡密创建成功",
            data=LicenseResponse.from_orm(license)
        )
    except BusinessException as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="创建卡密失败")

@router.get("/", response_model=ResponseModel[LicenseList])
async def get_licenses(
    pagination: PaginationParams = Depends(),
    application_id: Optional[int] = Query(None, description="应用ID"),
    status: Optional[str] = Query(None, description="状态筛选"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """获取卡密列表"""
    query = db.query(License)
    
    # 应用筛选
    if application_id:
        query = query.filter(License.application_id == application_id)
    
    # 状态筛选
    if status:
        query = query.filter(License.status == status)
    
    # 分页
    total = query.count()
    licenses = query.offset(
        (pagination.page - 1) * pagination.page_size
    ).limit(pagination.page_size).all()
    
    return ResponseModel(
        success=True,
        data=LicenseList(
            items=[LicenseResponse.from_orm(license) for license in licenses],
            total=total,
            page=pagination.page,
            page_size=pagination.page_size
        )
    )

@router.post("/activate", response_model=ResponseModel[dict])
async def activate_license(
    activation_data: LicenseActivate,
    license_service: LicenseService = Depends(get_license_service)
):
    """激活卡密"""
    try:
        result = license_service.activate_license(
            license_key=activation_data.license_key,
            device_id=activation_data.device_id,
            device_info=activation_data.device_info
        )
        
        return ResponseModel(
            success=True,
            message=result["message"],
            data=result
        )
    except BusinessException as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="激活失败")

@router.post("/verify", response_model=ResponseModel[dict])
async def verify_license(
    verify_data: LicenseVerify,
    license_service: LicenseService = Depends(get_license_service)
):
    """验证卡密"""
    try:
        result = license_service.verify_license(
            license_key=verify_data.license_key,
            device_id=verify_data.device_id
        )
        
        return ResponseModel(
            success=True,
            data=result
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail="验证失败")

@router.get("/statistics", response_model=ResponseModel[dict])
async def get_license_statistics(
    application_id: Optional[int] = Query(None, description="应用ID"),
    current_user: User = Depends(get_current_user),
    license_service: LicenseService = Depends(get_license_service)
):
    """获取卡密统计信息"""
    try:
        stats = license_service.get_license_statistics(application_id)
        
        return ResponseModel(
            success=True,
            data=stats
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail="获取统计信息失败")
```

## 9. 部署与运维

### 9.1 环境配置

#### 9.1.1 环境变量配置

```bash
# .env
# 数据库配置
DATABASE_URL=postgresql://username:password@localhost:5432/license_system
REDIS_URL=redis://localhost:6379/0

# 应用配置
APP_NAME=金鱼智盒卡密授权系统
APP_VERSION=1.0.0
DEBUG=false
SECRET_KEY=your-super-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# 服务端口
BACKEND_PORT=8000
FRONTEND_PORT=3000

# 安全配置
ENCRYPTION_KEY=your-encryption-key-here
API_KEY_SECRET=your-api-key-secret
RATE_LIMIT_PER_MINUTE=60

# 邮件配置（可选）
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-password

# 日志配置
LOG_LEVEL=INFO
LOG_FILE_PATH=./logs/app.log
LOG_MAX_SIZE=10MB
LOG_BACKUP_COUNT=5

# 缓存配置
CACHE_DEFAULT_TIMEOUT=300
CACHE_KEY_PREFIX=license_system:

# 数据库连接池配置
DB_POOL_SIZE=20
DB_MAX_OVERFLOW=30
DB_POOL_RECYCLE=3600
```

#### 9.1.2 Docker配置

```dockerfile
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements.txt .

# 安装Python依赖
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

# frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建应用
RUN npm run build

# 生产镜像
FROM node:18-alpine AS runner

WORKDIR /app

# 创建非root用户
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# 复制构建产物
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

# 设置权限
USER nextjs

# 暴露端口
EXPOSE 3000

# 启动命令
CMD ["node", "server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  # 数据库
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: license_system
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres123
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redis缓存
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 后端服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://postgres:postgres123@postgres:5432/license_system
      - REDIS_URL=redis://redis:6379/0
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # 前端服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:3000
    ports:
      - "3000:3000"
    depends_on:
      - backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### 9.2 监控与日志

#### 9.2.1 应用监控

```python
# core/monitoring.py
import time
import psutil
from typing import Dict, Any
from fastapi import Request
from prometheus_client import Counter, Histogram, Gauge, generate_latest

# Prometheus指标
REQUEST_COUNT = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

REQUEST_DURATION = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint']
)

ACTIVE_LICENSES = Gauge(
    'active_licenses_total',
    'Total active licenses'
)

SYSTEM_CPU_USAGE = Gauge(
    'system_cpu_usage_percent',
    'System CPU usage percentage'
)

SYSTEM_MEMORY_USAGE = Gauge(
    'system_memory_usage_percent',
    'System memory usage percentage'
)

class MonitoringService:
    def __init__(self):
        self.start_time = time.time()
    
    async def record_request(self, request: Request, response_time: float, status_code: int):
        """记录请求指标"""
        method = request.method
        endpoint = request.url.path
        
        REQUEST_COUNT.labels(
            method=method,
            endpoint=endpoint,
            status=status_code
        ).inc()
        
        REQUEST_DURATION.labels(
            method=method,
            endpoint=endpoint
        ).observe(response_time)
    
    def update_system_metrics(self):
        """更新系统指标"""
        # CPU使用率
        cpu_percent = psutil.cpu_percent(interval=1)
        SYSTEM_CPU_USAGE.set(cpu_percent)
        
        # 内存使用率
        memory = psutil.virtual_memory()
        SYSTEM_MEMORY_USAGE.set(memory.percent)
    
    def update_business_metrics(self, db_session):
        """更新业务指标"""
        from ..models.license import License
        
        # 活跃卡密数量
        active_count = db_session.query(License).filter(
            License.status == 'active'
        ).count()
        ACTIVE_LICENSES.set(active_count)
    
    def get_health_status(self) -> Dict[str, Any]:
        """获取健康状态"""
        uptime = time.time() - self.start_time
        
        return {
            "status": "healthy",
            "uptime_seconds": uptime,
            "timestamp": time.time(),
            "version": "1.0.0"
        }
    
    def get_metrics(self) -> str:
        """获取Prometheus格式的指标"""
        return generate_latest()

# 中间件
async def monitoring_middleware(request: Request, call_next):
    """监控中间件"""
    start_time = time.time()
    
    response = await call_next(request)
    
    process_time = time.time() - start_time
    
    # 记录请求指标
    monitoring_service = request.app.state.monitoring_service
    await monitoring_service.record_request(
        request, process_time, response.status_code
    )
    
    return response
```

#### 9.2.2 日志配置

```python
# core/logging.py
import logging
import logging.handlers
import json
from datetime import datetime
from typing import Dict, Any
from pathlib import Path

class JSONFormatter(logging.Formatter):
    """JSON格式日志格式化器"""
    
    def format(self, record: logging.LogRecord) -> str:
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        # 添加异常信息
        if record.exc_info:
            log_entry["exception"] = self.formatException(record.exc_info)
        
        # 添加额外字段
        if hasattr(record, 'user_id'):
            log_entry["user_id"] = record.user_id
        if hasattr(record, 'request_id'):
            log_entry["request_id"] = record.request_id
        if hasattr(record, 'ip_address'):
            log_entry["ip_address"] = record.ip_address
        
        return json.dumps(log_entry, ensure_ascii=False)

def setup_logging(log_level: str = "INFO", log_file: str = "./logs/app.log"):
    """配置日志系统"""
    # 创建日志目录
    log_path = Path(log_file)
    log_path.parent.mkdir(parents=True, exist_ok=True)
    
    # 根日志器配置
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level.upper()))
    
    # 清除现有处理器
    root_logger.handlers.clear()
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(console_formatter)
    root_logger.addHandler(console_handler)
    
    # 文件处理器（轮转）
    file_handler = logging.handlers.RotatingFileHandler(
        log_file,
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(JSONFormatter())
    root_logger.addHandler(file_handler)
    
    # 错误日志处理器
    error_handler = logging.handlers.RotatingFileHandler(
        log_file.replace('.log', '_error.log'),
        maxBytes=10*1024*1024,
        backupCount=5,
        encoding='utf-8'
    )
    error_handler.setLevel(logging.ERROR)
    error_handler.setFormatter(JSONFormatter())
    root_logger.addHandler(error_handler)
    
    # 设置第三方库日志级别
    logging.getLogger('uvicorn').setLevel(logging.INFO)
    logging.getLogger('sqlalchemy.engine').setLevel(logging.WARNING)
    logging.getLogger('redis').setLevel(logging.WARNING)

class StructuredLogger:
    """结构化日志器"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
    
    def info(self, message: str, **kwargs):
        """记录信息日志"""
        extra = self._build_extra(**kwargs)
        self.logger.info(message, extra=extra)
    
    def warning(self, message: str, **kwargs):
        """记录警告日志"""
        extra = self._build_extra(**kwargs)
        self.logger.warning(message, extra=extra)
    
    def error(self, message: str, **kwargs):
        """记录错误日志"""
        extra = self._build_extra(**kwargs)
        self.logger.error(message, extra=extra)
    
    def debug(self, message: str, **kwargs):
        """记录调试日志"""
        extra = self._build_extra(**kwargs)
        self.logger.debug(message, extra=extra)
    
    def _build_extra(self, **kwargs) -> Dict[str, Any]:
        """构建额外字段"""
        return {k: v for k, v in kwargs.items() if v is not None}

# 业务日志记录器
audit_logger = StructuredLogger('audit')
security_logger = StructuredLogger('security')
performance_logger = StructuredLogger('performance')
```

### 9.3 部署脚本

```bash
#!/bin/bash
# deploy.sh - 部署脚本

set -e

echo "开始部署金鱼智盒卡密授权系统..."

# 检查Docker和Docker Compose
if ! command -v docker &> /dev/null; then
    echo "错误: Docker未安装"
    exit 1
fi

if ! command -v docker-compose &> /dev/null; then
    echo "错误: Docker Compose未安装"
    exit 1
fi

# 创建必要目录
mkdir -p logs ssl

# 检查环境变量文件
if [ ! -f .env ]; then
    echo "警告: .env文件不存在，复制示例文件"
    cp .env.example .env
    echo "请编辑.env文件配置必要参数"
    exit 1
fi

# 构建镜像
echo "构建Docker镜像..."
docker-compose build

# 启动数据库服务
echo "启动数据库服务..."
docker-compose up -d postgres redis

# 等待数据库就绪
echo "等待数据库就绪..."
sleep 10

# 运行数据库迁移
echo "运行数据库迁移..."
docker-compose run --rm backend alembic upgrade head

# 启动所有服务
echo "启动所有服务..."
docker-compose up -d

# 检查服务状态
echo "检查服务状态..."
sleep 5
docker-compose ps

# 健康检查
echo "执行健康检查..."
for i in {1..30}; do
    if curl -f http://localhost:8000/health > /dev/null 2>&1; then
        echo "后端服务启动成功"
        break
    fi
    echo "等待后端服务启动... ($i/30)"
    sleep 2
done

for i in {1..30}; do
    if curl -f http://localhost:3000 > /dev/null 2>&1; then
        echo "前端服务启动成功"
        break
    fi
    echo "等待前端服务启动... ($i/30)"
    sleep 2
done

echo "部署完成！"
echo "前端访问地址: http://localhost:3000"
echo "后端API地址: http://localhost:8000"
echo "默认管理员账号: admin / admin1314159"
```

## 10. 测试方案

### 10.1 单元测试

#### 10.1.1 后端单元测试

```python
# tests/test_license_service.py
import pytest
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from unittest.mock import Mock, patch

from app.services.license_service import LicenseService
from app.models.license import License
from app.models.application import Application
from app.core.exceptions import BusinessException

class TestLicenseService:
    @pytest.fixture
    def mock_db(self):
        return Mock(spec=Session)
    
    @pytest.fixture
    def mock_event_bus(self):
        return Mock()
    
    @pytest.fixture
    def mock_cache(self):
        return Mock()
    
    @pytest.fixture
    def license_service(self, mock_db, mock_event_bus, mock_cache):
        return LicenseService(mock_db, mock_event_bus, mock_cache)
    
    def test_generate_license_key(self, license_service):
        """测试卡密生成"""
        # 模拟数据库查询返回空
        license_service.db.query.return_value.filter.return_value.first.return_value = None
        
        key = license_service.generate_license_key()
        
        # 验证格式
        assert isinstance(key, str)
        assert len(key.replace('-', '')) == 32
        assert '-' in key
        
        # 验证不包含容易混淆的字符
        assert '0' not in key
        assert 'O' not in key
        assert 'I' not in key
        assert '1' not in key
    
    def test_create_license_success(self, license_service):
        """测试创建卡密成功"""
        # 模拟应用存在
        mock_app = Mock(spec=Application)
        mock_app.id = 1
        license_service.db.query.return_value.filter.return_value.first.return_value = mock_app
        
        # 模拟License.create
        mock_license = Mock(spec=License)
        mock_license.id = 1
        mock_license.license_key = "TEST-KEY-1234-5678"
        
        with patch.object(License, 'create', return_value=mock_license):
            result = license_service.create_license(
                application_id=1,
                duration_days=30,
                device_limit=2
            )
        
        assert result == mock_license
        license_service.cache.delete_pattern.assert_called_once_with("license:*")
    
    def test_create_license_app_not_found(self, license_service):
        """测试创建卡密时应用不存在"""
        # 模拟应用不存在
        license_service.db.query.return_value.filter.return_value.first.return_value = None
        
        with pytest.raises(BusinessException, match="应用不存在"):
            license_service.create_license(
                application_id=999,
                duration_days=30
            )
    
    def test_activate_license_success(self, license_service):
        """测试激活卡密成功"""
        # 模拟卡密存在且有效
        mock_license = Mock(spec=License)
        mock_license.id = 1
        mock_license.status = "pending"
        mock_license.is_expired = False
        mock_license.can_bind_device = True
        mock_license.expires_at = datetime.utcnow() + timedelta(days=30)
        mock_license.device_limit = 1
        mock_license.bound_devices = 0
        mock_license.application_id = 1
        
        license_service.db.query.return_value.filter.return_value.first.return_value = mock_license
        
        # 模拟设备不存在（首次激活）
        license_service.db.query.return_value.filter.return_value.first.side_effect = [mock_license, None]
        
        # 模拟Device.create
        mock_device = Mock()
        with patch('app.models.device.Device.create', return_value=mock_device):
            result = license_service.activate_license(
                license_key="TEST-KEY-1234-5678",
                device_id="device123"
            )
        
        assert result["success"] is True
        assert result["message"] == "激活成功"
        license_service.event_bus.publish.assert_called_once()
    
    def test_verify_license_valid(self, license_service):
        """测试验证有效卡密"""
        # 模拟缓存未命中
        license_service.cache.get.return_value = None
        
        # 模拟卡密和设备存在且有效
        mock_license = Mock(spec=License)
        mock_license.status = "active"
        mock_license.is_expired = False
        mock_license.expires_at = datetime.utcnow() + timedelta(days=30)
        mock_license.application_id = 1
        mock_license.device_limit = 1
        mock_license.bound_devices = 1
        
        mock_device = Mock()
        mock_device.is_active = True
        mock_device.last_seen = datetime.utcnow()
        
        license_service.db.query.return_value.filter.return_value.first.side_effect = [mock_license, mock_device]
        
        result = license_service.verify_license(
            license_key="TEST-KEY-1234-5678",
            device_id="device123"
        )
        
        assert result["valid"] is True
        assert "license_info" in result
        license_service.cache.set.assert_called_once()

# tests/conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient

from app.main import app
from app.database import get_db
from app.models.base import Base

# 测试数据库配置
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture(scope="session")
def db_engine():
    """创建测试数据库引擎"""
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)

@pytest.fixture
def db_session(db_engine):
    """创建测试数据库会话"""
    connection = db_engine.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)
    
    yield session
    
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture
def client(db_session):
    """创建测试客户端"""
    def override_get_db():
        yield db_session
    
    app.dependency_overrides[get_db] = override_get_db
    
    with TestClient(app) as test_client:
        yield test_client
    
    app.dependency_overrides.clear()
```

#### 10.1.2 前端单元测试

```javascript
// __tests__/components/LicenseCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { LicenseCard } from '@/components/LicenseCard';
import { License } from '@/types';

const mockLicense: License = {
  id: 1,
  license_key: 'TEST-KEY-1234-5678',
  application_id: 1,
  application_name: '测试应用',
  status: 'active',
  device_limit: 2,
  bound_devices: 1,
  expires_at: '2024-12-31T23:59:59Z',
  created_at: '2024-01-01T00:00:00Z'
};

describe('LicenseCard', () => {
  it('应该正确渲染卡密信息', () => {
    render(<LicenseCard license={mockLicense} />);
    
    expect(screen.getByText('TEST-KEY-1234-5678')).toBeInTheDocument();
    expect(screen.getByText('测试应用')).toBeInTheDocument();
    expect(screen.getByText('已激活')).toBeInTheDocument();
    expect(screen.getByText('1/2')).toBeInTheDocument();
  });
  
  it('应该正确显示过期状态', () => {
    const expiredLicense = {
      ...mockLicense,
      status: 'expired' as const,
      expires_at: '2023-12-31T23:59:59Z'
    };
    
    render(<LicenseCard license={expiredLicense} />);
    
    expect(screen.getByText('已过期')).toBeInTheDocument();
    expect(screen.getByText('已过期')).toHaveClass('text-red-600');
  });
  
  it('应该触发复制卡密功能', async () => {
    // 模拟clipboard API
    Object.assign(navigator, {
      clipboard: {
        writeText: jest.fn().mockImplementation(() => Promise.resolve())
      }
    });
    
    render(<LicenseCard license={mockLicense} />);
    
    const copyButton = screen.getByRole('button', { name: /复制/i });
    fireEvent.click(copyButton);
    
    expect(navigator.clipboard.writeText).toHaveBeenCalledWith('TEST-KEY-1234-5678');
  });
});

// __tests__/hooks/useLicenses.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useLicenses } from '@/hooks/useLicenses';
import { api } from '@/lib/api';

// 模拟API
jest.mock('@/lib/api');
const mockedApi = api as jest.Mocked<typeof api>;

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });
  
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useLicenses', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('应该成功获取卡密列表', async () => {
    const mockData = {
      success: true,
      data: {
        items: [mockLicense],
        total: 1,
        page: 1,
        page_size: 10
      }
    };
    
    mockedApi.get.mockResolvedValueOnce({ data: mockData });
    
    const { result } = renderHook(() => useLicenses(), {
      wrapper: createWrapper()
    });
    
    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });
    
    expect(result.current.data?.items).toHaveLength(1);
    expect(result.current.data?.items[0]).toEqual(mockLicense);
  });
  
  it('应该处理API错误', async () => {
    mockedApi.get.mockRejectedValueOnce(new Error('网络错误'));
    
    const { result } = renderHook(() => useLicenses(), {
      wrapper: createWrapper()
    });
    
    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });
    
    expect(result.current.error).toBeDefined();
  });
});
```

### 10.2 集成测试

```python
# tests/test_integration.py
import pytest
from fastapi.testclient import TestClient
from datetime import datetime, timedelta

from app.main import app
from app.models.user import User
from app.models.application import Application
from app.models.license import License

class TestLicenseIntegration:
    def test_complete_license_workflow(self, client: TestClient, db_session):
        """测试完整的卡密工作流程"""
        # 1. 创建管理员用户
        admin_user = User.create(
            db_session,
            username="admin",
            email="admin@test.com",
            hashed_password="hashed_password",
            is_admin=True
        )
        
        # 2. 登录获取token
        login_response = client.post("/api/v1/auth/login", json={
            "username": "admin",
            "password": "admin1314159"
        })
        assert login_response.status_code == 200
        token = login_response.json()["data"]["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # 3. 创建应用
        app_response = client.post("/api/v1/applications/", json={
            "name": "测试应用",
            "description": "用于测试的应用",
            "version": "1.0.0"
        }, headers=headers)
        assert app_response.status_code == 200
        app_id = app_response.json()["data"]["id"]
        
        # 4. 创建卡密
        license_response = client.post("/api/v1/licenses/", json={
            "application_id": app_id,
            "duration_days": 30,
            "device_limit": 2
        }, headers=headers)
        assert license_response.status_code == 200
        license_key = license_response.json()["data"]["license_key"]
        
        # 5. 激活卡密
        activate_response = client.post("/api/v1/licenses/activate", json={
            "license_key": license_key,
            "device_id": "test_device_001",
            "device_info": {
                "os": "Windows 11",
                "cpu": "Intel i7",
                "memory": "16GB"
            }
        })
        assert activate_response.status_code == 200
        assert activate_response.json()["data"]["success"] is True
        
        # 6. 验证卡密
        verify_response = client.post("/api/v1/licenses/verify", json={
            "license_key": license_key,
            "device_id": "test_device_001"
        })
        assert verify_response.status_code == 200
        assert verify_response.json()["data"]["valid"] is True
        
        # 7. 尝试超出设备限制
        activate_response2 = client.post("/api/v1/licenses/activate", json={
            "license_key": license_key,
            "device_id": "test_device_002"
        })
        assert activate_response2.status_code == 200
        
        activate_response3 = client.post("/api/v1/licenses/activate", json={
            "license_key": license_key,
            "device_id": "test_device_003"
        })
        assert activate_response3.status_code == 400
        assert "设备绑定数量已达上限" in activate_response3.json()["detail"]
        
        # 8. 获取统计信息
        stats_response = client.get("/api/v1/licenses/statistics", headers=headers)
        assert stats_response.status_code == 200
        stats = stats_response.json()["data"]
        assert stats["total"] == 1
        assert stats["active"] == 1
```

### 10.3 性能测试

```python
# tests/test_performance.py
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
import requests

class TestPerformance:
    BASE_URL = "http://localhost:8000"
    
    def test_license_verification_performance(self):
        """测试卡密验证性能"""
        # 准备测试数据
        license_key = "TEST-KEY-1234-5678"
        device_id = "performance_test_device"
        
        def verify_license():
            response = requests.post(f"{self.BASE_URL}/api/v1/licenses/verify", json={
                "license_key": license_key,
                "device_id": device_id
            })
            return response.status_code == 200
        
        # 单次请求性能测试
        start_time = time.time()
        result = verify_license()
        end_time = time.time()
        
        response_time = (end_time - start_time) * 1000  # 转换为毫秒
        assert response_time < 300, f"响应时间过长: {response_time}ms"
        assert result is True
        
        # 并发性能测试
        concurrent_requests = 100
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(verify_license) for _ in range(concurrent_requests)]
            results = [future.result() for future in futures]
        
        end_time = time.time()
        total_time = end_time - start_time
        
        # 验证结果
        success_count = sum(results)
        success_rate = success_count / concurrent_requests
        
        assert success_rate >= 0.95, f"成功率过低: {success_rate}"
        assert total_time < 10, f"并发测试时间过长: {total_time}s"
        
        print(f"并发测试结果:")
        print(f"  请求数量: {concurrent_requests}")
        print(f"  成功数量: {success_count}")
        print(f"  成功率: {success_rate:.2%}")
        print(f"  总耗时: {total_time:.2f}s")
        print(f"  平均响应时间: {(total_time / concurrent_requests * 1000):.2f}ms")
```

## 11. 安全加固

### 11.1 数据加密

```python
# utils/crypto.py
import base64
import hashlib
import secrets
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from typing import Union, Optional

class CryptoManager:
    """加密管理器"""
    
    def __init__(self, master_key: str):
        self.master_key = master_key.encode()
        self._fernet = None
    
    @property
    def fernet(self) -> Fernet:
        """获取Fernet实例"""
        if self._fernet is None:
            # 使用PBKDF2派生密钥
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=b'license_system_salt',  # 生产环境应使用随机salt
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
            self._fernet = Fernet(key)
        return self._fernet
    
    def encrypt(self, data: Union[str, bytes]) -> str:
        """加密数据"""
        if isinstance(data, str):
            data = data.encode('utf-8')
        
        encrypted = self.fernet.encrypt(data)
        return base64.urlsafe_b64encode(encrypted).decode('utf-8')
    
    def decrypt(self, encrypted_data: str) -> str:
        """解密数据"""
        try:
            encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode('utf-8'))
            decrypted = self.fernet.decrypt(encrypted_bytes)
            return decrypted.decode('utf-8')
        except Exception:
            raise ValueError("解密失败")
    
    def hash_password(self, password: str, salt: Optional[str] = None) -> tuple[str, str]:
        """哈希密码"""
        if salt is None:
            salt = secrets.token_hex(16)
        
        # 使用PBKDF2哈希密码
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt.encode(),
            iterations=100000,
        )
        
        hashed = kdf.derive(password.encode())
        return base64.urlsafe_b64encode(hashed).decode(), salt
    
    def verify_password(self, password: str, hashed: str, salt: str) -> bool:
        """验证密码"""
        try:
            expected_hash, _ = self.hash_password(password, salt)
            return secrets.compare_digest(hashed, expected_hash)
        except Exception:
            return False
    
    def generate_api_key(self, length: int = 32) -> str:
        """生成API密钥"""
        return secrets.token_urlsafe(length)
    
    def hash_device_id(self, device_id: str) -> str:
        """哈希设备ID（单向）"""
        return hashlib.sha256(device_id.encode()).hexdigest()

# 全局加密实例
crypto_manager = None

def init_crypto(master_key: str):
    """初始化加密管理器"""
    global crypto_manager
    crypto_manager = CryptoManager(master_key)

def encrypt_data(data: Union[str, dict]) -> str:
    """加密数据"""
    if crypto_manager is None:
        raise RuntimeError("加密管理器未初始化")
    
    if isinstance(data, dict):
        import json
        data = json.dumps(data, ensure_ascii=False)
    
    return crypto_manager.encrypt(data)

def decrypt_data(encrypted_data: str) -> str:
    """解密数据"""
    if crypto_manager is None:
        raise RuntimeError("加密管理器未初始化")
    
    return crypto_manager.decrypt(encrypted_data)
```

### 11.2 访问控制

```python
# middleware/security.py
import time
import hashlib
from typing import Dict, Optional
from fastapi import Request, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from collections import defaultdict, deque
from datetime import datetime, timedelta

class RateLimiter:
    """速率限制器"""
    
    def __init__(self, max_requests: int = 60, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests: Dict[str, deque] = defaultdict(deque)
    
    def is_allowed(self, identifier: str) -> bool:
        """检查是否允许请求"""
        now = time.time()
        window_start = now - self.window_seconds
        
        # 清理过期记录
        request_times = self.requests[identifier]
        while request_times and request_times[0] < window_start:
            request_times.popleft()
        
        # 检查是否超出限制
        if len(request_times) >= self.max_requests:
            return False
        
        # 记录当前请求
        request_times.append(now)
        return True

class SecurityMiddleware:
    """安全中间件"""
    
    def __init__(self):
        self.rate_limiter = RateLimiter()
        self.blocked_ips = set()
        self.suspicious_activities = defaultdict(int)
    
    async def __call__(self, request: Request, call_next):
        # 获取客户端IP
        client_ip = self._get_client_ip(request)
        
        # 检查IP黑名单
        if client_ip in self.blocked_ips:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="IP地址已被封禁"
            )
        
        # 速率限制
        if not self.rate_limiter.is_allowed(client_ip):
            self._record_suspicious_activity(client_ip, "rate_limit_exceeded")
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="请求过于频繁，请稍后再试"
            )
        
        # 检查请求头
        self._validate_headers(request)
        
        # 处理请求
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        
        # 添加安全响应头
        self._add_security_headers(response)
        
        # 记录响应时间（检测异常）
        if process_time > 5.0:  # 超过5秒认为异常
            self._record_suspicious_activity(client_ip, "slow_response")
        
        return response
    
    def _get_client_ip(self, request: Request) -> str:
        """获取客户端真实IP"""
        # 检查代理头
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip
        
        return request.client.host if request.client else "unknown"
    
    def _validate_headers(self, request: Request):
        """验证请求头"""
        # 检查User-Agent
        user_agent = request.headers.get("User-Agent", "")
        if not user_agent or len(user_agent) > 500:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="无效的User-Agent"
            )
        
        # 检查Content-Length
        content_length = request.headers.get("Content-Length")
        if content_length and int(content_length) > 10 * 1024 * 1024:  # 10MB限制
            raise HTTPException(
                status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
                detail="请求体过大"
            )
    
    def _add_security_headers(self, response):
        """添加安全响应头"""
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    
    def _record_suspicious_activity(self, ip: str, activity_type: str):
        """记录可疑活动"""
        key = f"{ip}:{activity_type}"
        self.suspicious_activities[key] += 1
        
        # 如果同一IP的可疑活动过多，加入黑名单
        total_suspicious = sum(
            count for k, count in self.suspicious_activities.items()
            if k.startswith(f"{ip}:")
        )
        
        if total_suspicious >= 10:
            self.blocked_ips.add(ip)
            # 记录到安全日志
            from ..core.logging import security_logger
            security_logger.warning(
                f"IP {ip} 已被自动封禁",
                ip_address=ip,
                suspicious_count=total_suspicious
            )

class APIKeyAuth(HTTPBearer):
    """API密钥认证"""
    
    def __init__(self, auto_error: bool = True):
        super().__init__(auto_error=auto_error)
        self.valid_api_keys = set()  # 从配置或数据库加载
    
    async def __call__(self, request: Request) -> Optional[str]:
        credentials: HTTPAuthorizationCredentials = await super().__call__(request)
        
        if credentials:
            api_key = credentials.credentials
            if self._validate_api_key(api_key):
                return api_key
            else:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="无效的API密钥"
                )
        
        return None
    
    def _validate_api_key(self, api_key: str) -> bool:
        """验证API密钥"""
        # 简单的哈希验证（生产环境应使用数据库）
        api_key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        return api_key_hash in self.valid_api_keys
```

### 11.3 数据脱敏

```python
# utils/data_masking.py
import re
from typing import Any, Dict, List, Union

class DataMasker:
    """数据脱敏器"""
    
    # 敏感字段模式
    SENSITIVE_PATTERNS = {
        'password': r'password|pwd|passwd',
        'email': r'email|mail',
        'phone': r'phone|mobile|tel',
        'id_card': r'id_card|identity|idcard',
        'credit_card': r'card_number|credit_card',
        'license_key': r'license_key|key|token'
    }
    
    @classmethod
    def mask_dict(cls, data: Dict[str, Any], mask_license_keys: bool = False) -> Dict[str, Any]:
        """脱敏字典数据"""
        if not isinstance(data, dict):
            return data
        
        masked_data = {}
        
        for key, value in data.items():
            key_lower = key.lower()
            
            # 递归处理嵌套字典
            if isinstance(value, dict):
                masked_data[key] = cls.mask_dict(value, mask_license_keys)
            elif isinstance(value, list):
                masked_data[key] = [cls.mask_dict(item, mask_license_keys) if isinstance(item, dict) else item for item in value]
            else:
                # 检查是否为敏感字段
                if cls._is_sensitive_field(key_lower, mask_license_keys):
                    masked_data[key] = cls._mask_value(value, key_lower)
                else:
                    masked_data[key] = value
        
        return masked_data
    
    @classmethod
    def _is_sensitive_field(cls, field_name: str, mask_license_keys: bool = False) -> bool:
        """检查是否为敏感字段"""
        for pattern_type, pattern in cls.SENSITIVE_PATTERNS.items():
            if pattern_type == 'license_key' and not mask_license_keys:
                continue
            
            if re.search(pattern, field_name, re.IGNORECASE):
                return True
        
        return False
    
    @classmethod
    def _mask_value(cls, value: Any, field_type: str) -> str:
        """脱敏值"""
        if value is None:
            return None
        
        value_str = str(value)
        
        if not value_str:
            return value_str
        
        # 根据字段类型选择脱敏策略
        if 'password' in field_type:
            return '***'
        elif 'email' in field_type:
            return cls._mask_email(value_str)
        elif 'phone' in field_type:
            return cls._mask_phone(value_str)
        elif 'license' in field_type or 'key' in field_type:
            return cls._mask_license_key(value_str)
        else:
            # 默认脱敏策略
            return cls._mask_default(value_str)
    
    @classmethod
    def _mask_email(cls, email: str) -> str:
        """脱敏邮箱"""
        if '@' not in email:
            return cls._mask_default(email)
        
        local, domain = email.split('@', 1)
        if len(local) <= 2:
            masked_local = '*' * len(local)
        else:
            masked_local = local[0] + '*' * (len(local) - 2) + local[-1]
        
        return f"{masked_local}@{domain}"
    
    @classmethod
    def _mask_phone(cls, phone: str) -> str:
        """脱敏手机号"""
        # 移除非数字字符
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) < 7:
            return '*' * len(phone)
        
        # 保留前3位和后4位
        if len(digits) >= 11:
            return digits[:3] + '*' * (len(digits) - 7) + digits[-4:]
        else:
            return digits[:2] + '*' * (len(digits) - 4) + digits[-2:]
    
    @classmethod
    def _mask_license_key(cls, license_key: str) -> str:
        """脱敏卡密"""
        if len(license_key) <= 8:
            return '*' * len(license_key)
        
        # 保留前4位和后4位
        return license_key[:4] + '*' * (len(license_key) - 8) + license_key[-4:]
    
    @classmethod
    def _mask_default(cls, value: str) -> str:
        """默认脱敏策略"""
        if len(value) <= 2:
            return '*' * len(value)
        elif len(value) <= 6:
            return value[0] + '*' * (len(value) - 2) + value[-1]
        else:
            return value[:2] + '*' * (len(value) - 4) + value[-2:]

# 使用示例
def mask_log_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """脱敏日志数据"""
    return DataMasker.mask_dict(data, mask_license_keys=True)

def mask_api_response(data: Dict[str, Any]) -> Dict[str, Any]:
    """脱敏API响应数据"""
    return DataMasker.mask_dict(data, mask_license_keys=False)
```

## 12. 项目总结

### 12.1 技术架构总结

本金鱼智盒卡密授权系统采用现代化的前后端分离架构，具备以下核心特性：

#### 12.1.1 技术栈选择

**前端技术栈**：
- **React 18** + **Next.js 14**：提供现代化的用户界面和服务端渲染能力
- **TypeScript**：增强代码类型安全和开发体验
- **Tailwind CSS**：实现响应式和美观的UI设计
- **React Query**：优化数据获取和状态管理
- **Zustand**：轻量级全局状态管理

**后端技术栈**：
- **FastAPI**：高性能异步Web框架，自动生成API文档
- **SQLAlchemy**：强大的ORM框架，支持数据库迁移
- **PostgreSQL**：可靠的关系型数据库
- **Redis**：高性能缓存和会话存储
- **Alembic**：数据库版本控制和迁移

#### 12.1.2 系统架构优势

1. **高可用性**：通过Docker容器化部署，支持水平扩展
2. **高性能**：Redis缓存机制，数据库连接池优化
3. **高安全性**：多层安全防护，数据加密存储
4. **易维护性**：模块化设计，清晰的代码结构
5. **易扩展性**：事件驱动架构，支持功能模块独立扩展

### 12.2 核心功能实现

#### 12.2.1 卡密管理系统

- **卡密生成**：采用密码学安全的随机数生成，避免冲突和猜测
- **设备绑定**：基于硬件指纹的设备识别和绑定限制
- **状态管理**：完整的卡密生命周期管理（待激活→已激活→已过期→已暂停）
- **批量操作**：支持批量生成、导出和管理卡密

#### 12.2.2 用户权限系统

- **角色分离**：管理员和普通用户的权限隔离
- **JWT认证**：无状态的身份验证机制
- **会话管理**：支持多设备登录和会话控制
- **操作审计**：完整的用户操作日志记录

#### 12.2.3 应用管理模块

- **应用注册**：支持多应用管理和版本控制
- **维护模式**：应用维护期间的访问控制
- **公告系统**：实时消息推送和公告管理
- **统计分析**：应用使用情况和卡密分布统计

### 12.3 安全保障措施

#### 12.3.1 数据安全

- **加密存储**：敏感数据使用AES-256加密
- **传输安全**：HTTPS协议和TLS加密
- **密码安全**：PBKDF2哈希算法，防彩虹表攻击
- **数据脱敏**：日志和API响应的敏感信息脱敏

#### 12.3.2 访问控制

- **速率限制**：防止暴力破解和DDoS攻击
- **IP黑名单**：自动检测和封禁恶意IP
- **API密钥**：客户端应用的身份验证
- **CORS策略**：跨域请求的安全控制

#### 12.3.3 监控告警

- **实时监控**：系统性能和业务指标监控
- **异常检测**：自动识别异常行为和安全威胁
- **日志审计**：结构化日志记录和分析
- **健康检查**：服务可用性监控和自动恢复

### 12.4 部署运维方案

#### 12.4.1 容器化部署

- **Docker镜像**：标准化的应用打包和分发
- **Docker Compose**：本地开发和测试环境
- **多阶段构建**：优化镜像大小和安全性
- **健康检查**：容器状态监控和自动重启

#### 12.4.2 生产环境优化

- **负载均衡**：Nginx反向代理和负载分发
- **数据库优化**：连接池、索引优化、读写分离
- **缓存策略**：多级缓存和缓存预热
- **备份恢复**：自动化数据备份和灾难恢复

### 12.5 测试保障体系

#### 12.5.1 测试覆盖

- **单元测试**：核心业务逻辑的单元测试覆盖
- **集成测试**：API接口和数据库交互测试
- **性能测试**：并发压力和响应时间测试
- **安全测试**：漏洞扫描和渗透测试

#### 12.5.2 质量保证

- **代码审查**：Pull Request代码审查流程
- **自动化测试**：CI/CD流水线集成测试
- **代码覆盖率**：测试覆盖率监控和报告
- **性能基准**：性能指标基准和回归测试

### 12.6 项目亮点与创新

#### 12.6.1 技术创新

1. **事件驱动架构**：模块间松耦合的事件通信机制
2. **智能缓存策略**：多级缓存和缓存失效策略
3. **自适应安全防护**：基于行为分析的安全防护
4. **实时数据同步**：WebSocket实时数据推送

#### 12.6.2 用户体验优化

1. **响应式设计**：适配多种设备和屏幕尺寸
2. **渐进式加载**：优化页面加载性能
3. **离线支持**：Service Worker离线缓存
4. **国际化支持**：多语言界面支持

### 12.7 未来发展规划

#### 12.7.1 功能扩展

- **移动端应用**：iOS和Android原生应用
- **API网关**：统一的API管理和限流
- **数据分析**：用户行为分析和商业智能
- **第三方集成**：支付系统和第三方服务集成

#### 12.7.2 技术升级

- **微服务架构**：服务拆分和独立部署
- **云原生部署**：Kubernetes容器编排
- **AI智能化**：机器学习异常检测
- **区块链技术**：去中心化的授权验证

### 12.8 开发团队建议

#### 12.8.1 开发规范

1. **代码规范**：统一的代码风格和命名规范
2. **Git工作流**：标准化的分支管理和提交规范
3. **文档维护**：及时更新技术文档和API文档
4. **安全意识**：定期安全培训和漏洞修复

#### 12.8.2 运维建议

1. **监控告警**：完善的监控体系和告警机制
2. **备份策略**：定期数据备份和恢复演练
3. **性能优化**：持续的性能监控和优化
4. **安全加固**：定期安全审计和漏洞扫描

---

**项目总结**：金鱼智盒卡密授权系统是一个功能完整、架构合理、安全可靠的企业级授权管理平台。通过现代化的技术栈和完善的安全机制，为软件开发商提供了专业的授权解决方案。系统具备良好的扩展性和维护性，能够满足不同规模企业的授权管理需求。

本文档涵盖了从需求分析到部署运维的完整开发流程，为开发团队提供了详细的技术指导和最佳实践。希望能够帮助开发者快速理解和实施这一授权系统，为软件产品的商业化运营提供强有力的技术支撑。

#### 7.5.2 卡密管理组件

```tsx
// components/licenses/LicenseList.tsx
import React, { useEffect, useState } from 'react';
import { useLicenseStore } from '../../store/licenseStore';
import { Button } from '../common/Button';
import { Table } from '../common/Table';
import { Badge } from '../common/Badge';
import { Pagination } from '../common/Pagination';
import { SearchFilter } from '../common/SearchFilter';
import { License } from '../../types/license';

export const LicenseList: React.FC = () => {
  const {
    licenses,
    total,
    isLoading,
    error,
    fetchLicenses,
    deleteLicense,
    clearError
  } = useLicenseStore();
  
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize] = useState(20);
  const [filters, setFilters] = useState({
    app_id: undefined as number | undefined,
    status: undefined as string | undefined
  });
  
  useEffect(() => {
    fetchLicenses({
      page: currentPage,
      page_size: pageSize,
      ...filters
    });
  }, [currentPage, pageSize, filters]);
  
  const handleDelete = async (id: number) => {
    if (window.confirm('确定要删除这个卡密吗？')) {
      try {
        await deleteLicense(id);
      } catch (error) {
        // 错误已在store中处理
      }
    }
  };
  
  const getStatusBadge = (status: string) => {
    const statusConfig = {
      active: { color: 'green', text: '激活' },
      expired: { color: 'red', text: '过期' },
      suspended: { color: 'yellow', text: '暂停' },
      pending: { color: 'gray', text: '待激活' }
    };
    
    const config = statusConfig[status as keyof typeof statusConfig] || 
                   { color: 'gray', text: status };
    
    return <Badge color={config.color}>{config.text}</Badge>;
  };
  
  const columns = [
    {
      key: 'license_key',
      title: '卡密',
      render: (license: License) => (
        <code className="text-sm bg-gray-100 px-2 py-1 rounded">
          {license.license_key}
        </code>
      )
    },
    {
      key: 'application_name',
      title: '应用',
      render: (license: License) => license.application_name || '-'
    },
    {
      key: 'username',
      title: '用户',
      render: (license: License) => license.username || '-'
    },
    {
      key: 'status',
      title: '状态',
      render: (license: License) => getStatusBadge(license.status)
    },
    {
      key: 'device_usage',
      title: '设备使用',
      render: (license: License) => (
        <span className={license.bound_devices >= license.device_limit ? 'text-red-600' : ''}>
          {license.bound_devices}/{license.device_limit}
        </span>
      )
    },
    {
      key: 'expires_at',
      title: '过期时间',
      render: (license: License) => 
        new Date(license.expires_at).toLocaleString('zh-CN')
    },
    {
      key: 'actions',
      title: '操作',
      render: (license: License) => (
        <div className="flex space-x-2">
          <Button
            size="small"
            variant="outline"
            onClick={() => {/* 编辑逻辑 */}}
          >
            编辑
          </Button>
          <Button
            size="small"
            variant="danger"
            onClick={() => handleDelete(license.id)}
          >
            删除
          </Button>
        </div>
      )
    }
  ];
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-900">卡密管理</h1>
        <Button variant="primary">
          创建卡密
        </Button>
      </div>
      
      <SearchFilter
        filters={[
          {
            key: 'status',
            label: '状态',
            type: 'select',
            options: [
              { value: '', label: '全部' },
              { value: 'active', label: '激活' },
              { value: 'expired', label: '过期' },
              { value: 'suspended', label: '暂停' },
              { value: 'pending', label: '待激活' }
            ]
          }
        ]}
        onFilterChange={setFilters}
      />
      
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
          {error}
          <button 
            onClick={clearError}
            className="ml-2 text-red-500 hover:text-red-700"
          >
            ×
          </button>
        </div>
      )}
      
      <Table
        columns={columns}
        data={licenses}
        loading={isLoading}
        emptyText="暂无卡密数据"
      />
      
      <Pagination
        current={currentPage}
        total={total}
        pageSize={pageSize}
        onChange={setCurrentPage}
      />
    </div>
  );
};
```