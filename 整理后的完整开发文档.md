# é‡‘é±¼æ™ºç›’å¡å¯†æˆæƒç³»ç»Ÿ - å®Œæ•´å¼€å‘æ–‡æ¡£

## ğŸ“‹ æ–‡æ¡£ç›®å½•

- [1. ç³»ç»Ÿæ¦‚è¿°](#1-ç³»ç»Ÿæ¦‚è¿°)
  - [1.1 é¡¹ç›®ç®€ä»‹](#11-é¡¹ç›®ç®€ä»‹)
  - [1.2 æ ¸å¿ƒåŠŸèƒ½](#12-æ ¸å¿ƒåŠŸèƒ½)
  - [1.3 æŠ€æœ¯æ¶æ„](#13-æŠ€æœ¯æ¶æ„)
  - [1.4 ç³»ç»Ÿç‰¹è‰²](#14-ç³»ç»Ÿç‰¹è‰²)
- [2. æŠ€æœ¯æ ˆä¸æ¶æ„è®¾è®¡](#2-æŠ€æœ¯æ ˆä¸æ¶æ„è®¾è®¡)
  - [2.1 å‰ç«¯æŠ€æœ¯æ ˆ](#21-å‰ç«¯æŠ€æœ¯æ ˆ)
  - [2.2 åç«¯æŠ€æœ¯æ ˆ](#22-åç«¯æŠ€æœ¯æ ˆ)
  - [2.3 æ•°æ®åº“è®¾è®¡](#23-æ•°æ®åº“è®¾è®¡)
  - [2.4 ç³»ç»Ÿæ¶æ„å›¾](#24-ç³»ç»Ÿæ¶æ„å›¾)
- [3. æ ¸å¿ƒåŠŸèƒ½æ¨¡å—](#3-æ ¸å¿ƒåŠŸèƒ½æ¨¡å—)
  - [3.1 ç”¨æˆ·è®¤è¯ç³»ç»Ÿ](#31-ç”¨æˆ·è®¤è¯ç³»ç»Ÿ)
  - [3.2 åº”ç”¨ç®¡ç†æ¨¡å—](#32-åº”ç”¨ç®¡ç†æ¨¡å—)
  - [3.3 å¡å¯†ç®¡ç†ç³»ç»Ÿ](#33-å¡å¯†ç®¡ç†ç³»ç»Ÿ)
  - [3.4 è®¾å¤‡ç»‘å®šæœºåˆ¶](#34-è®¾å¤‡ç»‘å®šæœºåˆ¶)
  - [3.5 åº”ç”¨å…¬å‘ŠåŠŸèƒ½](#35-åº”ç”¨å…¬å‘ŠåŠŸèƒ½)
  - [3.6 å®æ—¶é€šçŸ¥ç³»ç»Ÿ](#36-å®æ—¶é€šçŸ¥ç³»ç»Ÿ)
- [4. æ¨¡å—è”åŠ¨æœºåˆ¶](#4-æ¨¡å—è”åŠ¨æœºåˆ¶)
  - [4.1 äº‹ä»¶é©±åŠ¨æ¶æ„](#41-äº‹ä»¶é©±åŠ¨æ¶æ„)
  - [4.2 çŠ¶æ€åŒæ­¥æœºåˆ¶](#42-çŠ¶æ€åŒæ­¥æœºåˆ¶)
  - [4.3 ç¼“å­˜ä¸€è‡´æ€§](#43-ç¼“å­˜ä¸€è‡´æ€§)
- [5. å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–](#5-å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–)
  - [5.1 å®‰å…¨ç­–ç•¥](#51-å®‰å…¨ç­–ç•¥)
  - [5.2 æ€§èƒ½ä¼˜åŒ–](#52-æ€§èƒ½ä¼˜åŒ–)
  - [5.3 ç›‘æ§å®¡è®¡](#53-ç›‘æ§å®¡è®¡)
- [6. APIæ¥å£è§„èŒƒ](#6-apiæ¥å£è§„èŒƒ)
  - [6.1 æ¥å£è®¾è®¡åŸåˆ™](#61-æ¥å£è®¾è®¡åŸåˆ™)
  - [6.2 è®¤è¯æˆæƒ](#62-è®¤è¯æˆæƒ)
  - [6.3 æ ¸å¿ƒæ¥å£](#63-æ ¸å¿ƒæ¥å£)
- [7. å‰ç«¯å®ç°æŒ‡å—](#7-å‰ç«¯å®ç°æŒ‡å—)
  - [7.1 ç»„ä»¶æ¶æ„](#71-ç»„ä»¶æ¶æ„)
  - [7.2 çŠ¶æ€ç®¡ç†](#72-çŠ¶æ€ç®¡ç†)
  - [7.3 UI/UXè®¾è®¡](#73-uiuxè®¾è®¡)
- [8. åç«¯å®ç°æŒ‡å—](#8-åç«¯å®ç°æŒ‡å—)
  - [8.1 æœåŠ¡æ¶æ„](#81-æœåŠ¡æ¶æ„)
  - [8.2 æ•°æ®è®¿é—®å±‚](#82-æ•°æ®è®¿é—®å±‚)
  - [8.3 ä¸šåŠ¡é€»è¾‘å±‚](#83-ä¸šåŠ¡é€»è¾‘å±‚)
- [9. éƒ¨ç½²ä¸è¿ç»´](#9-éƒ¨ç½²ä¸è¿ç»´)
  - [9.1 ç¯å¢ƒé…ç½®](#91-ç¯å¢ƒé…ç½®)
  - [9.2 éƒ¨ç½²æŒ‡å—](#92-éƒ¨ç½²æŒ‡å—)
  - [9.3 ç›‘æ§è¿ç»´](#93-ç›‘æ§è¿ç»´)
- [10. æµ‹è¯•æ–¹æ¡ˆ](#10-æµ‹è¯•æ–¹æ¡ˆ)
  - [10.1 æµ‹è¯•ç­–ç•¥](#101-æµ‹è¯•ç­–ç•¥)
  - [10.2 æµ‹è¯•ç”¨ä¾‹](#102-æµ‹è¯•ç”¨ä¾‹)
  - [10.3 æ€§èƒ½æµ‹è¯•](#103-æ€§èƒ½æµ‹è¯•)
- [11. é™„å½•](#11-é™„å½•)
  - [11.1 é…ç½®å‚è€ƒ](#111-é…ç½®å‚è€ƒ)
  - [11.2 é”™è¯¯ç è§„èŒƒ](#112-é”™è¯¯ç è§„èŒƒ)
  - [11.3 å¼€å‘è§„èŒƒ](#113-å¼€å‘è§„èŒƒ)

---

## 1. ç³»ç»Ÿæ¦‚è¿°

### 1.1 é¡¹ç›®ç®€ä»‹

é‡‘é±¼æ™ºç›’å¡å¯†æˆæƒç³»ç»Ÿæ˜¯ä¸€ä¸ªä¼ä¸šçº§çš„è½¯ä»¶æˆæƒç®¡ç†å¹³å°ï¼Œä¸“ä¸ºPythonæ¡Œé¢åº”ç”¨è®¾è®¡ã€‚ç³»ç»Ÿé‡‡ç”¨å‰åç«¯åˆ†ç¦»æ¶æ„ï¼Œæ”¯æŒè´¦å·å¯†ç +å¡å¯†åŒé‡éªŒè¯æœºåˆ¶ï¼Œæä¾›å®Œæ•´çš„æˆæƒç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚

**æ ¸å¿ƒä»·å€¼ï¼š**
- ğŸ” **åŒé‡éªŒè¯**ï¼šè´¦å·å¯†ç +å¡å¯†åŒé‡å®‰å…¨ä¿éšœ
- ğŸ¢ **ä¼ä¸šçº§**ï¼šæ”¯æŒå¤šåº”ç”¨ã€å¤šç§Ÿæˆ·ç®¡ç†
- ğŸ›¡ï¸ **å®‰å…¨å¯é **ï¼šAES-256åŠ å¯†ã€JWTè®¤è¯ã€è®¾å¤‡ç»‘å®š
- ğŸ“Š **æ•°æ®é©±åŠ¨**ï¼šå®Œæ•´çš„ç»Ÿè®¡åˆ†æå’Œå®¡è®¡æ—¥å¿—
- ğŸš€ **é«˜æ€§èƒ½**ï¼šRedisç¼“å­˜ã€è¿æ¥æ± ä¼˜åŒ–ã€å¼‚æ­¥å¤„ç†

### 1.2 æ ¸å¿ƒåŠŸèƒ½

#### åº”ç”¨ç®¡ç†
- **å¤šåº”ç”¨æ”¯æŒ**ï¼šç‹¬ç«‹çš„æˆæƒç­–ç•¥å’Œé…ç½®
- **ç‰ˆæœ¬æ§åˆ¶**ï¼šåº”ç”¨ç‰ˆæœ¬ç®¡ç†å’Œå…¼å®¹æ€§æ£€æŸ¥
- **çŠ¶æ€ç®¡ç†**ï¼šæ­£å¸¸/ç»´æŠ¤/åœç”¨çŠ¶æ€æ§åˆ¶
- **Webhooké›†æˆ**ï¼šäº‹ä»¶é€šçŸ¥å’Œç¬¬ä¸‰æ–¹ç³»ç»Ÿé›†æˆ

#### å¡å¯†ç®¡ç†
- **æ‰¹é‡ç”Ÿæˆ**ï¼šæ”¯æŒå¤§æ‰¹é‡å¡å¯†ç”Ÿæˆå’Œå¯¼å‡º
- **æ¿€æ´»æ§åˆ¶**ï¼šè®¾å¤‡ç»‘å®šã€æ—¶é—´é™åˆ¶ã€ä½¿ç”¨æ¬¡æ•°
- **åˆ°æœŸç®¡ç†**ï¼šè‡ªåŠ¨åˆ°æœŸæ£€æŸ¥å’Œé€šçŸ¥æé†’
- **è§„åˆ™å¼•æ“**ï¼šçµæ´»çš„æˆæƒè§„åˆ™é…ç½®

#### ç”¨æˆ·ç®¡ç†
- **è§’è‰²æƒé™**ï¼šè¶…çº§ç®¡ç†å‘˜/ç®¡ç†å‘˜/æ™®é€šç”¨æˆ·
- **æƒé™æ§åˆ¶**ï¼šåŸºäºRBACçš„ç»†ç²’åº¦æƒé™ç®¡ç†
- **æ“ä½œå®¡è®¡**ï¼šå®Œæ•´çš„ç”¨æˆ·æ“ä½œè®°å½•
- **å®‰å…¨ç­–ç•¥**ï¼šå¯†ç ç­–ç•¥ã€ç™»å½•é™åˆ¶ã€IPç™½åå•

#### è®¾å¤‡ç»‘å®š
- **ç¡¬ä»¶æŒ‡çº¹**ï¼šCPUã€ä¸»æ¿ã€ç¡¬ç›˜ç­‰ç¡¬ä»¶ä¿¡æ¯è¯†åˆ«
- **è®¾å¤‡é™åˆ¶**ï¼šå•å¡å¯†æ”¯æŒçš„æœ€å¤§è®¾å¤‡æ•°é‡
- **è®¾å¤‡ç®¡ç†**ï¼šè®¾å¤‡è§£ç»‘ã€é»‘åå•ç®¡ç†
- **å¼‚å¸¸æ£€æµ‹**ï¼šè®¾å¤‡å˜æ›´æ£€æµ‹å’Œå®‰å…¨å‘Šè­¦

### 1.3 æŠ€æœ¯æ¶æ„

```mermaid
graph TB
    subgraph "å®¢æˆ·ç«¯å±‚"
        A[Pythonæ¡Œé¢åº”ç”¨]
        B[Webç®¡ç†ç•Œé¢]
        C[ç§»åŠ¨ç«¯åº”ç”¨]
    end
    
    subgraph "ç½‘å…³å±‚"
        D[Nginxåå‘ä»£ç†]
        E[APIç½‘å…³]
        F[è´Ÿè½½å‡è¡¡]
    end
    
    subgraph "åº”ç”¨å±‚"
        G[å‰ç«¯ React+Next.js]
        H[åç«¯ FastAPI]
        I[WebSocketæœåŠ¡]
    end
    
    subgraph "æœåŠ¡å±‚"
        J[è®¤è¯æœåŠ¡]
        K[æˆæƒæœåŠ¡]
        L[é€šçŸ¥æœåŠ¡]
        M[å®¡è®¡æœåŠ¡]
    end
    
    subgraph "æ•°æ®å±‚"
        N[PostgreSQLä¸»åº“]
        O[Redisç¼“å­˜]
        P[æ–‡ä»¶å­˜å‚¨]
        Q[æ—¥å¿—å­˜å‚¨]
    end
    
    A --> D
    B --> D
    C --> D
    D --> E
    E --> F
    F --> G
    F --> H
    F --> I
    
    H --> J
    H --> K
    H --> L
    H --> M
    
    J --> N
    K --> N
    L --> O
    M --> Q
    
    H --> N
    H --> O
    H --> P
```

### 1.4 ç³»ç»Ÿç‰¹è‰²

#### é«˜å¯ç”¨æ€§
- **99.9%å¯ç”¨æ€§**ï¼šç³»ç»Ÿå¹´åº¦å¯ç”¨æ€§ä¿éšœ
- **æ•…éšœæ¢å¤**ï¼šè‡ªåŠ¨æ•…éšœæ£€æµ‹å’Œå¿«é€Ÿæ¢å¤
- **æ•°æ®å¤‡ä»½**ï¼šå®šæ—¶å¤‡ä»½å’Œç¾éš¾æ¢å¤æ–¹æ¡ˆ
- **ç›‘æ§å‘Šè­¦**ï¼šå®æ—¶ç›‘æ§å’Œæ™ºèƒ½å‘Šè­¦

#### é«˜æ€§èƒ½
- **å“åº”æ—¶é—´**ï¼šAPIæ¥å£å“åº”æ—¶é—´â‰¤300ms
- **å¹¶å‘å¤„ç†**ï¼šæ”¯æŒ1000+å¹¶å‘ç”¨æˆ·
- **ç¼“å­˜ç­–ç•¥**ï¼šå¤šçº§ç¼“å­˜å’Œæ™ºèƒ½é¢„åŠ è½½
- **æ•°æ®åº“ä¼˜åŒ–**ï¼šç´¢å¼•ä¼˜åŒ–å’ŒæŸ¥è¯¢ä¼˜åŒ–

#### é«˜å®‰å…¨æ€§
- **æ•°æ®åŠ å¯†**ï¼šAES-256æ•°æ®åŠ å¯†å­˜å‚¨
- **ä¼ è¾“å®‰å…¨**ï¼šHTTPS/WSSåŠ å¯†ä¼ è¾“
- **è®¿é—®æ§åˆ¶**ï¼šå¤šå› å­è®¤è¯å’Œæƒé™æ§åˆ¶
- **å®‰å…¨å®¡è®¡**ï¼šå®Œæ•´çš„å®‰å…¨æ—¥å¿—å’Œå®¡è®¡

#### æ˜“æ‰©å±•æ€§
- **æ¨¡å—åŒ–è®¾è®¡**ï¼šæ¾è€¦åˆçš„æ¨¡å—åŒ–æ¶æ„
- **æ’ä»¶æœºåˆ¶**ï¼šæ”¯æŒåŠŸèƒ½æ’ä»¶æ‰©å±•
- **APIå¼€æ”¾**ï¼šå®Œæ•´çš„RESTful API
- **å¾®æœåŠ¡å°±ç»ª**ï¼šæ”¯æŒå¾®æœåŠ¡æ¶æ„æ¼”è¿›

---

## 2. æŠ€æœ¯æ ˆä¸æ¶æ„è®¾è®¡

### 2.1 å‰ç«¯æŠ€æœ¯æ ˆ

#### æ ¸å¿ƒæ¡†æ¶
```json
{
  "react": "18.2.0",
  "next": "13.4.19",
  "typescript": "5.1.6"
}
```

**é€‰å‹ç†ç”±ï¼š**
- **React 18**ï¼šæœ€æ–°çš„å¹¶å‘ç‰¹æ€§ï¼Œæ›´å¥½çš„æ€§èƒ½
- **Next.js 13**ï¼šApp Routerã€æœåŠ¡ç«¯ç»„ä»¶ã€ä¼˜åŒ–çš„æ„å»º
- **TypeScript**ï¼šç±»å‹å®‰å…¨ï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯

#### UIç»„ä»¶åº“
```json
{
  "antd": "5.8.6",
  "@heroicons/react": "2.0.18",
  "@headlessui/react": "1.7.17"
}
```

**ç‰¹æ€§è¯´æ˜ï¼š**
- **Ant Design 5**ï¼šä¼ä¸šçº§UIè®¾è®¡è¯­è¨€ï¼Œç»„ä»¶ä¸°å¯Œ
- **Heroicons**ï¼šé«˜è´¨é‡SVGå›¾æ ‡ï¼Œæ”¯æŒå¤šç§æ ·å¼
- **Headless UI**ï¼šæ— æ ·å¼ç»„ä»¶ï¼Œé«˜åº¦å¯å®šåˆ¶

#### çŠ¶æ€ç®¡ç†
```json
{
  "zustand": "4.4.1",
  "swr": "2.2.2",
  "react-hook-form": "7.45.4"
}
```

**æ¶æ„ä¼˜åŠ¿ï¼š**
- **Zustand**ï¼šè½»é‡çº§çŠ¶æ€ç®¡ç†ï¼ŒTypeScriptå‹å¥½
- **SWR**ï¼šæ•°æ®è·å–å’Œç¼“å­˜ï¼Œè‡ªåŠ¨é‡æ–°éªŒè¯
- **React Hook Form**ï¼šé«˜æ€§èƒ½è¡¨å•åº“ï¼Œæœ€å°‘é‡æ¸²æŸ“

#### æ ·å¼ä¸åŠ¨ç”»
```json
{
  "tailwindcss": "3.3.3",
  "framer-motion": "10.16.4",
  "class-variance-authority": "0.7.0"
}
```

### 2.2 åç«¯æŠ€æœ¯æ ˆ

#### æ ¸å¿ƒæ¡†æ¶
```python
# pyproject.toml
[tool.poetry.dependencies]
python = "^3.9"
fastapi = "^0.103.0"
uvicorn = {extras = ["standard"], version = "^0.23.0"}
pydantic = "^2.3.0"
```

**æŠ€æœ¯ä¼˜åŠ¿ï¼š**
- **FastAPI**ï¼šé«˜æ€§èƒ½å¼‚æ­¥æ¡†æ¶ï¼Œè‡ªåŠ¨APIæ–‡æ¡£
- **Uvicorn**ï¼šASGIæœåŠ¡å™¨ï¼Œæ”¯æŒHTTP/2å’ŒWebSocket
- **Pydantic**ï¼šæ•°æ®éªŒè¯å’Œåºåˆ—åŒ–ï¼Œç±»å‹å®‰å…¨

#### æ•°æ®åº“ä¸ç¼“å­˜
```python
# æ•°æ®åº“
sqlalchemy = "^2.0.20"
alembic = "^1.12.0"
asyncpg = "^0.28.0"

# ç¼“å­˜
redis = "^4.6.0"
aioredis = "^2.0.1"
```

#### å®‰å…¨ä¸è®¤è¯
```python
# è®¤è¯
python-jose = {extras = ["cryptography"], version = "^3.3.0"}
passlib = {extras = ["bcrypt"], version = "^1.7.4"}
python-multipart = "^0.0.6"

# å®‰å…¨
cryptography = "^41.0.4"
```

### 2.3 æ•°æ®åº“è®¾è®¡

#### ä¸»æ•°æ®åº“ï¼ˆPostgreSQLï¼‰

**æ ¸å¿ƒè¡¨ç»“æ„ï¼š**

```sql
-- ç”¨æˆ·è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) DEFAULT 'user',
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- åº”ç”¨è¡¨
CREATE TABLE applications (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    version VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    webhook_url VARCHAR(500),
    settings JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- å¡å¯†è¡¨
CREATE TABLE licenses (
    id SERIAL PRIMARY KEY,
    license_key VARCHAR(100) UNIQUE NOT NULL,
    application_id INTEGER REFERENCES applications(id),
    license_type VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'inactive',
    max_devices INTEGER DEFAULT 1,
    expires_at TIMESTAMP,
    activated_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- è®¾å¤‡è¡¨
CREATE TABLE devices (
    id SERIAL PRIMARY KEY,
    device_id VARCHAR(255) UNIQUE NOT NULL,
    device_name VARCHAR(100),
    device_type VARCHAR(50),
    os_info VARCHAR(200),
    hardware_info JSONB,
    license_id INTEGER REFERENCES licenses(id),
    status VARCHAR(20) DEFAULT 'active',
    first_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### ç¼“å­˜è®¾è®¡ï¼ˆRedisï¼‰

**ç¼“å­˜ç­–ç•¥ï¼š**

```python
# ç¼“å­˜é”®å‘½åè§„èŒƒ
CACHE_KEYS = {
    'user_session': 'session:{user_id}',
    'license_info': 'license:{license_key}',
    'device_info': 'device:{device_id}',
    'app_config': 'app:{app_id}:config',
    'rate_limit': 'rate_limit:{ip}:{endpoint}',
    'notification': 'notification:{user_id}'
}

# ç¼“å­˜è¿‡æœŸæ—¶é—´
CACHE_TTL = {
    'session': 3600 * 24,      # 24å°æ—¶
    'license': 3600 * 2,       # 2å°æ—¶
    'device': 3600,            # 1å°æ—¶
    'config': 3600 * 12,       # 12å°æ—¶
    'rate_limit': 60,          # 1åˆ†é’Ÿ
    'notification': 3600 * 6   # 6å°æ—¶
}
```

### 2.4 ç³»ç»Ÿæ¶æ„å›¾

#### éƒ¨ç½²æ¶æ„

```mermaid
graph TB
    subgraph "è´Ÿè½½å‡è¡¡å±‚"
        LB[Nginxè´Ÿè½½å‡è¡¡]
    end
    
    subgraph "åº”ç”¨æœåŠ¡å™¨é›†ç¾¤"
        APP1[åº”ç”¨æœåŠ¡å™¨1]
        APP2[åº”ç”¨æœåŠ¡å™¨2]
        APP3[åº”ç”¨æœåŠ¡å™¨3]
    end
    
    subgraph "æ•°æ®åº“é›†ç¾¤"
        DB_MASTER[PostgreSQLä¸»åº“]
        DB_SLAVE1[PostgreSQLä»åº“1]
        DB_SLAVE2[PostgreSQLä»åº“2]
    end
    
    subgraph "ç¼“å­˜é›†ç¾¤"
        REDIS_MASTER[Redisä¸»èŠ‚ç‚¹]
        REDIS_SLAVE1[Redisä»èŠ‚ç‚¹1]
        REDIS_SLAVE2[Redisä»èŠ‚ç‚¹2]
    end
    
    subgraph "ç›‘æ§ç³»ç»Ÿ"
        MONITOR[Prometheus]
        GRAFANA[Grafana]
        ALERT[AlertManager]
    end
    
    LB --> APP1
    LB --> APP2
    LB --> APP3
    
    APP1 --> DB_MASTER
    APP2 --> DB_MASTER
    APP3 --> DB_MASTER
    
    DB_MASTER --> DB_SLAVE1
    DB_MASTER --> DB_SLAVE2
    
    APP1 --> REDIS_MASTER
    APP2 --> REDIS_MASTER
    APP3 --> REDIS_MASTER
    
    REDIS_MASTER --> REDIS_SLAVE1
    REDIS_MASTER --> REDIS_SLAVE2
    
    APP1 --> MONITOR
    APP2 --> MONITOR
    APP3 --> MONITOR
    
    MONITOR --> GRAFANA
    MONITOR --> ALERT
```

---

## 3. æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

### 3.1 ç”¨æˆ·è®¤è¯ç³»ç»Ÿ

#### è®¤è¯æµç¨‹

```mermaid
sequenceDiagram
    participant C as å®¢æˆ·ç«¯
    participant A as è®¤è¯æœåŠ¡
    participant D as æ•°æ®åº“
    participant R as Redisç¼“å­˜
    
    C->>A: ç™»å½•è¯·æ±‚(ç”¨æˆ·å/å¯†ç )
    A->>D: éªŒè¯ç”¨æˆ·å‡­æ®
    D-->>A: è¿”å›ç”¨æˆ·ä¿¡æ¯
    A->>A: ç”ŸæˆJWT Token
    A->>R: å­˜å‚¨ä¼šè¯ä¿¡æ¯
    A-->>C: è¿”å›Tokenå’Œç”¨æˆ·ä¿¡æ¯
    
    Note over C,R: åç»­è¯·æ±‚æºå¸¦Token
    
    C->>A: APIè¯·æ±‚(æºå¸¦Token)
    A->>A: éªŒè¯Tokenç­¾å
    A->>R: æ£€æŸ¥ä¼šè¯çŠ¶æ€
    R-->>A: è¿”å›ä¼šè¯ä¿¡æ¯
    A-->>C: è¿”å›APIå“åº”
```

#### æƒé™æ§åˆ¶

**è§’è‰²å®šä¹‰ï¼š**

```python
# models/user.py
class UserRole(str, Enum):
    SUPER_ADMIN = "super_admin"  # è¶…çº§ç®¡ç†å‘˜
    ADMIN = "admin"              # ç®¡ç†å‘˜
    USER = "user"                # æ™®é€šç”¨æˆ·

# æƒé™æ˜ å°„
ROLE_PERMISSIONS = {
    UserRole.SUPER_ADMIN: [
        "user:*", "application:*", "license:*", 
        "device:*", "system:*", "audit:*"
    ],
    UserRole.ADMIN: [
        "user:read", "user:create", "user:update",
        "application:*", "license:*", "device:*",
        "audit:read"
    ],
    UserRole.USER: [
        "user:read:self", "license:read", "device:read"
    ]
}
```

**æƒé™è£…é¥°å™¨ï¼š**

```python
# decorators/auth.py
from functools import wraps
from fastapi import HTTPException, status

def require_permission(permission: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # ä»è¯·æ±‚ä¸­è·å–å½“å‰ç”¨æˆ·
            current_user = kwargs.get('current_user')
            if not current_user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="æœªè®¤è¯"
                )
            
            # æ£€æŸ¥æƒé™
            if not has_permission(current_user.role, permission):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="æƒé™ä¸è¶³"
                )
            
            return await func(*args, **kwargs)
        return wrapper
    return decorator

def has_permission(user_role: UserRole, required_permission: str) -> bool:
    """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å…·æœ‰æŒ‡å®šæƒé™"""
    user_permissions = ROLE_PERMISSIONS.get(user_role, [])
    
    for permission in user_permissions:
        if permission == "*" or permission == required_permission:
            return True
        
        # æ”¯æŒé€šé…ç¬¦æƒé™
        if permission.endswith(":*"):
            prefix = permission[:-2]
            if required_permission.startswith(prefix + ":"):
                return True
    
    return False
```

### 3.2 åº”ç”¨ç®¡ç†æ¨¡å—

#### åº”ç”¨ç”Ÿå‘½å‘¨æœŸ

```mermaid
stateDiagram-v2
    [*] --> åˆ›å»ºä¸­
    åˆ›å»ºä¸­ --> æ´»è·ƒ
    æ´»è·ƒ --> ç»´æŠ¤ä¸­
    ç»´æŠ¤ä¸­ --> æ´»è·ƒ
    æ´»è·ƒ --> åœç”¨
    åœç”¨ --> æ´»è·ƒ
    åœç”¨ --> [*]
    
    note right of æ´»è·ƒ
        æ­£å¸¸æä¾›æœåŠ¡
        å¯ä»¥æ¿€æ´»å¡å¯†
    end note
    
    note right of ç»´æŠ¤ä¸­
        æš‚åœæ–°æ¿€æ´»
        ç°æœ‰æˆæƒç»§ç»­æœ‰æ•ˆ
    end note
    
    note right of åœç”¨
        åœæ­¢æ‰€æœ‰æœåŠ¡
        æ’¤é”€æ‰€æœ‰æˆæƒ
    end note
```

#### åº”ç”¨é…ç½®ç®¡ç†

```python
# schemas/application.py
class ApplicationSettings(BaseModel):
    """åº”ç”¨è®¾ç½®"""
    max_devices_per_license: int = 1
    allow_device_transfer: bool = False
    require_online_verification: bool = True
    verification_interval_hours: int = 24
    auto_ban_on_violation: bool = True
    webhook_events: List[str] = []
    custom_fields: Dict[str, Any] = {}
    
    # å®‰å…¨è®¾ç½®
    ip_whitelist: List[str] = []
    allowed_countries: List[str] = []
    block_vpn: bool = False
    
    # åŠŸèƒ½å¼€å…³
    enable_device_binding: bool = True
    enable_time_limit: bool = True
    enable_usage_tracking: bool = True

class Application(BaseModel):
    id: int
    name: str
    description: Optional[str]
    version: str
    status: ApplicationStatus
    webhook_url: Optional[str]
    settings: ApplicationSettings
    created_at: datetime
    updated_at: datetime
    
    # ç»Ÿè®¡ä¿¡æ¯
    total_licenses: int = 0
    active_licenses: int = 0
    total_devices: int = 0
```

#### Webhooké›†æˆ

```python
# services/webhook.py
class WebhookService:
    """WebhookæœåŠ¡"""
    
    async def send_webhook(self, app_id: int, event: str, data: dict):
        """å‘é€Webhooké€šçŸ¥"""
        app = await self.get_application(app_id)
        if not app.webhook_url:
            return
        
        payload = {
            "event": event,
            "timestamp": datetime.utcnow().isoformat(),
            "application_id": app_id,
            "data": data
        }
        
        # æ·»åŠ ç­¾å
        signature = self._generate_signature(payload, app.webhook_secret)
        headers = {
            "Content-Type": "application/json",
            "X-Webhook-Signature": signature,
            "User-Agent": "GoldfishLicense-Webhook/1.0"
        }
        
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.post(
                    app.webhook_url,
                    json=payload,
                    headers=headers
                )
                
                # è®°å½•Webhookè°ƒç”¨æ—¥å¿—
                await self._log_webhook_call(
                    app_id, event, response.status_code, 
                    response.text[:1000]
                )
                
        except Exception as e:
            logger.error(f"Webhookè°ƒç”¨å¤±è´¥: {e}")
            await self._log_webhook_call(
                app_id, event, 0, str(e)
            )
    
    def _generate_signature(self, payload: dict, secret: str) -> str:
        """ç”ŸæˆWebhookç­¾å"""
        import hmac
        import hashlib
        
        message = json.dumps(payload, sort_keys=True)
        signature = hmac.new(
            secret.encode(),
            message.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return f"sha256={signature}"
```

### 3.3 å¡å¯†ç®¡ç†ç³»ç»Ÿ

#### å¡å¯†ç”Ÿæˆç®—æ³•

```python
# services/license_generator.py
class LicenseGenerator:
    """å¡å¯†ç”Ÿæˆå™¨"""
    
    def __init__(self):
        self.charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
        self.segment_length = 4
        self.segments = 4
    
    def generate_license_key(self, app_id: int, license_type: str) -> str:
        """ç”Ÿæˆå¡å¯†"""
        # ç”Ÿæˆéšæœºéƒ¨åˆ†
        random_part = self._generate_random_string()
        
        # æ·»åŠ æ ¡éªŒç 
        checksum = self._calculate_checksum(random_part, app_id)
        
        # ç»„åˆæœ€ç»ˆå¡å¯†
        license_key = f"{random_part}-{checksum}"
        
        return license_key
    
    def _generate_random_string(self) -> str:
        """ç”Ÿæˆéšæœºå­—ç¬¦ä¸²"""
        segments = []
        for _ in range(self.segments):
            segment = ''.join(
                secrets.choice(self.charset) 
                for _ in range(self.segment_length)
            )
            segments.append(segment)
        
        return '-'.join(segments)
    
    def _calculate_checksum(self, key: str, app_id: int) -> str:
        """è®¡ç®—æ ¡éªŒç """
        import hashlib
        
        # ç»„åˆé”®å€¼å’Œåº”ç”¨ID
        data = f"{key}-{app_id}"
        
        # è®¡ç®—MD5å“ˆå¸Œ
        hash_obj = hashlib.md5(data.encode())
        hash_hex = hash_obj.hexdigest()
        
        # å–å‰4ä½å¹¶è½¬æ¢ä¸ºå¤§å†™å­—æ¯å’Œæ•°å­—
        checksum = ''.join(
            self.charset[int(hash_hex[i:i+2], 16) % len(self.charset)]
            for i in range(0, 8, 2)
        )
        
        return checksum
    
    def validate_license_key(self, license_key: str, app_id: int) -> bool:
        """éªŒè¯å¡å¯†æ ¼å¼"""
        try:
            parts = license_key.split('-')
            if len(parts) != self.segments + 1:
                return False
            
            # é‡æ–°è®¡ç®—æ ¡éªŒç 
            random_part = '-'.join(parts[:-1])
            expected_checksum = self._calculate_checksum(random_part, app_id)
            
            return parts[-1] == expected_checksum
            
        except Exception:
            return False
```

#### æ‰¹é‡æ“ä½œ

```python
# services/license_batch.py
class LicenseBatchService:
    """å¡å¯†æ‰¹é‡æ“ä½œæœåŠ¡"""
    
    async def batch_generate(self, request: BatchGenerateRequest) -> BatchResult:
        """æ‰¹é‡ç”Ÿæˆå¡å¯†"""
        results = []
        errors = []
        
        # åˆ†æ‰¹å¤„ç†ï¼Œé¿å…å†…å­˜æº¢å‡º
        batch_size = 1000
        total_batches = (request.quantity + batch_size - 1) // batch_size
        
        for batch_num in range(total_batches):
            start_idx = batch_num * batch_size
            end_idx = min(start_idx + batch_size, request.quantity)
            batch_quantity = end_idx - start_idx
            
            try:
                batch_licenses = await self._generate_batch(
                    request.application_id,
                    request.license_type,
                    batch_quantity,
                    request.expires_at
                )
                results.extend(batch_licenses)
                
            except Exception as e:
                error_msg = f"æ‰¹æ¬¡ {batch_num + 1} ç”Ÿæˆå¤±è´¥: {str(e)}"
                errors.append(error_msg)
                logger.error(error_msg)
        
        return BatchResult(
            total_requested=request.quantity,
            total_generated=len(results),
            licenses=results,
            errors=errors
        )
    
    async def _generate_batch(
        self, 
        app_id: int, 
        license_type: str, 
        quantity: int,
        expires_at: Optional[datetime]
    ) -> List[License]:
        """ç”Ÿæˆå•ä¸ªæ‰¹æ¬¡çš„å¡å¯†"""
        licenses = []
        
        # ç”Ÿæˆå¡å¯†æ•°æ®
        for _ in range(quantity):
            license_key = self.generator.generate_license_key(app_id, license_type)
            
            license_data = {
                "license_key": license_key,
                "application_id": app_id,
                "license_type": license_type,
                "status": "inactive",
                "expires_at": expires_at,
                "created_at": datetime.utcnow()
            }
            
            licenses.append(license_data)
        
        # æ‰¹é‡æ’å…¥æ•°æ®åº“
        async with self.db.begin() as transaction:
            try:
                result = await self.db.execute(
                    insert(License).values(licenses)
                )
                await transaction.commit()
                
                # è¿”å›ç”Ÿæˆçš„å¡å¯†å¯¹è±¡
                return await self._fetch_generated_licenses(
                    [data["license_key"] for data in licenses]
                )
                
            except Exception as e:
                await transaction.rollback()
                raise e
```

### 3.4 è®¾å¤‡ç»‘å®šæœºåˆ¶

#### ç¡¬ä»¶æŒ‡çº¹ç®—æ³•

```python
# utils/hardware_fingerprint.py
class HardwareFingerprint:
    """ç¡¬ä»¶æŒ‡çº¹ç”Ÿæˆå™¨"""
    
    @staticmethod
    def generate_device_id(hardware_info: dict) -> str:
        """ç”Ÿæˆè®¾å¤‡ID"""
        # æå–å…³é”®ç¡¬ä»¶ä¿¡æ¯
        key_components = [
            hardware_info.get('cpu_id', ''),
            hardware_info.get('motherboard_serial', ''),
            hardware_info.get('disk_serial', ''),
            hardware_info.get('mac_address', ''),
            hardware_info.get('bios_uuid', '')
        ]
        
        # è¿‡æ»¤ç©ºå€¼
        key_components = [comp for comp in key_components if comp]
        
        if not key_components:
            raise ValueError("æ— æ³•è·å–æœ‰æ•ˆçš„ç¡¬ä»¶ä¿¡æ¯")
        
        # ç”ŸæˆæŒ‡çº¹
        combined = '|'.join(sorted(key_components))
        fingerprint = hashlib.sha256(combined.encode()).hexdigest()
        
        return fingerprint[:32].upper()
    
    @staticmethod
    def calculate_similarity(device1: dict, device2: dict) -> float:
        """è®¡ç®—è®¾å¤‡ç›¸ä¼¼åº¦"""
        components = ['cpu_id', 'motherboard_serial', 'disk_serial', 'mac_address']
        
        matches = 0
        total = 0
        
        for component in components:
            val1 = device1.get(component)
            val2 = device2.get(component)
            
            if val1 and val2:
                total += 1
                if val1 == val2:
                    matches += 1
        
        return matches / total if total > 0 else 0.0
    
    @staticmethod
    def is_device_changed(old_info: dict, new_info: dict, threshold: float = 0.7) -> bool:
        """æ£€æµ‹è®¾å¤‡æ˜¯å¦å‘ç”Ÿé‡å¤§å˜æ›´"""
        similarity = HardwareFingerprint.calculate_similarity(old_info, new_info)
        return similarity < threshold
```

#### è®¾å¤‡éªŒè¯æµç¨‹

```python
# services/device_verification.py
class DeviceVerificationService:
    """è®¾å¤‡éªŒè¯æœåŠ¡"""
    
    async def verify_device(
        self, 
        license_key: str, 
        device_info: DeviceInfo
    ) -> VerificationResult:
        """éªŒè¯è®¾å¤‡"""
        # 1. éªŒè¯å¡å¯†
        license = await self.license_service.get_by_key(license_key)
        if not license or license.status != 'active':
            return VerificationResult(
                success=False,
                error_code="INVALID_LICENSE",
                message="æ— æ•ˆçš„å¡å¯†"
            )
        
        # 2. æ£€æŸ¥å¡å¯†æ˜¯å¦è¿‡æœŸ
        if license.expires_at and license.expires_at < datetime.utcnow():
            return VerificationResult(
                success=False,
                error_code="LICENSE_EXPIRED",
                message="å¡å¯†å·²è¿‡æœŸ"
            )
        
        # 3. ç”Ÿæˆè®¾å¤‡ID
        device_id = HardwareFingerprint.generate_device_id(
            device_info.hardware_info
        )
        
        # 4. æ£€æŸ¥è®¾å¤‡æ˜¯å¦å·²ç»‘å®š
        existing_device = await self.device_service.get_by_device_id(device_id)
        
        if existing_device:
            # è®¾å¤‡å·²å­˜åœ¨ï¼ŒéªŒè¯æ˜¯å¦ç»‘å®šåˆ°å½“å‰å¡å¯†
            if existing_device.license_id != license.id:
                return VerificationResult(
                    success=False,
                    error_code="DEVICE_BOUND_TO_OTHER_LICENSE",
                    message="è®¾å¤‡å·²ç»‘å®šåˆ°å…¶ä»–å¡å¯†"
                )
            
            # æ›´æ–°è®¾å¤‡ä¿¡æ¯
            await self._update_device_info(existing_device, device_info)
            
        else:
            # æ–°è®¾å¤‡ï¼Œæ£€æŸ¥å¡å¯†è®¾å¤‡æ•°é‡é™åˆ¶
            device_count = await self.device_service.count_by_license(license.id)
            
            if device_count >= license.max_devices:
                return VerificationResult(
                    success=False,
                    error_code="MAX_DEVICES_EXCEEDED",
                    message=f"è¶…å‡ºæœ€å¤§è®¾å¤‡æ•°é‡é™åˆ¶({license.max_devices})"
                )
            
            # åˆ›å»ºæ–°è®¾å¤‡è®°å½•
            await self._create_device_record(license.id, device_id, device_info)
        
        # 5. è®°å½•éªŒè¯æ—¥å¿—
        await self._log_verification(license.id, device_id, "SUCCESS")
        
        return VerificationResult(
            success=True,
            device_id=device_id,
            license_info=license
        )
    
    async def _detect_device_changes(
        self, 
        device: Device, 
        new_info: DeviceInfo
    ) -> List[str]:
        """æ£€æµ‹è®¾å¤‡å˜æ›´"""
        changes = []
        
        # æ£€æŸ¥ç¡¬ä»¶å˜æ›´
        if HardwareFingerprint.is_device_changed(
            device.hardware_info, 
            new_info.hardware_info
        ):
            changes.append("ç¡¬ä»¶é…ç½®å‘ç”Ÿé‡å¤§å˜æ›´")
        
        # æ£€æŸ¥æ“ä½œç³»ç»Ÿå˜æ›´
        if device.os_info != new_info.os_info:
            changes.append(f"æ“ä½œç³»ç»Ÿå˜æ›´: {device.os_info} -> {new_info.os_info}")
        
        # æ£€æŸ¥è®¾å¤‡åç§°å˜æ›´
        if device.device_name != new_info.device_name:
            changes.append(f"è®¾å¤‡åç§°å˜æ›´: {device.device_name} -> {new_info.device_name}")
        
        return changes
```

### 3.5 åº”ç”¨å…¬å‘ŠåŠŸèƒ½

#### å…¬å‘Šç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    subgraph "å…¬å‘Šç®¡ç†"
        A[å…¬å‘Šåˆ›å»º]
        B[å…¬å‘Šç¼–è¾‘]
        C[å…¬å‘Šå‘å¸ƒ]
        D[å…¬å‘Šå½’æ¡£]
    end
    
    subgraph "ç›®æ ‡ç®¡ç†"
        E[ç”¨æˆ·ç­›é€‰]
        F[åº”ç”¨ç­›é€‰]
        G[è§’è‰²ç­›é€‰]
        H[è‡ªå®šä¹‰æ¡ä»¶]
    end
    
    subgraph "æ¨é€æ¸ é“"
        I[Webé€šçŸ¥]
        J[é‚®ä»¶æ¨é€]
        K[çŸ­ä¿¡æ¨é€]
        L[WebSocketå®æ—¶]
    end
    
    subgraph "æ•ˆæœç»Ÿè®¡"
        M[é˜…è¯»ç»Ÿè®¡]
        N[ç‚¹å‡»ç»Ÿè®¡]
        O[è½¬åŒ–ç»Ÿè®¡]
        P[åé¦ˆæ”¶é›†]
    end
    
    A --> E
    B --> F
    C --> G
    D --> H
    
    E --> I
    F --> J
    G --> K
    H --> L
    
    I --> M
    J --> N
    K --> O
    L --> P
```

#### å…¬å‘Šæ•°æ®æ¨¡å‹

```python
# models/announcement.py
class AnnouncementType(str, Enum):
    INFO = "info"        # ä¿¡æ¯å…¬å‘Š
    WARNING = "warning"  # è­¦å‘Šå…¬å‘Š
    ERROR = "error"      # é”™è¯¯å…¬å‘Š
    SUCCESS = "success"  # æˆåŠŸå…¬å‘Š
    MAINTENANCE = "maintenance"  # ç»´æŠ¤å…¬å‘Š

class AnnouncementPriority(str, Enum):
    LOW = "low"          # ä½ä¼˜å…ˆçº§
    MEDIUM = "medium"    # ä¸­ä¼˜å…ˆçº§
    HIGH = "high"        # é«˜ä¼˜å…ˆçº§
    URGENT = "urgent"    # ç´§æ€¥

class AnnouncementStatus(str, Enum):
    DRAFT = "draft"          # è‰ç¨¿
    SCHEDULED = "scheduled"  # å·²å®‰æ’
    PUBLISHED = "published"  # å·²å‘å¸ƒ
    EXPIRED = "expired"      # å·²è¿‡æœŸ
    ARCHIVED = "archived"    # å·²å½’æ¡£

class Announcement(BaseModel):
    id: int
    title: str
    content: str
    type: AnnouncementType
    priority: AnnouncementPriority
    status: AnnouncementStatus
    
    # ç›®æ ‡è®¾ç½®
    target_type: str  # 'all', 'users', 'applications', 'roles'
    target_ids: List[int] = []
    
    # æ˜¾ç¤ºè®¾ç½®
    display_type: str  # 'banner', 'modal', 'notification'
    is_sticky: bool = False
    is_dismissible: bool = True
    
    # æ—¶é—´è®¾ç½®
    publish_at: Optional[datetime]
    expires_at: Optional[datetime]
    
    # é™„ä»¶
    attachments: List[AnnouncementAttachment] = []
    
    # ç»Ÿè®¡ä¿¡æ¯
    view_count: int = 0
    click_count: int = 0
    
    # å…ƒæ•°æ®
    created_by: int
    created_at: datetime
    updated_at: datetime

class AnnouncementAttachment(BaseModel):
    id: int
    announcement_id: int
    filename: str
    file_url: str
    file_size: int
    mime_type: str
    created_at: datetime
```

#### å…¬å‘Šæ¨é€æœåŠ¡

```python
# services/announcement_push.py
class AnnouncementPushService:
    """å…¬å‘Šæ¨é€æœåŠ¡"""
    
    def __init__(self):
        self.notification_service = NotificationService()
        self.email_service = EmailService()
        self.websocket_manager = WebSocketManager()
    
    async def push_announcement(self, announcement: Announcement):
        """æ¨é€å…¬å‘Š"""
        # 1. è·å–ç›®æ ‡ç”¨æˆ·åˆ—è¡¨
        target_users = await self._get_target_users(announcement)
        
        # 2. æ ¹æ®ä¼˜å…ˆçº§é€‰æ‹©æ¨é€æ¸ é“
        channels = self._get_push_channels(announcement.priority)
        
        # 3. æ‰¹é‡æ¨é€
        tasks = []
        
        for channel in channels:
            if channel == 'websocket':
                tasks.append(self._push_websocket(announcement, target_users))
            elif channel == 'email':
                tasks.append(self._push_email(announcement, target_users))
            elif channel == 'notification':
                tasks.append(self._push_notification(announcement, target_users))
        
        # å¹¶å‘æ‰§è¡Œæ¨é€ä»»åŠ¡
        await asyncio.gather(*tasks, return_exceptions=True)
        
        # 4. è®°å½•æ¨é€æ—¥å¿—
        await self._log_push_result(announcement.id, target_users, channels)
    
    async def _get_target_users(self, announcement: Announcement) -> List[User]:
        """è·å–ç›®æ ‡ç”¨æˆ·"""
        if announcement.target_type == 'all':
            return await self.user_service.get_all_active_users()
        
        elif announcement.target_type == 'users':
            return await self.user_service.get_users_by_ids(announcement.target_ids)
        
        elif announcement.target_type == 'roles':
            return await self.user_service.get_users_by_roles(announcement.target_ids)
        
        elif announcement.target_type == 'applications':
            # è·å–ä½¿ç”¨æŒ‡å®šåº”ç”¨çš„ç”¨æˆ·
            return await self.user_service.get_users_by_applications(
                announcement.target_ids
            )
        
        return []
    
    def _get_push_channels(self, priority: AnnouncementPriority) -> List[str]:
        """æ ¹æ®ä¼˜å…ˆçº§è·å–æ¨é€æ¸ é“"""
        channel_map = {
            AnnouncementPriority.LOW: ['notification'],
            AnnouncementPriority.MEDIUM: ['notification', 'websocket'],
            AnnouncementPriority.HIGH: ['notification', 'websocket', 'email'],
            AnnouncementPriority.URGENT: ['notification', 'websocket', 'email', 'sms']
        }
        
        return channel_map.get(priority, ['notification'])
    
    async def _push_websocket(self, announcement: Announcement, users: List[User]):
        """WebSocketæ¨é€"""
        message = {
            "type": "announcement",
            "data": {
                "id": announcement.id,
                "title": announcement.title,
                "content": announcement.content,
                "type": announcement.type,
                "priority": announcement.priority,
                "display_type": announcement.display_type
            }
        }
        
        for user in users:
            await self.websocket_manager.send_to_user(user.id, message)
    
    async def _push_notification(self, announcement: Announcement, users: List[User]):
        """åº”ç”¨å†…é€šçŸ¥æ¨é€"""
        for user in users:
            await self.notification_service.create_notification(
                user_id=user.id,
                title=announcement.title,
                content=announcement.content[:200],  # é™åˆ¶é•¿åº¦
                type=announcement.type,
                data={
                    "announcement_id": announcement.id,
                    "action_url": f"/announcements/{announcement.id}"
                }
            )
```

### 3.6 å®æ—¶é€šçŸ¥ç³»ç»Ÿ

#### WebSocketè¿æ¥ç®¡ç†

```python
# services/websocket_manager.py
class WebSocketManager:
    """WebSocketè¿æ¥ç®¡ç†å™¨"""
    
    def __init__(self):
        # ç”¨æˆ·è¿æ¥æ˜ å°„ {user_id: [websocket1, websocket2, ...]}
        self.user_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # åº”ç”¨è¿æ¥æ˜ å°„ {app_id: [websocket1, websocket2, ...]}
        self.app_connections: Dict[int, List[WebSocket]] = defaultdict(list)
        
        # è¿æ¥å…ƒæ•°æ® {websocket: ConnectionInfo}
        self.connection_info: Dict[WebSocket, ConnectionInfo] = {}
        
        # è¿æ¥ç»Ÿè®¡
        self.stats = {
            "total_connections": 0,
            "user_connections": 0,
            "app_connections": 0,
            "messages_sent": 0,
            "messages_received": 0
        }
    
    async def connect_user(self, websocket: WebSocket, user_id: int, token: str):
        """ç”¨æˆ·è¿æ¥"""
        await websocket.accept()
        
        # éªŒè¯token
        if not await self._verify_token(token, user_id):
            await websocket.close(code=4001, reason="Invalid token")
            return
        
        # æ·»åŠ è¿æ¥
        self.user_connections[user_id].append(websocket)
        self.connection_info[websocket] = ConnectionInfo(
            type="user",
            user_id=user_id,
            connected_at=datetime.utcnow(),
            last_ping=datetime.utcnow()
        )
        
        self.stats["total_connections"] += 1
        self.stats["user_connections"] += 1
        
        logger.info(f"ç”¨æˆ· {user_id} WebSocketè¿æ¥å»ºç«‹")
        
        # å‘é€è¿æ¥ç¡®è®¤
        await self.send_to_websocket(websocket, {
            "type": "connection_established",
            "user_id": user_id,
            "timestamp": datetime.utcnow().isoformat()
        })
    
    async def connect_application(
        self, 
        websocket: WebSocket, 
        app_id: int, 
        api_key: str
    ):
        """åº”ç”¨è¿æ¥"""
        await websocket.accept()
        
        # éªŒè¯APIå¯†é’¥
        if not await self._verify_api_key(api_key, app_id):
            await websocket.close(code=4001, reason="Invalid API key")
            return
        
        # æ·»åŠ è¿æ¥
        self.app_connections[app_id].append(websocket)
        self.connection_info[websocket] = ConnectionInfo(
            type="application",
            app_id=app_id,
            connected_at=datetime.utcnow(),
            last_ping=datetime.utcnow()
        )
        
        self.stats["total_connections"] += 1
        self.stats["app_connections"] += 1
        
        logger.info(f"åº”ç”¨ {app_id} WebSocketè¿æ¥å»ºç«‹")
    
    async def disconnect(self, websocket: WebSocket):
        """æ–­å¼€è¿æ¥"""
        if websocket not in self.connection_info:
            return
        
        conn_info = self.connection_info[websocket]
        
        # ä»è¿æ¥æ˜ å°„ä¸­ç§»é™¤
        if conn_info.type == "user" and conn_info.user_id:
            self.user_connections[conn_info.user_id].remove(websocket)
            if not self.user_connections[conn_info.user_id]:
                del self.user_connections[conn_info.user_id]
            self.stats["user_connections"] -= 1
            
        elif conn_info.type == "application" and conn_info.app_id:
            self.app_connections[conn_info.app_id].remove(websocket)
            if not self.app_connections[conn_info.app_id]:
                del self.app_connections[conn_info.app_id]
            self.stats["app_connections"] -= 1
        
        # ç§»é™¤è¿æ¥ä¿¡æ¯
        del self.connection_info[websocket]
        self.stats["total_connections"] -= 1
        
        logger.info(f"WebSocketè¿æ¥æ–­å¼€: {conn_info.type}")
    
    async def send_to_user(self, user_id: int, message: dict):
        """å‘é€æ¶ˆæ¯ç»™æŒ‡å®šç”¨æˆ·"""
        if user_id not in self.user_connections:
            return
        
        # å‘é€ç»™ç”¨æˆ·çš„æ‰€æœ‰è¿æ¥
        disconnected = []
        for websocket in self.user_connections[user_id]:
            try:
                await self.send_to_websocket(websocket, message)
            except Exception as e:
                logger.error(f"å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
                disconnected.append(websocket)
        
        # æ¸…ç†æ–­å¼€çš„è¿æ¥
        for websocket in disconnected:
            await self.disconnect(websocket)
    
    async def send_to_application(self, app_id: int, message: dict):
        """å‘é€æ¶ˆæ¯ç»™æŒ‡å®šåº”ç”¨"""
        if app_id not in self.app_connections:
            return
        
        disconnected = []
        for websocket in self.app_connections[app_id]:
            try:
                await self.send_to_websocket(websocket, message)
            except Exception as e:
                logger.error(f"å‘é€æ¶ˆæ¯å¤±è´¥: {e}")
                disconnected.append(websocket)
        
        # æ¸…ç†æ–­å¼€çš„è¿æ¥
        for websocket in disconnected:
            await self.disconnect(websocket)
    
    async def broadcast_to_all(self, message: dict):
        """å¹¿æ’­æ¶ˆæ¯ç»™æ‰€æœ‰è¿æ¥"""
        all_websockets = list(self.connection_info.keys())
        
        tasks = [
            self.send_to_websocket(ws, message) 
            for ws in all_websockets
        ]
        
        # å¹¶å‘å‘é€
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # ç»Ÿè®¡å‘é€ç»“æœ
        success_count = sum(1 for r in results if not isinstance(r, Exception))
        error_count = len(results) - success_count
        
        logger.info(f"å¹¿æ’­æ¶ˆæ¯å®Œæˆ: æˆåŠŸ {success_count}, å¤±è´¥ {error_count}")
    
    async def send_to_websocket(self, websocket: WebSocket, message: dict):
        """å‘é€æ¶ˆæ¯åˆ°WebSocket"""
        try:
            await websocket.send_json(message)
            self.stats["messages_sent"] += 1
        except Exception as e:
            logger.error(f"WebSocketå‘é€å¤±è´¥: {e}")
            raise
    
    async def handle_ping(self, websocket: WebSocket):
        """å¤„ç†å¿ƒè·³"""
        if websocket in self.connection_info:
            self.connection_info[websocket].last_ping = datetime.utcnow()
            await self.send_to_websocket(websocket, {"type": "pong"})
    
    async def cleanup_stale_connections(self):
        """æ¸…ç†è¿‡æœŸè¿æ¥"""
        now = datetime.utcnow()
        stale_connections = []
        
        for websocket, info in self.connection_info.items():
            # è¶…è¿‡5åˆ†é’Ÿæ²¡æœ‰å¿ƒè·³çš„è¿æ¥è§†ä¸ºè¿‡æœŸ
            if (now - info.last_ping).total_seconds() > 300:
                stale_connections.append(websocket)
        
        for websocket in stale_connections:
            await self.disconnect(websocket)
            try:
                await websocket.close(code=4000, reason="Connection timeout")
            except Exception:
                pass
        
        if stale_connections:
            logger.info(f"æ¸…ç†äº† {len(stale_connections)} ä¸ªè¿‡æœŸè¿æ¥")
```

---

## 4. æ¨¡å—è”åŠ¨æœºåˆ¶

### 4.1 äº‹ä»¶é©±åŠ¨æ¶æ„

#### äº‹ä»¶æ€»çº¿è®¾è®¡

```python
# core/event_bus.py
class EventBus:
    """äº‹ä»¶æ€»çº¿"""
    
    def __init__(self):
        self._handlers: Dict[str, List[Callable]] = defaultdict(list)
        self._middleware: List[Callable] = []
        self._logger = logging.getLogger(__name__)
    
    def subscribe(self, event_type: str, handler: Callable):
        """è®¢é˜…äº‹ä»¶"""
        self._handlers[event_type].append(handler)
        self._logger.debug(f"è®¢é˜…äº‹ä»¶: {event_type} -> {handler.__name__}")
    
    def unsubscribe(self, event_type: str, handler: Callable):
        """å–æ¶ˆè®¢é˜…"""
        if handler in self._handlers[event_type]:
            self._handlers[event_type].remove(handler)
            self._logger.debug(f"å–æ¶ˆè®¢é˜…: {event_type} -> {handler.__name__}")
    
    async def publish(self, event: Event):
        """å‘å¸ƒäº‹ä»¶"""
        self._logger.info(f"å‘å¸ƒäº‹ä»¶: {event.type} - {event.data}")
        
        # æ‰§è¡Œä¸­é—´ä»¶
        for middleware in self._middleware:
            event = await middleware(event)
            if event is None:
                return  # ä¸­é—´ä»¶æ‹¦æˆªäº†äº‹ä»¶
        
        # æ‰§è¡Œäº‹ä»¶å¤„ç†å™¨
        handlers = self._handlers.get(event.type, [])
        
        if not handlers:
            self._logger.warning(f"æ²¡æœ‰æ‰¾åˆ°äº‹ä»¶å¤„ç†å™¨: {event.type}")
            return
        
        # å¹¶å‘æ‰§è¡Œæ‰€æœ‰å¤„ç†å™¨
        tasks = [self._execute_handler(handler, event) for handler in handlers]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # è®°å½•æ‰§è¡Œç»“æœ
        success_count = sum(1 for r in results if not isinstance(r, Exception))
        error_count = len(results) - success_count
        
        self._logger.info(
            f"äº‹ä»¶å¤„ç†å®Œæˆ: {event.type} - æˆåŠŸ: {success_count}, å¤±è´¥: {error_count}"
        )
        
        # è®°å½•é”™è¯¯
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                handler_name = handlers[i].__name__
                self._logger.error(
                    f"äº‹ä»¶å¤„ç†å™¨æ‰§è¡Œå¤±è´¥: {handler_name} - {result}"
                )
    
    async def _execute_handler(self, handler: Callable, event: Event):
        """æ‰§è¡Œäº‹ä»¶å¤„ç†å™¨"""
        try:
            if asyncio.iscoroutinefunction(handler):
                await handler(event)
            else:
                handler(event)
        except Exception as e:
            self._logger.error(f"äº‹ä»¶å¤„ç†å™¨å¼‚å¸¸: {handler.__name__} - {e}")
            raise
    
    def add_middleware(self, middleware: Callable):
        """æ·»åŠ ä¸­é—´ä»¶"""
        self._middleware.append(middleware)

# å…¨å±€äº‹ä»¶æ€»çº¿å®ä¾‹
event_bus = EventBus()
```

#### äº‹ä»¶å®šä¹‰

```python
# events/base.py
class Event:
    """åŸºç¡€äº‹ä»¶ç±»"""
    
    def __init__(self, event_type: str, data: dict, source: str = None):
        self.type = event_type
        self.data = data
        self.source = source or "system"
        self.timestamp = datetime.utcnow()
        self.id = str(uuid.uuid4())
    
    def to_dict(self) -> dict:
        return {
            "id": self.id,
            "type": self.type,
            "data": self.data,
            "source": self.source,
            "timestamp": self.timestamp.isoformat()
        }

# events/license_events.py
class LicenseActivatedEvent(Event):
    """å¡å¯†æ¿€æ´»äº‹ä»¶"""
    
    def __init__(self, license_id: int, device_id: str, user_id: int = None):
        super().__init__(
            event_type="license.activated",
            data={
                "license_id": license_id,
                "device_id": device_id,
                "user_id": user_id
            }
        )

class LicenseExpiredEvent(Event):
    """å¡å¯†è¿‡æœŸäº‹ä»¶"""
    
    def __init__(self, license_id: int, license_key: str):
        super().__init__(
            event_type="license.expired",
            data={
                "license_id": license_id,
                "license_key": license_key
            }
        )

class DeviceBindingEvent(Event):
    """è®¾å¤‡ç»‘å®šäº‹ä»¶"""
    
    def __init__(self, device_id: str, license_id: int, action: str):
        super().__init__(
            event_type="device.binding",
            data={
                "device_id": device_id,
                "license_id": license_id,
                "action": action  # 'bind' or 'unbind'
            }
        )

# events/application_events.py
class ApplicationStatusChangedEvent(Event):
    """åº”ç”¨çŠ¶æ€å˜æ›´äº‹ä»¶"""
    
    def __init__(self, app_id: int, old_status: str, new_status: str):
        super().__init__(
            event_type="application.status_changed",
            data={
                "app_id": app_id,
                "old_status": old_status,
                "new_status": new_status
            }
        )

class ApplicationMaintenanceEvent(Event):
    """åº”ç”¨ç»´æŠ¤äº‹ä»¶"""
    
    def __init__(self, app_id: int, maintenance_type: str, message: str):
        super().__init__(
            event_type="application.maintenance",
            data={
                "app_id": app_id,
                "maintenance_type": maintenance_type,
                "message": message
            }
        )
```

#### 4.2.2 äº‹ä»¶å¤„ç†å™¨

```python
# handlers/license_handlers.py
from events.event_bus import EventBus
from services.notification_service import NotificationService
from services.announcement_service import AnnouncementService

class LicenseEventHandler:
    """å¡å¯†äº‹ä»¶å¤„ç†å™¨"""
    
    def __init__(self, notification_service: NotificationService, 
                 announcement_service: AnnouncementService):
        self.notification_service = notification_service
        self.announcement_service = announcement_service
        self._register_handlers()
    
    def _register_handlers(self):
        """æ³¨å†Œäº‹ä»¶å¤„ç†å™¨"""
        EventBus.subscribe("license.activated", self.handle_license_activated)
        EventBus.subscribe("license.expired", self.handle_license_expired)
        EventBus.subscribe("device.binding", self.handle_device_binding)
    
    async def handle_license_activated(self, event):
        """å¤„ç†å¡å¯†æ¿€æ´»äº‹ä»¶"""
        data = event.data
        
        # å‘é€æ¿€æ´»æˆåŠŸé€šçŸ¥
        await self.notification_service.send_notification(
            user_id=data.get("user_id"),
            device_id=data["device_id"],
            message=f"å¡å¯†æ¿€æ´»æˆåŠŸï¼Œè®¾å¤‡ID: {data['device_id']}",
            notification_type="license_activated"
        )
        
        # è®°å½•æ¿€æ´»æ—¥å¿—
        logger.info(f"License {data['license_id']} activated for device {data['device_id']}")
    
    async def handle_license_expired(self, event):
        """å¤„ç†å¡å¯†è¿‡æœŸäº‹ä»¶"""
        data = event.data
        
        # åˆ›å»ºè¿‡æœŸå…¬å‘Š
        await self.announcement_service.create_announcement(
            title="å¡å¯†è¿‡æœŸæé†’",
            content=f"æ‚¨çš„å¡å¯† {data['license_key']} å·²è¿‡æœŸï¼Œè¯·åŠæ—¶ç»­è´¹",
            announcement_type="warning",
            target_licenses=[data["license_id"]]
        )
        
        # å‘é€è¿‡æœŸé€šçŸ¥
        await self.notification_service.broadcast_to_license(
            license_id=data["license_id"],
            message="æ‚¨çš„å¡å¯†å·²è¿‡æœŸï¼Œè¯·è”ç³»ç®¡ç†å‘˜ç»­è´¹",
            notification_type="license_expired"
        )
    
    async def handle_device_binding(self, event):
        """å¤„ç†è®¾å¤‡ç»‘å®šäº‹ä»¶"""
        data = event.data
        action = data["action"]
        
        if action == "bind":
            message = f"è®¾å¤‡ {data['device_id']} å·²æˆåŠŸç»‘å®šåˆ°å¡å¯†"
        else:
            message = f"è®¾å¤‡ {data['device_id']} å·²è§£é™¤ç»‘å®š"
        
        await self.notification_service.send_to_device(
            device_id=data["device_id"],
            message=message,
            notification_type="device_binding"
        )

# handlers/application_handlers.py
class ApplicationEventHandler:
    """åº”ç”¨äº‹ä»¶å¤„ç†å™¨"""
    
    def __init__(self, notification_service: NotificationService):
        self.notification_service = notification_service
        self._register_handlers()
    
    def _register_handlers(self):
        EventBus.subscribe("application.status_changed", self.handle_status_changed)
        EventBus.subscribe("application.maintenance", self.handle_maintenance)
    
    async def handle_status_changed(self, event):
        """å¤„ç†åº”ç”¨çŠ¶æ€å˜æ›´äº‹ä»¶"""
        data = event.data
        
        if data["new_status"] == "maintenance":
            # åº”ç”¨è¿›å…¥ç»´æŠ¤çŠ¶æ€ï¼Œé€šçŸ¥æ‰€æœ‰ç”¨æˆ·
            await self.notification_service.broadcast_to_application(
                app_id=data["app_id"],
                message="åº”ç”¨æ­£åœ¨ç»´æŠ¤ä¸­ï¼Œæš‚æ—¶æ— æ³•ä½¿ç”¨",
                notification_type="maintenance"
            )
        elif data["old_status"] == "maintenance" and data["new_status"] == "active":
            # åº”ç”¨ç»´æŠ¤ç»“æŸ
            await self.notification_service.broadcast_to_application(
                app_id=data["app_id"],
                message="åº”ç”¨ç»´æŠ¤å®Œæˆï¼Œç°å·²æ¢å¤æ­£å¸¸ä½¿ç”¨",
                notification_type="maintenance_complete"
            )
    
    async def handle_maintenance(self, event):
        """å¤„ç†åº”ç”¨ç»´æŠ¤äº‹ä»¶"""
        data = event.data
        
        await self.notification_service.broadcast_to_application(
            app_id=data["app_id"],
            message=data["message"],
            notification_type="maintenance_notice"
        )
```

#### 4.2.3 è”åŠ¨æµç¨‹ç¤ºä¾‹

```mermaid
sequenceDiagram
    participant Client as å®¢æˆ·ç«¯
    participant Auth as è®¤è¯æœåŠ¡
    participant License as å¡å¯†æœåŠ¡
    participant Device as è®¾å¤‡æœåŠ¡
    participant Event as äº‹ä»¶æ€»çº¿
    participant Notify as é€šçŸ¥æœåŠ¡
    participant Announce as å…¬å‘ŠæœåŠ¡
    
    Client->>Auth: ç™»å½•è¯·æ±‚
    Auth->>License: éªŒè¯å¡å¯†
    License->>Device: æ£€æŸ¥è®¾å¤‡ç»‘å®š
    Device-->>License: è®¾å¤‡éªŒè¯é€šè¿‡
    License-->>Auth: å¡å¯†éªŒè¯é€šè¿‡
    Auth-->>Client: ç™»å½•æˆåŠŸ
    
    License->>Event: å‘å¸ƒå¡å¯†æ¿€æ´»äº‹ä»¶
    Event->>Notify: è§¦å‘é€šçŸ¥å¤„ç†å™¨
    Event->>Announce: è§¦å‘å…¬å‘Šå¤„ç†å™¨
    
    Notify->>Client: æ¨é€æ¿€æ´»é€šçŸ¥
    Announce->>Client: æ¨é€ç›¸å…³å…¬å‘Š
```

## 5. å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–

### 5.1 å®‰å…¨æªæ–½

#### 5.1.1 å¯†é’¥è½®æ¢æœºåˆ¶

```python
# security/key_rotation.py
import secrets
import hashlib
from datetime import datetime, timedelta
from cryptography.fernet import Fernet
from config.settings import settings

class KeyRotationManager:
    """å¯†é’¥è½®æ¢ç®¡ç†å™¨"""
    
    def __init__(self):
        self.current_key = None
        self.previous_key = None
        self.rotation_interval = timedelta(days=30)  # 30å¤©è½®æ¢ä¸€æ¬¡
        self.last_rotation = None
    
    def generate_new_key(self) -> bytes:
        """ç”Ÿæˆæ–°çš„åŠ å¯†å¯†é’¥"""
        return Fernet.generate_key()
    
    def rotate_keys(self):
        """æ‰§è¡Œå¯†é’¥è½®æ¢"""
        if self.should_rotate():
            self.previous_key = self.current_key
            self.current_key = self.generate_new_key()
            self.last_rotation = datetime.utcnow()
            
            # ä¿å­˜åˆ°å®‰å…¨å­˜å‚¨
            self._save_keys_to_storage()
            
            logger.info("Encryption keys rotated successfully")
            return True
        return False
    
    def should_rotate(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦éœ€è¦è½®æ¢å¯†é’¥"""
        if not self.last_rotation:
            return True
        
        return datetime.utcnow() - self.last_rotation > self.rotation_interval
    
    def encrypt_data(self, data: str) -> str:
        """ä½¿ç”¨å½“å‰å¯†é’¥åŠ å¯†æ•°æ®"""
        if not self.current_key:
            self.rotate_keys()
        
        fernet = Fernet(self.current_key)
        encrypted_data = fernet.encrypt(data.encode())
        return encrypted_data.decode()
    
    def decrypt_data(self, encrypted_data: str) -> str:
        """è§£å¯†æ•°æ®ï¼ˆæ”¯æŒå½“å‰å’Œå†å²å¯†é’¥ï¼‰"""
        try:
            # å°è¯•ä½¿ç”¨å½“å‰å¯†é’¥è§£å¯†
            fernet = Fernet(self.current_key)
            return fernet.decrypt(encrypted_data.encode()).decode()
        except Exception:
            if self.previous_key:
                try:
                    # å°è¯•ä½¿ç”¨å†å²å¯†é’¥è§£å¯†
                    fernet = Fernet(self.previous_key)
                    decrypted = fernet.decrypt(encrypted_data.encode()).decode()
                    
                    # ä½¿ç”¨æ–°å¯†é’¥é‡æ–°åŠ å¯†
                    self._re_encrypt_with_current_key(encrypted_data, decrypted)
                    return decrypted
                except Exception:
                    pass
            
            raise ValueError("Unable to decrypt data with available keys")
    
    def _save_keys_to_storage(self):
        """ä¿å­˜å¯†é’¥åˆ°å®‰å…¨å­˜å‚¨"""
        # å®é™…å®ç°ä¸­åº”è¯¥ä½¿ç”¨HSMæˆ–å¯†é’¥ç®¡ç†æœåŠ¡
        pass
    
    def _re_encrypt_with_current_key(self, old_encrypted: str, decrypted: str):
        """ä½¿ç”¨å½“å‰å¯†é’¥é‡æ–°åŠ å¯†æ•°æ®"""
        # å¼‚æ­¥ä»»åŠ¡ï¼šä½¿ç”¨æ–°å¯†é’¥é‡æ–°åŠ å¯†å†å²æ•°æ®
        pass

# å…¨å±€å¯†é’¥ç®¡ç†å™¨å®ä¾‹
key_manager = KeyRotationManager()
```

#### 5.1.2 APIé˜²æŠ¤ç­–ç•¥

```python
# security/api_protection.py
from fastapi import Request, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from starlette.middleware.base import BaseHTTPMiddleware
import time
import hashlib
from collections import defaultdict
from datetime import datetime, timedelta

class RateLimitMiddleware(BaseHTTPMiddleware):
    """APIé™æµä¸­é—´ä»¶"""
    
    def __init__(self, app, calls_per_minute: int = 60):
        super().__init__(app)
        self.calls_per_minute = calls_per_minute
        self.requests = defaultdict(list)
    
    async def dispatch(self, request: Request, call_next):
        client_ip = self._get_client_ip(request)
        current_time = time.time()
        
        # æ¸…ç†è¿‡æœŸè®°å½•
        self._cleanup_expired_requests(client_ip, current_time)
        
        # æ£€æŸ¥é™æµ
        if len(self.requests[client_ip]) >= self.calls_per_minute:
            raise HTTPException(
                status_code=429,
                detail="Rate limit exceeded. Please try again later."
            )
        
        # è®°å½•è¯·æ±‚
        self.requests[client_ip].append(current_time)
        
        response = await call_next(request)
        return response
    
    def _get_client_ip(self, request: Request) -> str:
        """è·å–å®¢æˆ·ç«¯IP"""
        forwarded = request.headers.get("X-Forwarded-For")
        if forwarded:
            return forwarded.split(",")[0].strip()
        return request.client.host
    
    def _cleanup_expired_requests(self, client_ip: str, current_time: float):
        """æ¸…ç†è¿‡æœŸçš„è¯·æ±‚è®°å½•"""
        minute_ago = current_time - 60
        self.requests[client_ip] = [
            req_time for req_time in self.requests[client_ip]
            if req_time > minute_ago
        ]

class APIKeyValidator:
    """APIå¯†é’¥éªŒè¯å™¨"""
    
    def __init__(self):
        self.valid_keys = set()  # å®é™…åº”ä»æ•°æ®åº“åŠ è½½
        self.key_usage = defaultdict(int)
        self.key_last_used = defaultdict(datetime)
    
    def validate_api_key(self, api_key: str) -> bool:
        """éªŒè¯APIå¯†é’¥"""
        if not api_key or api_key not in self.valid_keys:
            return False
        
        # è®°å½•ä½¿ç”¨æƒ…å†µ
        self.key_usage[api_key] += 1
        self.key_last_used[api_key] = datetime.utcnow()
        
        return True
    
    def generate_api_key(self, user_id: int) -> str:
        """ç”ŸæˆAPIå¯†é’¥"""
        timestamp = str(int(time.time()))
        random_data = secrets.token_hex(16)
        raw_key = f"{user_id}:{timestamp}:{random_data}"
        
        api_key = hashlib.sha256(raw_key.encode()).hexdigest()
        self.valid_keys.add(api_key)
        
        return api_key
    
    def revoke_api_key(self, api_key: str):
        """æ’¤é”€APIå¯†é’¥"""
        self.valid_keys.discard(api_key)
        self.key_usage.pop(api_key, None)
        self.key_last_used.pop(api_key, None)

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    """å®‰å…¨å¤´ä¸­é—´ä»¶"""
    
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        
        # æ·»åŠ å®‰å…¨å¤´
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
        
        return response
```

### 5.2 æ€§èƒ½ä¼˜åŒ–

#### 5.2.1 æ•°æ®åº“è¿æ¥æ± é…ç½®

```python
# database/connection_pool.py
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool
from config.settings import settings

class DatabaseConnectionPool:
    """æ•°æ®åº“è¿æ¥æ± ç®¡ç†å™¨"""
    
    def __init__(self):
        self.engine = self._create_engine()
    
    def _create_engine(self):
        """åˆ›å»ºæ•°æ®åº“å¼•æ“"""
        return create_engine(
            settings.DATABASE_URL,
            poolclass=QueuePool,
            pool_size=20,  # è¿æ¥æ± å¤§å°
            max_overflow=30,  # æœ€å¤§æº¢å‡ºè¿æ¥æ•°
            pool_pre_ping=True,  # è¿æ¥å‰æ£€æŸ¥
            pool_recycle=3600,  # è¿æ¥å›æ”¶æ—¶é—´ï¼ˆç§’ï¼‰
            pool_timeout=30,  # è·å–è¿æ¥è¶…æ—¶æ—¶é—´
            echo=settings.DEBUG,  # æ˜¯å¦æ‰“å°SQL
            connect_args={
                "connect_timeout": 10,
                "application_name": "license_system"
            }
        )
    
    def get_connection(self):
        """è·å–æ•°æ®åº“è¿æ¥"""
        return self.engine.connect()
    
    def get_pool_status(self):
        """è·å–è¿æ¥æ± çŠ¶æ€"""
        pool = self.engine.pool
        return {
            "size": pool.size(),
            "checked_in": pool.checkedin(),
            "checked_out": pool.checkedout(),
            "overflow": pool.overflow(),
            "invalid": pool.invalid()
        }

# å…¨å±€è¿æ¥æ± å®ä¾‹
db_pool = DatabaseConnectionPool()
```

#### 5.2.2 ç¼“å­˜ä¼˜åŒ–ç­–ç•¥

```python
# cache/cache_manager.py
import redis
import json
import pickle
from typing import Any, Optional
from datetime import timedelta
from config.settings import settings

class CacheManager:
    """ç¼“å­˜ç®¡ç†å™¨"""
    
    def __init__(self):
        self.redis_client = redis.Redis(
            host=settings.REDIS_HOST,
            port=settings.REDIS_PORT,
            password=settings.REDIS_PASSWORD,
            db=0,
            decode_responses=False,
            socket_connect_timeout=5,
            socket_timeout=5,
            retry_on_timeout=True,
            health_check_interval=30
        )
        
        # ç¼“å­˜é”®å‰ç¼€
        self.KEY_PREFIXES = {
            "license": "license:",
            "user": "user:",
            "device": "device:",
            "application": "app:",
            "session": "session:"
        }
        
        # é»˜è®¤è¿‡æœŸæ—¶é—´
        self.DEFAULT_EXPIRY = {
            "license": timedelta(hours=1),
            "user": timedelta(minutes=30),
            "device": timedelta(hours=2),
            "application": timedelta(hours=6),
            "session": timedelta(hours=24)
        }
    
    def _build_key(self, category: str, identifier: str) -> str:
        """æ„å»ºç¼“å­˜é”®"""
        prefix = self.KEY_PREFIXES.get(category, "")
        return f"{prefix}{identifier}"
    
    def set(self, category: str, identifier: str, value: Any, 
            expiry: Optional[timedelta] = None) -> bool:
        """è®¾ç½®ç¼“å­˜"""
        try:
            key = self._build_key(category, identifier)
            serialized_value = pickle.dumps(value)
            
            if expiry is None:
                expiry = self.DEFAULT_EXPIRY.get(category, timedelta(hours=1))
            
            return self.redis_client.setex(
                key, 
                int(expiry.total_seconds()), 
                serialized_value
            )
        except Exception as e:
            logger.error(f"Cache set error: {e}")
            return False
    
    def get(self, category: str, identifier: str) -> Optional[Any]:
        """è·å–ç¼“å­˜"""
        try:
            key = self._build_key(category, identifier)
            cached_value = self.redis_client.get(key)
            
            if cached_value is None:
                return None
            
            return pickle.loads(cached_value)
        except Exception as e:
            logger.error(f"Cache get error: {e}")
            return None
    
    def delete(self, category: str, identifier: str) -> bool:
        """åˆ é™¤ç¼“å­˜"""
        try:
            key = self._build_key(category, identifier)
            return bool(self.redis_client.delete(key))
        except Exception as e:
            logger.error(f"Cache delete error: {e}")
            return False
    
    def invalidate_pattern(self, pattern: str) -> int:
        """æ‰¹é‡åˆ é™¤åŒ¹é…æ¨¡å¼çš„ç¼“å­˜"""
        try:
            keys = self.redis_client.keys(pattern)
            if keys:
                return self.redis_client.delete(*keys)
            return 0
        except Exception as e:
            logger.error(f"Cache pattern invalidation error: {e}")
            return 0
    
    def get_cache_stats(self) -> dict:
        """è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯"""
        try:
            info = self.redis_client.info()
            return {
                "used_memory": info.get("used_memory_human"),
                "connected_clients": info.get("connected_clients"),
                "total_commands_processed": info.get("total_commands_processed"),
                "keyspace_hits": info.get("keyspace_hits"),
                "keyspace_misses": info.get("keyspace_misses"),
                "hit_rate": info.get("keyspace_hits", 0) / 
                           max(info.get("keyspace_hits", 0) + info.get("keyspace_misses", 0), 1)
            }
        except Exception as e:
            logger.error(f"Cache stats error: {e}")
            return {}

# å…¨å±€ç¼“å­˜ç®¡ç†å™¨å®ä¾‹
cache_manager = CacheManager()
```

#### 5.2.3 æŸ¥è¯¢æ€§èƒ½ä¼˜åŒ–

```python
# database/query_optimizer.py
from sqlalchemy import Index, text
from sqlalchemy.orm import sessionmaker
from models.license import License
from models.device import Device
from models.user import User

class QueryOptimizer:
    """æŸ¥è¯¢ä¼˜åŒ–å™¨"""
    
    @staticmethod
    def create_indexes():
        """åˆ›å»ºæ€§èƒ½ä¼˜åŒ–ç´¢å¼•"""
        indexes = [
            # å¡å¯†ç›¸å…³ç´¢å¼•
            Index('idx_license_key_status', License.license_key, License.status),
            Index('idx_license_expires_at', License.expires_at),
            Index('idx_license_created_at', License.created_at),
            Index('idx_license_app_id', License.application_id),
            
            # è®¾å¤‡ç›¸å…³ç´¢å¼•
            Index('idx_device_hardware_id', Device.hardware_id),
            Index('idx_device_license_id', Device.license_id),
            Index('idx_device_last_seen', Device.last_seen_at),
            
            # ç”¨æˆ·ç›¸å…³ç´¢å¼•
            Index('idx_user_username', User.username),
            Index('idx_user_email', User.email),
            Index('idx_user_created_at', User.created_at),
            
            # å¤åˆç´¢å¼•
            Index('idx_license_app_status_expires', 
                  License.application_id, License.status, License.expires_at),
            Index('idx_device_license_status', 
                  Device.license_id, Device.status)
        ]
        
        return indexes
    
    @staticmethod
    def optimize_license_queries():
        """ä¼˜åŒ–å¡å¯†æŸ¥è¯¢"""
        # ä½¿ç”¨åŸç”ŸSQLè¿›è¡Œå¤æ‚æŸ¥è¯¢ä¼˜åŒ–
        optimized_queries = {
            "active_licenses_by_app": text("""
                SELECT l.*, u.username 
                FROM licenses l 
                JOIN users u ON l.user_id = u.id 
                WHERE l.application_id = :app_id 
                AND l.status = 'active' 
                AND l.expires_at > NOW() 
                ORDER BY l.created_at DESC 
                LIMIT :limit OFFSET :offset
            """),
            
            "license_usage_stats": text("""
                SELECT 
                    l.application_id,
                    COUNT(*) as total_licenses,
                    COUNT(CASE WHEN l.status = 'active' THEN 1 END) as active_licenses,
                    COUNT(CASE WHEN l.expires_at < NOW() THEN 1 END) as expired_licenses,
                    AVG(EXTRACT(EPOCH FROM (l.expires_at - l.created_at))/86400) as avg_duration_days
                FROM licenses l 
                GROUP BY l.application_id
            ""),
            
            "device_binding_summary": text("""
                SELECT 
                    d.license_id,
                    COUNT(*) as device_count,
                    MAX(d.last_seen_at) as last_activity,
                    STRING_AGG(d.hardware_id, ',') as device_ids
                FROM devices d 
                WHERE d.status = 'active' 
                GROUP BY d.license_id
                HAVING COUNT(*) > 0
            """)
        }
        
        return optimized_queries

# æŸ¥è¯¢ä¼˜åŒ–å™¨å®ä¾‹
query_optimizer = QueryOptimizer()
```

## 6. APIæ¥å£è§„èŒƒ

### 6.1 RESTful APIè®¾è®¡

#### 6.1.1 æ¥å£å‘½åè§„èŒƒ

```python
# api/v1/routes.py
from fastapi import APIRouter, Depends, HTTPException, Query
from typing import List, Optional
from schemas.license import LicenseResponse, CreateLicenseRequest
from schemas.common import PaginationParams, ResponseModel

# APIç‰ˆæœ¬å‰ç¼€
API_V1_PREFIX = "/api/v1"

# è·¯ç”±å®šä¹‰
router = APIRouter(prefix=API_V1_PREFIX)

# å¡å¯†ç®¡ç†æ¥å£
@router.post("/licenses", response_model=ResponseModel[LicenseResponse])
async def create_license(request: CreateLicenseRequest):
    """åˆ›å»ºå¡å¯†"""
    pass

@router.get("/licenses", response_model=ResponseModel[List[LicenseResponse]])
async def list_licenses(
    pagination: PaginationParams = Depends(),
    app_id: Optional[int] = Query(None, description="åº”ç”¨IDç­›é€‰"),
    status: Optional[str] = Query(None, description="çŠ¶æ€ç­›é€‰")
):
    """è·å–å¡å¯†åˆ—è¡¨"""
    pass

@router.get("/licenses/{license_id}", response_model=ResponseModel[LicenseResponse])
async def get_license(license_id: int):
    """è·å–å•ä¸ªå¡å¯†è¯¦æƒ…"""
    pass

@router.put("/licenses/{license_id}", response_model=ResponseModel[LicenseResponse])
async def update_license(license_id: int, request: UpdateLicenseRequest):
    """æ›´æ–°å¡å¯†ä¿¡æ¯"""
    pass

@router.delete("/licenses/{license_id}", response_model=ResponseModel[dict])
async def delete_license(license_id: int):
    """åˆ é™¤å¡å¯†"""
    pass

# å¡å¯†æ¿€æ´»æ¥å£
@router.post("/licenses/activate", response_model=ResponseModel[dict])
async def activate_license(request: ActivateLicenseRequest):
    """æ¿€æ´»å¡å¯†"""
    pass

@router.post("/licenses/verify", response_model=ResponseModel[dict])
async def verify_license(request: VerifyLicenseRequest):
    """éªŒè¯å¡å¯†"""
    pass
```

#### 6.1.2 å“åº”æ ¼å¼è§„èŒƒ

```python
# schemas/common.py
from pydantic import BaseModel
from typing import Generic, TypeVar, Optional, List
from datetime import datetime

T = TypeVar('T')

class ResponseModel(BaseModel, Generic[T]):
    """ç»Ÿä¸€å“åº”æ ¼å¼"""
    success: bool = True
    message: str = "æ“ä½œæˆåŠŸ"
    data: Optional[T] = None
    error_code: Optional[str] = None
    timestamp: datetime = datetime.utcnow()
    request_id: Optional[str] = None

class PaginationParams(BaseModel):
    """åˆ†é¡µå‚æ•°"""
    page: int = 1
    page_size: int = 20
    
    @property
    def offset(self) -> int:
        return (self.page - 1) * self.page_size

class PaginationResponse(BaseModel, Generic[T]):
    """åˆ†é¡µå“åº”æ ¼å¼"""
    items: List[T]
    total: int
    page: int
    page_size: int
    total_pages: int
    
    @classmethod
    def create(cls, items: List[T], total: int, page: int, page_size: int):
        return cls(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=(total + page_size - 1) // page_size
        )

class ErrorResponse(BaseModel):
    """é”™è¯¯å“åº”æ ¼å¼"""
    success: bool = False
    message: str
    error_code: str
    details: Optional[dict] = None
    timestamp: datetime = datetime.utcnow()
    request_id: Optional[str] = None
```

#### 6.1.3 é”™è¯¯ç è§„èŒƒ

```python
# constants/error_codes.py
class ErrorCodes:
    """é”™è¯¯ç å®šä¹‰"""
    
    # é€šç”¨é”™è¯¯ (1000-1999)
    INVALID_REQUEST = "1001"
    UNAUTHORIZED = "1002"
    FORBIDDEN = "1003"
    NOT_FOUND = "1004"
    METHOD_NOT_ALLOWED = "1005"
    RATE_LIMIT_EXCEEDED = "1006"
    INTERNAL_SERVER_ERROR = "1007"
    
    # è®¤è¯ç›¸å…³é”™è¯¯ (2000-2999)
    INVALID_CREDENTIALS = "2001"
    TOKEN_EXPIRED = "2002"
    TOKEN_INVALID = "2003"
    ACCOUNT_LOCKED = "2004"
    PASSWORD_EXPIRED = "2005"
    
    # å¡å¯†ç›¸å…³é”™è¯¯ (3000-3999)
    LICENSE_NOT_FOUND = "3001"
    LICENSE_EXPIRED = "3002"
    LICENSE_ALREADY_ACTIVATED = "3003"
    LICENSE_INVALID = "3004"
    LICENSE_QUOTA_EXCEEDED = "3005"
    
    # è®¾å¤‡ç›¸å…³é”™è¯¯ (4000-4999)
    DEVICE_NOT_FOUND = "4001"
    DEVICE_ALREADY_BOUND = "4002"
    DEVICE_LIMIT_EXCEEDED = "4003"
    DEVICE_UNAUTHORIZED = "4004"
    
    # åº”ç”¨ç›¸å…³é”™è¯¯ (5000-5999)
    APPLICATION_NOT_FOUND = "5001"
    APPLICATION_INACTIVE = "5002"
    APPLICATION_MAINTENANCE = "5003"
    
class ErrorMessages:
    """é”™è¯¯æ¶ˆæ¯å®šä¹‰"""
    
    ERROR_MESSAGES = {
        ErrorCodes.INVALID_REQUEST: "è¯·æ±‚å‚æ•°æ— æ•ˆ",
        ErrorCodes.UNAUTHORIZED: "æœªæˆæƒè®¿é—®",
        ErrorCodes.FORBIDDEN: "ç¦æ­¢è®¿é—®",
        ErrorCodes.NOT_FOUND: "èµ„æºä¸å­˜åœ¨",
        ErrorCodes.RATE_LIMIT_EXCEEDED: "è¯·æ±‚é¢‘ç‡è¶…é™",
        
        ErrorCodes.INVALID_CREDENTIALS: "ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯",
        ErrorCodes.TOKEN_EXPIRED: "è®¿é—®ä»¤ç‰Œå·²è¿‡æœŸ",
        ErrorCodes.TOKEN_INVALID: "è®¿é—®ä»¤ç‰Œæ— æ•ˆ",
        
        ErrorCodes.LICENSE_NOT_FOUND: "å¡å¯†ä¸å­˜åœ¨",
        ErrorCodes.LICENSE_EXPIRED: "å¡å¯†å·²è¿‡æœŸ",
        ErrorCodes.LICENSE_ALREADY_ACTIVATED: "å¡å¯†å·²è¢«æ¿€æ´»",
        ErrorCodes.LICENSE_INVALID: "å¡å¯†æ— æ•ˆ",
        
        ErrorCodes.DEVICE_NOT_FOUND: "è®¾å¤‡ä¸å­˜åœ¨",
        ErrorCodes.DEVICE_ALREADY_BOUND: "è®¾å¤‡å·²ç»‘å®š",
        ErrorCodes.DEVICE_LIMIT_EXCEEDED: "è®¾å¤‡ç»‘å®šæ•°é‡è¶…é™",
        
        ErrorCodes.APPLICATION_NOT_FOUND: "åº”ç”¨ä¸å­˜åœ¨",
        ErrorCodes.APPLICATION_INACTIVE: "åº”ç”¨æœªæ¿€æ´»",
        ErrorCodes.APPLICATION_MAINTENANCE: "åº”ç”¨ç»´æŠ¤ä¸­"
    }
    
    @classmethod
    def get_message(cls, error_code: str) -> str:
        return cls.ERROR_MESSAGES.get(error_code, "æœªçŸ¥é”™è¯¯")
```

## 7. å‰ç«¯å®ç°æŒ‡å—

### 7.1 é¡¹ç›®ç»“æ„

```
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/          # é€šç”¨ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ common/         # åŸºç¡€ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ forms/          # è¡¨å•ç»„ä»¶
â”‚   â”‚   â””â”€â”€ layout/         # å¸ƒå±€ç»„ä»¶
â”‚   â”œâ”€â”€ pages/              # é¡µé¢ç»„ä»¶
â”‚   â”‚   â”œâ”€â”€ auth/           # è®¤è¯é¡µé¢
â”‚   â”‚   â”œâ”€â”€ dashboard/      # ä»ªè¡¨æ¿
â”‚   â”‚   â”œâ”€â”€ licenses/       # å¡å¯†ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ applications/   # åº”ç”¨ç®¡ç†
â”‚   â”‚   â””â”€â”€ settings/       # ç³»ç»Ÿè®¾ç½®
â”‚   â”œâ”€â”€ hooks/              # è‡ªå®šä¹‰Hooks
â”‚   â”œâ”€â”€ services/           # APIæœåŠ¡
â”‚   â”œâ”€â”€ store/              # çŠ¶æ€ç®¡ç†
â”‚   â”œâ”€â”€ types/              # TypeScriptç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•°
â”‚   â””â”€â”€ styles/             # æ ·å¼æ–‡ä»¶
â”œâ”€â”€ public/                 # é™æ€èµ„æº
â””â”€â”€ package.json           # ä¾èµ–é…ç½®
```

### 7.2 TypeScriptç±»å‹å®šä¹‰

```typescript
// types/api.ts
export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  error_code?: string;
  timestamp: string;
  request_id?: string;
}

export interface PaginationParams {
  page: number;
  page_size: number;
}

export interface PaginationResponse<T> {
  items: T[];
  total: number;
  page: number;
  page_size: number;
  total_pages: number;
}

// types/license.ts
export interface License {
  id: number;
  license_key: string;
  application_id: number;
  application_name?: string;
  user_id?: number;
  username?: string;
  status: 'active' | 'expired' | 'suspended' | 'pending';
  expires_at: string;
  created_at: string;
  updated_at: string;
  device_limit: number;
  bound_devices: number;
  metadata?: Record<string, any>;
}

export interface CreateLicenseRequest {
  application_id: number;
  duration_days: number;
  device_limit: number;
  user_id?: number;
  metadata?: Record<string, any>;
}

export interface ActivateLicenseRequest {
  license_key: string;
  device_id: string;
  device_info?: Record<string, any>;
}

// types/application.ts
export interface Application {
  id: number;
  name: string;
  description?: string;
  status: 'active' | 'inactive' | 'maintenance';
  version: string;
  api_key: string;
  settings: ApplicationSettings;
  created_at: string;
  updated_at: string;
}

export interface ApplicationSettings {
  max_devices_per_license: number;
  allow_device_transfer: boolean;
  require_device_verification: boolean;
  auto_extend_licenses: boolean;
  notification_settings: {
    email_notifications: boolean;
    webhook_url?: string;
  };
}

// types/user.ts
export interface User {
  id: number;
  username: string;
  email: string;
  role: 'admin' | 'user';
  is_active: boolean;
  created_at: string;
  last_login?: string;
}

export interface LoginRequest {
  username: string;
  password: string;
}

export interface AuthResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
  user: User;
}
```

### 7.3 APIæœåŠ¡å±‚

```typescript
// services/api.ts
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { ApiResponse } from '../types/api';

class ApiService {
  private client: AxiosInstance;
  
  constructor() {
    this.client = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    this.setupInterceptors();
  }
  
  private setupInterceptors() {
    // è¯·æ±‚æ‹¦æˆªå™¨
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('access_token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );
    
    // å“åº”æ‹¦æˆªå™¨
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          localStorage.removeItem('access_token');
          window.location.href = '/auth/login';
        }
        return Promise.reject(error);
      }
    );
  }
  
  async get<T>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.get(url, config);
    return response.data;
  }
  
  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.post(url, data, config);
    return response.data;
  }
  
  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.put(url, data, config);
    return response.data;
  }
  
  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<ApiResponse<T>> {
    const response = await this.client.delete(url, config);
    return response.data;
  }
}

export const apiService = new ApiService();

// services/licenseService.ts
import { apiService } from './api';
import { License, CreateLicenseRequest, ActivateLicenseRequest } from '../types/license';
import { PaginationParams, PaginationResponse } from '../types/api';

export class LicenseService {
  static async getLicenses(params: PaginationParams & {
    app_id?: number;
    status?: string;
  }) {
    return apiService.get<PaginationResponse<License>>('/api/v1/licenses', {
      params
    });
  }
  
  static async getLicense(id: number) {
    return apiService.get<License>(`/api/v1/licenses/${id}`);
  }
  
  static async createLicense(data: CreateLicenseRequest) {
    return apiService.post<License>('/api/v1/licenses', data);
  }
  
  static async updateLicense(id: number, data: Partial<License>) {
    return apiService.put<License>(`/api/v1/licenses/${id}`, data);
  }
  
  static async deleteLicense(id: number) {
    return apiService.delete(`/api/v1/licenses/${id}`);
  }
  
  static async activateLicense(data: ActivateLicenseRequest) {
    return apiService.post('/api/v1/licenses/activate', data);
  }
  
  static async verifyLicense(licenseKey: string, deviceId: string) {
    return apiService.post('/api/v1/licenses/verify', {
      license_key: licenseKey,
      device_id: deviceId
    });
  }
}

// services/authService.ts
import { apiService } from './api';
import { LoginRequest, AuthResponse, User } from '../types/user';

export class AuthService {
  static async login(credentials: LoginRequest): Promise<AuthResponse> {
    const response = await apiService.post<AuthResponse>('/api/v1/auth/login', credentials);
    
    if (response.success && response.data) {
      localStorage.setItem('access_token', response.data.access_token);
      localStorage.setItem('user', JSON.stringify(response.data.user));
    }
    
    return response.data!;
  }
  
  static async logout() {
    try {
      await apiService.post('/api/v1/auth/logout');
    } finally {
      localStorage.removeItem('access_token');
      localStorage.removeItem('user');
    }
  }
  
  static async getCurrentUser(): Promise<User | null> {
    try {
      const response = await apiService.get<User>('/api/v1/auth/me');
      return response.data || null;
    } catch {
      return null;
    }
  }
  
  static getStoredUser(): User | null {
    const userStr = localStorage.getItem('user');
    return userStr ? JSON.parse(userStr) : null;
  }
  
  static isAuthenticated(): boolean {
    return !!localStorage.getItem('access_token');
  }
}
```

### 7.4 çŠ¶æ€ç®¡ç†

```typescript
// store/authStore.ts
import { create } from 'zustand';
import { User } from '../types/user';
import { AuthService } from '../services/authService';

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
  setUser: (user: User | null) => void;
}

export const useAuthStore = create<AuthState>((set, get) => ({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  
  login: async (username: string, password: string) => {
    try {
      const authResponse = await AuthService.login({ username, password });
      set({ 
        user: authResponse.user, 
        isAuthenticated: true,
        isLoading: false 
      });
    } catch (error) {
      set({ user: null, isAuthenticated: false, isLoading: false });
      throw error;
    }
  },
  
  logout: async () => {
    try {
      await AuthService.logout();
    } finally {
      set({ user: null, isAuthenticated: false, isLoading: false });
    }
  },
  
  checkAuth: async () => {
    set({ isLoading: true });
    
    if (!AuthService.isAuthenticated()) {
      set({ user: null, isAuthenticated: false, isLoading: false });
      return;
    }
    
    try {
      const user = await AuthService.getCurrentUser();
      if (user) {
        set({ user, isAuthenticated: true, isLoading: false });
      } else {
        set({ user: null, isAuthenticated: false, isLoading: false });
      }
    } catch {
      set({ user: null, isAuthenticated: false, isLoading: false });
    }
  },
  
  setUser: (user: User | null) => {
    set({ user, isAuthenticated: !!user });
  }
}));

// store/licenseStore.ts
import { create } from 'zustand';
import { License } from '../types/license';
import { LicenseService } from '../services/licenseService';
import { PaginationParams } from '../types/api';

interface LicenseState {
  licenses: License[];
  currentLicense: License | null;
  total: number;
  isLoading: boolean;
  error: string | null;
  
  fetchLicenses: (params: PaginationParams & { app_id?: number; status?: string }) => Promise<void>;
  fetchLicense: (id: number) => Promise<void>;
  createLicense: (data: any) => Promise<void>;
  updateLicense: (id: number, data: any) => Promise<void>;
  deleteLicense: (id: number) => Promise<void>;
  clearError: () => void;
}

export const useLicenseStore = create<LicenseState>((set, get) => ({
  licenses: [],
  currentLicense: null,
  total: 0,
  isLoading: false,
  error: null,
  
  fetchLicenses: async (params) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.getLicenses(params);
      if (response.success && response.data) {
        set({ 
          licenses: response.data.items, 
          total: response.data.total,
          isLoading: false 
        });
      }
    } catch (error: any) {
      set({ 
        error: error.message || 'è·å–å¡å¯†åˆ—è¡¨å¤±è´¥', 
        isLoading: false 
      });
    }
  },
  
  fetchLicense: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.getLicense(id);
      if (response.success && response.data) {
        set({ currentLicense: response.data, isLoading: false });
      }
    } catch (error: any) {
      set({ 
        error: error.message || 'è·å–å¡å¯†è¯¦æƒ…å¤±è´¥', 
        isLoading: false 
      });
    }
  },
  
  createLicense: async (data) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.createLicense(data);
      if (response.success && response.data) {
        const { licenses } = get();
        set({ 
          licenses: [response.data, ...licenses],
          isLoading: false 
        });
      }
    } catch (error: any) {
      set({ 
        error: error.message || 'åˆ›å»ºå¡å¯†å¤±è´¥', 
        isLoading: false 
      });
      throw error;
    }
  },
  
  updateLicense: async (id, data) => {
    set({ isLoading: true, error: null });
    try {
      const response = await LicenseService.updateLicense(id, data);
      if (response.success && response.data) {
        const { licenses } = get();
        const updatedLicenses = licenses.map(license => 
          license.id === id ? response.data! : license
        );
        set({ 
          licenses: updatedLicenses,
          currentLicense: response.data,
          isLoading: false 
        });
      }
    } catch (error: any) {
      set({ 
        error: error.message || 'æ›´æ–°å¡å¯†å¤±è´¥', 
        isLoading: false 
      });
      throw error;
    }
  },
  
  deleteLicense: async (id) => {
    set({ isLoading: true, error: null });
    try {
      await LicenseService.deleteLicense(id);
      const { licenses } = get();
      const filteredLicenses = licenses.filter(license => license.id !== id);
      set({ 
        licenses: filteredLicenses,
        isLoading: false 
      });
    } catch (error: any) {
      set({ 
        error: error.message || 'åˆ é™¤å¡å¯†å¤±è´¥', 
        isLoading: false 
      });
      throw error;
    }
  },
  
  clearError: () => set({ error: null })
}));
```

### 7.5 æ ¸å¿ƒç»„ä»¶å®ç°

#### 7.5.1 ç™»å½•ç»„ä»¶

```tsx
// components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { useRouter } from 'next/router';
import { useAuthStore } from '../../store/authStore';
import { Button } from '../common/Button';
import { Input } from '../common/Input';
import { Card } from '../common/Card';

export const LoginForm: React.FC = () => {
  const [credentials, setCredentials] = useState({
    username: '',
    password: ''
  });
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  
  const { login } = useAuthStore();
  const router = useRouter();
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');
    
    try {
      await login(credentials.username, credentials.password);
      router.push('/dashboard');
    } catch (err: any) {
      setError(err.message || 'ç™»å½•å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç”¨æˆ·åå’Œå¯†ç ');
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleInputChange = (field: string) => (value: string) => {
    setCredentials(prev => ({ ...prev, [field]: value }));
  };
  
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md p-8">
        <div className="text-center mb-8">
          <h1 className="text-2xl font-bold text-gray-900">é‡‘é±¼æ™ºç›’æˆæƒç³»ç»Ÿ</h1>
          <p className="text-gray-600 mt-2">è¯·ç™»å½•æ‚¨çš„ç®¡ç†è´¦æˆ·</p>
        </div>
        
        <form onSubmit={handleSubmit} className="space-y-6">
          <Input
            label="ç”¨æˆ·å"
            type="text"
            value={credentials.username}
            onChange={handleInputChange('username')}
            placeholder="è¯·è¾“å…¥ç”¨æˆ·å"
            required
          />
          
          <Input
            label="å¯†ç "
            type="password"
            value={credentials.password}
            onChange={handleInputChange('password')}
            placeholder="è¯·è¾“å…¥å¯†ç "
            required
          />
          
          {error && (
            <div className="text-red-600 text-sm text-center">
              {error}
            </div>
          )}
          
          <Button
            type="submit"
            variant="primary"
            size="large"
            className="w-full"
            loading={isLoading}
          >
            ç™»å½•
          </Button>
        </form>
        
        <div className="mt-6 text-center text-sm text-gray-500">
          <p>é»˜è®¤ç®¡ç†å‘˜è´¦æˆ·ï¼šadmin / admin1314159</p>
        </div>
      </Card>
    </div>
   );
 };
 ```

## 8. åç«¯å®ç°æŒ‡å—

### 8.1 é¡¹ç›®ç»“æ„

```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                 # FastAPIåº”ç”¨å…¥å£
â”‚   â”œâ”€â”€ config.py              # é…ç½®ç®¡ç†
â”‚   â”œâ”€â”€ database.py            # æ•°æ®åº“è¿æ¥
â”‚   â”œâ”€â”€ dependencies.py        # ä¾èµ–æ³¨å…¥
â”‚   â”œâ”€â”€ middleware/            # ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth.py           # è®¤è¯ä¸­é—´ä»¶
â”‚   â”‚   â”œâ”€â”€ cors.py           # CORSä¸­é—´ä»¶
â”‚   â”‚   â””â”€â”€ rate_limit.py     # é™æµä¸­é—´ä»¶
â”‚   â”œâ”€â”€ models/               # æ•°æ®æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ base.py          # åŸºç¡€æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ user.py          # ç”¨æˆ·æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ application.py   # åº”ç”¨æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ license.py       # å¡å¯†æ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ device.py        # è®¾å¤‡æ¨¡å‹
â”‚   â”‚   â””â”€â”€ announcement.py  # å…¬å‘Šæ¨¡å‹
â”‚   â”œâ”€â”€ schemas/             # Pydanticæ¨¡å¼
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ user.py
â”‚   â”‚   â”œâ”€â”€ application.py
â”‚   â”‚   â”œâ”€â”€ license.py
â”‚   â”‚   â”œâ”€â”€ device.py
â”‚   â”‚   â””â”€â”€ announcement.py
â”‚   â”œâ”€â”€ api/                 # APIè·¯ç”±
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.py
â”‚   â”‚   â”‚   â”œâ”€â”€ users.py
â”‚   â”‚   â”‚   â”œâ”€â”€ applications.py
â”‚   â”‚   â”‚   â”œâ”€â”€ licenses.py
â”‚   â”‚   â”‚   â”œâ”€â”€ devices.py
â”‚   â”‚   â”‚   â””â”€â”€ announcements.py
â”‚   â”œâ”€â”€ services/            # ä¸šåŠ¡é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth_service.py
â”‚   â”‚   â”œâ”€â”€ license_service.py
â”‚   â”‚   â”œâ”€â”€ device_service.py
â”‚   â”‚   â”œâ”€â”€ notification_service.py
â”‚   â”‚   â””â”€â”€ announcement_service.py
â”‚   â”œâ”€â”€ utils/               # å·¥å…·å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ security.py      # å®‰å…¨å·¥å…·
â”‚   â”‚   â”œâ”€â”€ crypto.py        # åŠ å¯†å·¥å…·
â”‚   â”‚   â”œâ”€â”€ validators.py    # éªŒè¯å™¨
â”‚   â”‚   â””â”€â”€ helpers.py       # è¾…åŠ©å‡½æ•°
â”‚   â””â”€â”€ core/               # æ ¸å¿ƒæ¨¡å—
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ events.py       # äº‹ä»¶ç³»ç»Ÿ
â”‚       â”œâ”€â”€ cache.py        # ç¼“å­˜ç®¡ç†
â”‚       â”œâ”€â”€ logging.py      # æ—¥å¿—é…ç½®
â”‚       â””â”€â”€ exceptions.py   # å¼‚å¸¸å¤„ç†
â”œâ”€â”€ tests/                  # æµ‹è¯•æ–‡ä»¶
â”œâ”€â”€ alembic/               # æ•°æ®åº“è¿ç§»
â”œâ”€â”€ requirements.txt       # ä¾èµ–åŒ…
â”œâ”€â”€ .env.example          # ç¯å¢ƒå˜é‡ç¤ºä¾‹
â””â”€â”€ docker-compose.yml    # Dockeré…ç½®
```

### 8.2 æ ¸å¿ƒæ¨¡å‹å®šä¹‰

```python
# models/base.py
from sqlalchemy import Column, Integer, DateTime, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import Session

Base = declarative_base()

class BaseModel(Base):
    __abstract__ = True
    
    id = Column(Integer, primary_key=True, index=True)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
    
    def to_dict(self):
        """è½¬æ¢ä¸ºå­—å…¸"""
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }
    
    @classmethod
    def create(cls, db: Session, **kwargs):
        """åˆ›å»ºå®ä¾‹"""
        instance = cls(**kwargs)
        db.add(instance)
        db.commit()
        db.refresh(instance)
        return instance
    
    def update(self, db: Session, **kwargs):
        """æ›´æ–°å®ä¾‹"""
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
        db.commit()
        db.refresh(self)
        return self
    
    def delete(self, db: Session):
        """åˆ é™¤å®ä¾‹"""
        db.delete(self)
        db.commit()

# models/license.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, Text
from sqlalchemy.orm import relationship
from .base import BaseModel

class License(BaseModel):
    __tablename__ = "licenses"
    
    license_key = Column(String(64), unique=True, index=True, nullable=False)
    application_id = Column(Integer, ForeignKey("applications.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    device_limit = Column(Integer, default=1, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    status = Column(String(20), default="pending", nullable=False)  # pending, active, expired, suspended
    activation_data = Column(Text, nullable=True)  # JSONæ ¼å¼çš„æ¿€æ´»æ•°æ®
    
    # å…³è”å…³ç³»
    application = relationship("Application", back_populates="licenses")
    user = relationship("User", back_populates="licenses")
    devices = relationship("Device", back_populates="license")
    
    @property
    def bound_devices(self):
        """å·²ç»‘å®šè®¾å¤‡æ•°é‡"""
        return len([d for d in self.devices if d.is_active])
    
    @property
    def is_expired(self):
        """æ˜¯å¦å·²è¿‡æœŸ"""
        from datetime import datetime
        return datetime.utcnow() > self.expires_at
    
    @property
    def can_bind_device(self):
        """æ˜¯å¦å¯ä»¥ç»‘å®šæ–°è®¾å¤‡"""
        return self.bound_devices < self.device_limit and not self.is_expired

# models/device.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey, Text
from sqlalchemy.orm import relationship
from .base import BaseModel

class Device(BaseModel):
    __tablename__ = "devices"
    
    hardware_id = Column(String(128), index=True, nullable=False)
    license_id = Column(Integer, ForeignKey("licenses.id"), nullable=False)
    device_name = Column(String(100), nullable=True)
    device_info = Column(Text, nullable=True)  # JSONæ ¼å¼çš„è®¾å¤‡ä¿¡æ¯
    last_seen = Column(DateTime, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False)
    
    # å…³è”å…³ç³»
    license = relationship("License", back_populates="devices")
    
    @property
    def is_online(self):
        """è®¾å¤‡æ˜¯å¦åœ¨çº¿"""
        from datetime import datetime, timedelta
        if not self.last_seen:
            return False
        return datetime.utcnow() - self.last_seen < timedelta(minutes=5)
```

### 8.3 ä¸šåŠ¡æœåŠ¡å±‚

```python
# services/license_service.py
from typing import List, Optional, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
from datetime import datetime, timedelta
import secrets
import string

from ..models.license import License
from ..models.device import Device
from ..models.application import Application
from ..core.events import EventBus
from ..core.cache import CacheManager
from ..utils.crypto import encrypt_data, decrypt_data
from ..core.exceptions import BusinessException

class LicenseService:
    def __init__(self, db: Session, event_bus: EventBus, cache: CacheManager):
        self.db = db
        self.event_bus = event_bus
        self.cache = cache
    
    def generate_license_key(self, length: int = 32) -> str:
        """ç”Ÿæˆå¡å¯†"""
        alphabet = string.ascii_uppercase + string.digits
        # æ’é™¤å®¹æ˜“æ··æ·†çš„å­—ç¬¦
        alphabet = alphabet.replace('0', '').replace('O', '').replace('I', '').replace('1')
        
        while True:
            key = ''.join(secrets.choice(alphabet) for _ in range(length))
            # æ·»åŠ åˆ†éš”ç¬¦æé«˜å¯è¯»æ€§
            formatted_key = '-'.join([key[i:i+4] for i in range(0, len(key), 4)])
            
            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            if not self.db.query(License).filter(License.license_key == formatted_key).first():
                return formatted_key
    
    def create_license(self, application_id: int, duration_days: int, 
                      device_limit: int = 1, user_id: Optional[int] = None) -> License:
        """åˆ›å»ºå¡å¯†"""
        # éªŒè¯åº”ç”¨æ˜¯å¦å­˜åœ¨
        application = self.db.query(Application).filter(Application.id == application_id).first()
        if not application:
            raise BusinessException("åº”ç”¨ä¸å­˜åœ¨")
        
        # ç”Ÿæˆå¡å¯†å’Œè¿‡æœŸæ—¶é—´
        license_key = self.generate_license_key()
        expires_at = datetime.utcnow() + timedelta(days=duration_days)
        
        # åˆ›å»ºå¡å¯†è®°å½•
        license = License.create(
            self.db,
            license_key=license_key,
            application_id=application_id,
            user_id=user_id,
            device_limit=device_limit,
            expires_at=expires_at,
            status="pending"
        )
        
        # æ¸…é™¤ç›¸å…³ç¼“å­˜
        self.cache.delete_pattern(f"license:*")
        
        return license
    
    def activate_license(self, license_key: str, device_id: str, 
                        device_info: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """æ¿€æ´»å¡å¯†"""
        # æŸ¥æ‰¾å¡å¯†
        license = self.db.query(License).filter(License.license_key == license_key).first()
        if not license:
            raise BusinessException("å¡å¯†ä¸å­˜åœ¨")
        
        # æ£€æŸ¥å¡å¯†çŠ¶æ€
        if license.status == "expired":
            raise BusinessException("å¡å¯†å·²è¿‡æœŸ")
        elif license.status == "suspended":
            raise BusinessException("å¡å¯†å·²è¢«æš‚åœ")
        elif license.is_expired:
            license.status = "expired"
            self.db.commit()
            raise BusinessException("å¡å¯†å·²è¿‡æœŸ")
        
        # æ£€æŸ¥è®¾å¤‡æ˜¯å¦å·²ç»‘å®š
        existing_device = self.db.query(Device).filter(
            and_(Device.hardware_id == device_id, Device.license_id == license.id)
        ).first()
        
        if existing_device:
            if existing_device.is_active:
                # æ›´æ–°æœ€åè§åˆ°æ—¶é—´
                existing_device.last_seen = datetime.utcnow()
                self.db.commit()
                
                return {
                    "success": True,
                    "message": "è®¾å¤‡å·²æ¿€æ´»",
                    "license_info": {
                        "expires_at": license.expires_at.isoformat(),
                        "device_limit": license.device_limit,
                        "bound_devices": license.bound_devices
                    }
                }
            else:
                raise BusinessException("è®¾å¤‡å·²è¢«ç¦ç”¨")
        
        # æ£€æŸ¥è®¾å¤‡ç»‘å®šé™åˆ¶
        if not license.can_bind_device:
            raise BusinessException(f"è®¾å¤‡ç»‘å®šæ•°é‡å·²è¾¾ä¸Šé™({license.device_limit})")
        
        # åˆ›å»ºè®¾å¤‡ç»‘å®šè®°å½•
        device = Device.create(
            self.db,
            hardware_id=device_id,
            license_id=license.id,
            device_info=encrypt_data(device_info) if device_info else None,
            last_seen=datetime.utcnow(),
            is_active=True
        )
        
        # æ›´æ–°å¡å¯†çŠ¶æ€
        if license.status == "pending":
            license.status = "active"
            self.db.commit()
        
        # å‘å¸ƒäº‹ä»¶
        self.event_bus.publish("license.activated", {
            "license_id": license.id,
            "license_key": license.license_key,
            "device_id": device_id,
            "application_id": license.application_id
        })
        
        # æ¸…é™¤ç¼“å­˜
        self.cache.delete(f"license:{license_key}")
        
        return {
            "success": True,
            "message": "æ¿€æ´»æˆåŠŸ",
            "license_info": {
                "expires_at": license.expires_at.isoformat(),
                "device_limit": license.device_limit,
                "bound_devices": license.bound_devices
            }
        }
    
    def verify_license(self, license_key: str, device_id: str) -> Dict[str, Any]:
        """éªŒè¯å¡å¯†"""
        # å°è¯•ä»ç¼“å­˜è·å–
        cache_key = f"license:{license_key}:{device_id}"
        cached_result = self.cache.get(cache_key)
        if cached_result:
            return cached_result
        
        # æŸ¥æ‰¾å¡å¯†å’Œè®¾å¤‡
        license = self.db.query(License).filter(License.license_key == license_key).first()
        if not license:
            result = {"valid": False, "reason": "å¡å¯†ä¸å­˜åœ¨"}
            self.cache.set(cache_key, result, 300)  # ç¼“å­˜5åˆ†é’Ÿ
            return result
        
        device = self.db.query(Device).filter(
            and_(Device.hardware_id == device_id, Device.license_id == license.id)
        ).first()
        
        if not device or not device.is_active:
            result = {"valid": False, "reason": "è®¾å¤‡æœªç»‘å®šæˆ–å·²ç¦ç”¨"}
            self.cache.set(cache_key, result, 300)
            return result
        
        # æ£€æŸ¥å¡å¯†çŠ¶æ€å’Œè¿‡æœŸæ—¶é—´
        if license.status != "active" or license.is_expired:
            result = {"valid": False, "reason": "å¡å¯†å·²è¿‡æœŸæˆ–è¢«æš‚åœ"}
            self.cache.set(cache_key, result, 300)
            return result
        
        # æ›´æ–°è®¾å¤‡æœ€åè§åˆ°æ—¶é—´
        device.last_seen = datetime.utcnow()
        self.db.commit()
        
        result = {
            "valid": True,
            "license_info": {
                "expires_at": license.expires_at.isoformat(),
                "application_id": license.application_id,
                "device_limit": license.device_limit,
                "bound_devices": license.bound_devices
            }
        }
        
        # ç¼“å­˜éªŒè¯ç»“æœï¼ˆè¾ƒçŸ­æ—¶é—´ï¼‰
        self.cache.set(cache_key, result, 60)  # ç¼“å­˜1åˆ†é’Ÿ
        
        return result
    
    def get_license_statistics(self, application_id: Optional[int] = None) -> Dict[str, Any]:
        """è·å–å¡å¯†ç»Ÿè®¡ä¿¡æ¯"""
        query = self.db.query(License)
        if application_id:
            query = query.filter(License.application_id == application_id)
        
        total = query.count()
        active = query.filter(License.status == "active").count()
        expired = query.filter(License.status == "expired").count()
        pending = query.filter(License.status == "pending").count()
        suspended = query.filter(License.status == "suspended").count()
        
        return {
            "total": total,
            "active": active,
            "expired": expired,
            "pending": pending,
            "suspended": suspended,
            "usage_rate": round((active / total * 100) if total > 0 else 0, 2)
        }
```

### 8.4 APIè·¯ç”±å®ç°

```python
# api/v1/licenses.py
from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session

from ...database import get_db
from ...dependencies import get_current_user, get_license_service
from ...schemas.license import (
    LicenseCreate, LicenseUpdate, LicenseResponse, 
    LicenseActivate, LicenseVerify, LicenseList
)
from ...schemas.common import PaginationParams, ResponseModel
from ...models.user import User
from ...services.license_service import LicenseService
from ...core.exceptions import BusinessException

router = APIRouter(prefix="/licenses", tags=["licenses"])

@router.post("/", response_model=ResponseModel[LicenseResponse])
async def create_license(
    license_data: LicenseCreate,
    current_user: User = Depends(get_current_user),
    license_service: LicenseService = Depends(get_license_service)
):
    """åˆ›å»ºå¡å¯†"""
    try:
        license = license_service.create_license(
            application_id=license_data.application_id,
            duration_days=license_data.duration_days,
            device_limit=license_data.device_limit,
            user_id=license_data.user_id
        )
        
        return ResponseModel(
            success=True,
            message="å¡å¯†åˆ›å»ºæˆåŠŸ",
            data=LicenseResponse.from_orm(license)
        )
    except BusinessException as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="åˆ›å»ºå¡å¯†å¤±è´¥")

@router.get("/", response_model=ResponseModel[LicenseList])
async def get_licenses(
    pagination: PaginationParams = Depends(),
    application_id: Optional[int] = Query(None, description="åº”ç”¨ID"),
    status: Optional[str] = Query(None, description="çŠ¶æ€ç­›é€‰"),
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """è·å–å¡å¯†åˆ—è¡¨"""
    query = db.query(License)
    
    # åº”ç”¨ç­›é€‰
    if application_id:
        query = query.filter(License.application_id == application_id)
    
    # çŠ¶æ€ç­›é€‰
    if status:
        query = query.filter(License.status == status)
    
    # åˆ†é¡µ
    total = query.count()
    licenses = query.offset(
        (pagination.page - 1) * pagination.page_size
    ).limit(pagination.page_size).all()
    
    return ResponseModel(
        success=True,
        data=LicenseList(
            items=[LicenseResponse.from_orm(license) for license in licenses],
            total=total,
            page=pagination.page,
            page_size=pagination.page_size
        )
    )

@router.post("/activate", response_model=ResponseModel[dict])
async def activate_license(
    activation_data: LicenseActivate,
    license_service: LicenseService = Depends(get_license_service)
):
    """æ¿€æ´»å¡å¯†"""
    try:
        result = license_service.activate_license(
            license_key=activation_data.license_key,
            device_id=activation_data.device_id,
            device_info=activation_data.device_info
        )
        
        return ResponseModel(
            success=True,
            message=result["message"],
            data=result
        )
    except BusinessException as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="æ¿€æ´»å¤±è´¥")

@router.post("/verify", response_model=ResponseModel[dict])
async def verify_license(
    verify_data: LicenseVerify,
    license_service: LicenseService = Depends(get_license_service)
):
    """éªŒè¯å¡å¯†"""
    try:
        result = license_service.verify_license(
            license_key=verify_data.license_key,
            device_id=verify_data.device_id
        )
        
        return ResponseModel(
            success=True,
            data=result
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail="éªŒè¯å¤±è´¥")

@router.get("/statistics", response_model=ResponseModel[dict])
async def get_license_statistics(
    application_id: Optional[int] = Query(None, description="åº”ç”¨ID"),
    current_user: User = Depends(get_current_user),
    license_service: LicenseService = Depends(get_license_service)
):
    """è·å–å¡å¯†ç»Ÿè®¡ä¿¡æ¯"""
    try:
        stats = license_service.get_license_statistics(application_id)
        
        return ResponseModel(
            success=True,
            data=stats
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail="è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥")
```

## 9. éƒ¨ç½²ä¸è¿ç»´

### 9.1 ç¯å¢ƒé…ç½®

#### 9.1.1 ç¯å¢ƒå˜é‡é…ç½®

```bash
# .env
# æ•°æ®åº“é…ç½®
DATABASE_URL=postgresql://username:password@localhost:5432/license_system
REDIS_URL=redis://localhost:6379/0

# åº”ç”¨é…ç½®
APP_NAME=é‡‘é±¼æ™ºç›’å¡å¯†æˆæƒç³»ç»Ÿ
APP_VERSION=1.0.0
DEBUG=false
SECRET_KEY=your-super-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# æœåŠ¡ç«¯å£
BACKEND_PORT=8000
FRONTEND_PORT=3000

# å®‰å…¨é…ç½®
ENCRYPTION_KEY=your-encryption-key-here
API_KEY_SECRET=your-api-key-secret
RATE_LIMIT_PER_MINUTE=60

# é‚®ä»¶é…ç½®ï¼ˆå¯é€‰ï¼‰
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-password

# æ—¥å¿—é…ç½®
LOG_LEVEL=INFO
LOG_FILE_PATH=./logs/app.log
LOG_MAX_SIZE=10MB
LOG_BACKUP_COUNT=5

# ç¼“å­˜é…ç½®
CACHE_DEFAULT_TIMEOUT=300
CACHE_KEY_PREFIX=license_system:

# æ•°æ®åº“è¿æ¥æ± é…ç½®
DB_POOL_SIZE=20
DB_MAX_OVERFLOW=30
DB_POOL_RECYCLE=3600
```

#### 9.1.2 Dockeré…ç½®

```dockerfile
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements.txt .

# å®‰è£…Pythonä¾èµ–
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# åˆ›å»ºérootç”¨æˆ·
RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
USER appuser

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

# frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./

# å®‰è£…ä¾èµ–
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN npm run build

# ç”Ÿäº§é•œåƒ
FROM node:18-alpine AS runner

WORKDIR /app

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

# å¤åˆ¶æ„å»ºäº§ç‰©
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

# è®¾ç½®æƒé™
USER nextjs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¯åŠ¨å‘½ä»¤
CMD ["node", "server.js"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  # æ•°æ®åº“
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: license_system
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres123
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3

  # åç«¯æœåŠ¡
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - DATABASE_URL=postgresql://postgres:postgres123@postgres:5432/license_system
      - REDIS_URL=redis://redis:6379/0
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  # å‰ç«¯æœåŠ¡
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:3000
    ports:
      - "3000:3000"
    depends_on:
      - backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Nginxåå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### 9.2 ç›‘æ§ä¸æ—¥å¿—

#### 9.2.1 åº”ç”¨ç›‘æ§

```python
# core/monitoring.py
import time
import psutil
from typing import Dict, Any
from fastapi import Request
from prometheus_client import Counter, Histogram, Gauge, generate_latest

# PrometheusæŒ‡æ ‡
REQUEST_COUNT = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status']
)

REQUEST_DURATION = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint']
)

ACTIVE_LICENSES = Gauge(
    'active_licenses_total',
    'Total active licenses'
)

SYSTEM_CPU_USAGE = Gauge(
    'system_cpu_usage_percent',
    'System CPU usage percentage'
)

SYSTEM_MEMORY_USAGE = Gauge(
    'system_memory_usage_percent',
    'System memory usage percentage'
)

class MonitoringService:
    def __init__(self):
        self.start_time = time.time()
    
    async def record_request(self, request: Request, response_time: float, status_code: int):
        """è®°å½•è¯·æ±‚æŒ‡æ ‡"""
        method = request.method
        endpoint = request.url.path
        
        REQUEST_COUNT.labels(
            method=method,
            endpoint=endpoint,
            status=status_code
        ).inc()
        
        REQUEST_DURATION.labels(
            method=method,
            endpoint=endpoint
        ).observe(response_time)
    
    def update_system_metrics(self):
        """æ›´æ–°ç³»ç»ŸæŒ‡æ ‡"""
        # CPUä½¿ç”¨ç‡
        cpu_percent = psutil.cpu_percent(interval=1)
        SYSTEM_CPU_USAGE.set(cpu_percent)
        
        # å†…å­˜ä½¿ç”¨ç‡
        memory = psutil.virtual_memory()
        SYSTEM_MEMORY_USAGE.set(memory.percent)
    
    def update_business_metrics(self, db_session):
        """æ›´æ–°ä¸šåŠ¡æŒ‡æ ‡"""
        from ..models.license import License
        
        # æ´»è·ƒå¡å¯†æ•°é‡
        active_count = db_session.query(License).filter(
            License.status == 'active'
        ).count()
        ACTIVE_LICENSES.set(active_count)
    
    def get_health_status(self) -> Dict[str, Any]:
        """è·å–å¥åº·çŠ¶æ€"""
        uptime = time.time() - self.start_time
        
        return {
            "status": "healthy",
            "uptime_seconds": uptime,
            "timestamp": time.time(),
            "version": "1.0.0"
        }
    
    def get_metrics(self) -> str:
        """è·å–Prometheusæ ¼å¼çš„æŒ‡æ ‡"""
        return generate_latest()

# ä¸­é—´ä»¶
async def monitoring_middleware(request: Request, call_next):
    """ç›‘æ§ä¸­é—´ä»¶"""
    start_time = time.time()
    
    response = await call_next(request)
    
    process_time = time.time() - start_time
    
    # è®°å½•è¯·æ±‚æŒ‡æ ‡
    monitoring_service = request.app.state.monitoring_service
    await monitoring_service.record_request(
        request, process_time, response.status_code
    )
    
    return response
```

#### 9.2.2 æ—¥å¿—é…ç½®

```python
# core/logging.py
import logging
import logging.handlers
import json
from datetime import datetime
from typing import Dict, Any
from pathlib import Path

class JSONFormatter(logging.Formatter):
    """JSONæ ¼å¼æ—¥å¿—æ ¼å¼åŒ–å™¨"""
    
    def format(self, record: logging.LogRecord) -> str:
        log_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        
        # æ·»åŠ å¼‚å¸¸ä¿¡æ¯
        if record.exc_info:
            log_entry["exception"] = self.formatException(record.exc_info)
        
        # æ·»åŠ é¢å¤–å­—æ®µ
        if hasattr(record, 'user_id'):
            log_entry["user_id"] = record.user_id
        if hasattr(record, 'request_id'):
            log_entry["request_id"] = record.request_id
        if hasattr(record, 'ip_address'):
            log_entry["ip_address"] = record.ip_address
        
        return json.dumps(log_entry, ensure_ascii=False)

def setup_logging(log_level: str = "INFO", log_file: str = "./logs/app.log"):
    """é…ç½®æ—¥å¿—ç³»ç»Ÿ"""
    # åˆ›å»ºæ—¥å¿—ç›®å½•
    log_path = Path(log_file)
    log_path.parent.mkdir(parents=True, exist_ok=True)
    
    # æ ¹æ—¥å¿—å™¨é…ç½®
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level.upper()))
    
    # æ¸…é™¤ç°æœ‰å¤„ç†å™¨
    root_logger.handlers.clear()
    
    # æ§åˆ¶å°å¤„ç†å™¨
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    console_formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(console_formatter)
    root_logger.addHandler(console_handler)
    
    # æ–‡ä»¶å¤„ç†å™¨ï¼ˆè½®è½¬ï¼‰
    file_handler = logging.handlers.RotatingFileHandler(
        log_file,
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5,
        encoding='utf-8'
    )
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(JSONFormatter())
    root_logger.addHandler(file_handler)
    
    # é”™è¯¯æ—¥å¿—å¤„ç†å™¨
    error_handler = logging.handlers.RotatingFileHandler(
        log_file.replace('.log', '_error.log'),
        maxBytes=10*1024*1024,
        backupCount=5,
        encoding='utf-8'
    )
    error_handler.setLevel(logging.ERROR)
    error_handler.setFormatter(JSONFormatter())
    root_logger.addHandler(error_handler)
    
    # è®¾ç½®ç¬¬ä¸‰æ–¹åº“æ—¥å¿—çº§åˆ«
    logging.getLogger('uvicorn').setLevel(logging.INFO)
    logging.getLogger('sqlalchemy.engine').setLevel(logging.WARNING)
    logging.getLogger('redis').setLevel(logging.WARNING)

class StructuredLogger:
    """ç»“æ„åŒ–æ—¥å¿—å™¨"""
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
    
    def info(self, message: str, **kwargs):
        """è®°å½•ä¿¡æ¯æ—¥å¿—"""
        extra = self._build_extra(**kwargs)
        self.logger.info(message, extra=extra)
    
    def warning(self, message: str, **kwargs):
        """è®°å½•è­¦å‘Šæ—¥å¿—"""
        extra = self._build_extra(**kwargs)
        self.logger.warning(message, extra=extra)
    
    def error(self, message: str, **kwargs):
        """è®°å½•é”™è¯¯æ—¥å¿—"""
        extra = self._build_extra(**kwargs)
        self.logger.error(message, extra=extra)
    
    def debug(self, message: str, **kwargs):
        """è®°å½•è°ƒè¯•æ—¥å¿—"""
        extra = self._build_extra(**kwargs)
        self.logger.debug(message, extra=extra)
    
    def _build_extra(self, **kwargs) -> Dict[str, Any]:
        """æ„å»ºé¢å¤–å­—æ®µ"""
        return {k: v for k, v in kwargs.items() if v is not None}

# ä¸šåŠ¡æ—¥å¿—è®°å½•å™¨
audit_logger = StructuredLogger('audit')
security_logger = StructuredLogger('security')
performance_logger = StructuredLogger('performance')
```

### 9.3 éƒ¨ç½²è„šæœ¬

```bash
#!/bin/bash
# deploy.sh - éƒ¨ç½²è„šæœ¬

set -e

echo "å¼€å§‹éƒ¨ç½²é‡‘é±¼æ™ºç›’å¡å¯†æˆæƒç³»ç»Ÿ..."

# æ£€æŸ¥Dockerå’ŒDocker Compose
if ! command -v docker &> /dev/null; then
    echo "é”™è¯¯: Dockeræœªå®‰è£…"
    exit 1
fi

if ! command -v docker-compose &> /dev/null; then
    echo "é”™è¯¯: Docker Composeæœªå®‰è£…"
    exit 1
fi

# åˆ›å»ºå¿…è¦ç›®å½•
mkdir -p logs ssl

# æ£€æŸ¥ç¯å¢ƒå˜é‡æ–‡ä»¶
if [ ! -f .env ]; then
    echo "è­¦å‘Š: .envæ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¤åˆ¶ç¤ºä¾‹æ–‡ä»¶"
    cp .env.example .env
    echo "è¯·ç¼–è¾‘.envæ–‡ä»¶é…ç½®å¿…è¦å‚æ•°"
    exit 1
fi

# æ„å»ºé•œåƒ
echo "æ„å»ºDockeré•œåƒ..."
docker-compose build

# å¯åŠ¨æ•°æ®åº“æœåŠ¡
echo "å¯åŠ¨æ•°æ®åº“æœåŠ¡..."
docker-compose up -d postgres redis

# ç­‰å¾…æ•°æ®åº“å°±ç»ª
echo "ç­‰å¾…æ•°æ®åº“å°±ç»ª..."
sleep 10

# è¿è¡Œæ•°æ®åº“è¿ç§»
echo "è¿è¡Œæ•°æ®åº“è¿ç§»..."
docker-compose run --rm backend alembic upgrade head

# å¯åŠ¨æ‰€æœ‰æœåŠ¡
echo "å¯åŠ¨æ‰€æœ‰æœåŠ¡..."
docker-compose up -d

# æ£€æŸ¥æœåŠ¡çŠ¶æ€
echo "æ£€æŸ¥æœåŠ¡çŠ¶æ€..."
sleep 5
docker-compose ps

# å¥åº·æ£€æŸ¥
echo "æ‰§è¡Œå¥åº·æ£€æŸ¥..."
for i in {1..30}; do
    if curl -f http://localhost:8000/health > /dev/null 2>&1; then
        echo "åç«¯æœåŠ¡å¯åŠ¨æˆåŠŸ"
        break
    fi
    echo "ç­‰å¾…åç«¯æœåŠ¡å¯åŠ¨... ($i/30)"
    sleep 2
done

for i in {1..30}; do
    if curl -f http://localhost:3000 > /dev/null 2>&1; then
        echo "å‰ç«¯æœåŠ¡å¯åŠ¨æˆåŠŸ"
        break
    fi
    echo "ç­‰å¾…å‰ç«¯æœåŠ¡å¯åŠ¨... ($i/30)"
    sleep 2
done

echo "éƒ¨ç½²å®Œæˆï¼"
echo "å‰ç«¯è®¿é—®åœ°å€: http://localhost:3000"
echo "åç«¯APIåœ°å€: http://localhost:8000"
echo "é»˜è®¤ç®¡ç†å‘˜è´¦å·: admin / admin1314159"
```

## 10. æµ‹è¯•æ–¹æ¡ˆ

### 10.1 å•å…ƒæµ‹è¯•

#### 10.1.1 åç«¯å•å…ƒæµ‹è¯•

```python
# tests/test_license_service.py
import pytest
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from unittest.mock import Mock, patch

from app.services.license_service import LicenseService
from app.models.license import License
from app.models.application import Application
from app.core.exceptions import BusinessException

class TestLicenseService:
    @pytest.fixture
    def mock_db(self):
        return Mock(spec=Session)
    
    @pytest.fixture
    def mock_event_bus(self):
        return Mock()
    
    @pytest.fixture
    def mock_cache(self):
        return Mock()
    
    @pytest.fixture
    def license_service(self, mock_db, mock_event_bus, mock_cache):
        return LicenseService(mock_db, mock_event_bus, mock_cache)
    
    def test_generate_license_key(self, license_service):
        """æµ‹è¯•å¡å¯†ç”Ÿæˆ"""
        # æ¨¡æ‹Ÿæ•°æ®åº“æŸ¥è¯¢è¿”å›ç©º
        license_service.db.query.return_value.filter.return_value.first.return_value = None
        
        key = license_service.generate_license_key()
        
        # éªŒè¯æ ¼å¼
        assert isinstance(key, str)
        assert len(key.replace('-', '')) == 32
        assert '-' in key
        
        # éªŒè¯ä¸åŒ…å«å®¹æ˜“æ··æ·†çš„å­—ç¬¦
        assert '0' not in key
        assert 'O' not in key
        assert 'I' not in key
        assert '1' not in key
    
    def test_create_license_success(self, license_service):
        """æµ‹è¯•åˆ›å»ºå¡å¯†æˆåŠŸ"""
        # æ¨¡æ‹Ÿåº”ç”¨å­˜åœ¨
        mock_app = Mock(spec=Application)
        mock_app.id = 1
        license_service.db.query.return_value.filter.return_value.first.return_value = mock_app
        
        # æ¨¡æ‹ŸLicense.create
        mock_license = Mock(spec=License)
        mock_license.id = 1
        mock_license.license_key = "TEST-KEY-1234-5678"
        
        with patch.object(License, 'create', return_value=mock_license):
            result = license_service.create_license(
                application_id=1,
                duration_days=30,
                device_limit=2
            )
        
        assert result == mock_license
        license_service.cache.delete_pattern.assert_called_once_with("license:*")
    
    def test_create_license_app_not_found(self, license_service):
        """æµ‹è¯•åˆ›å»ºå¡å¯†æ—¶åº”ç”¨ä¸å­˜åœ¨"""
        # æ¨¡æ‹Ÿåº”ç”¨ä¸å­˜åœ¨
        license_service.db.query.return_value.filter.return_value.first.return_value = None
        
        with pytest.raises(BusinessException, match="åº”ç”¨ä¸å­˜åœ¨"):
            license_service.create_license(
                application_id=999,
                duration_days=30
            )
    
    def test_activate_license_success(self, license_service):
        """æµ‹è¯•æ¿€æ´»å¡å¯†æˆåŠŸ"""
        # æ¨¡æ‹Ÿå¡å¯†å­˜åœ¨ä¸”æœ‰æ•ˆ
        mock_license = Mock(spec=License)
        mock_license.id = 1
        mock_license.status = "pending"
        mock_license.is_expired = False
        mock_license.can_bind_device = True
        mock_license.expires_at = datetime.utcnow() + timedelta(days=30)
        mock_license.device_limit = 1
        mock_license.bound_devices = 0
        mock_license.application_id = 1
        
        license_service.db.query.return_value.filter.return_value.first.return_value = mock_license
        
        # æ¨¡æ‹Ÿè®¾å¤‡ä¸å­˜åœ¨ï¼ˆé¦–æ¬¡æ¿€æ´»ï¼‰
        license_service.db.query.return_value.filter.return_value.first.side_effect = [mock_license, None]
        
        # æ¨¡æ‹ŸDevice.create
        mock_device = Mock()
        with patch('app.models.device.Device.create', return_value=mock_device):
            result = license_service.activate_license(
                license_key="TEST-KEY-1234-5678",
                device_id="device123"
            )
        
        assert result["success"] is True
        assert result["message"] == "æ¿€æ´»æˆåŠŸ"
        license_service.event_bus.publish.assert_called_once()
    
    def test_verify_license_valid(self, license_service):
        """æµ‹è¯•éªŒè¯æœ‰æ•ˆå¡å¯†"""
        # æ¨¡æ‹Ÿç¼“å­˜æœªå‘½ä¸­
        license_service.cache.get.return_value = None
        
        # æ¨¡æ‹Ÿå¡å¯†å’Œè®¾å¤‡å­˜åœ¨ä¸”æœ‰æ•ˆ
        mock_license = Mock(spec=License)
        mock_license.status = "active"
        mock_license.is_expired = False
        mock_license.expires_at = datetime.utcnow() + timedelta(days=30)
        mock_license.application_id = 1
        mock_license.device_limit = 1
        mock_license.bound_devices = 1
        
        mock_device = Mock()
        mock_device.is_active = True
        mock_device.last_seen = datetime.utcnow()
        
        license_service.db.query.return_value.filter.return_value.first.side_effect = [mock_license, mock_device]
        
        result = license_service.verify_license(
            license_key="TEST-KEY-1234-5678",
            device_id="device123"
        )
        
        assert result["valid"] is True
        assert "license_info" in result
        license_service.cache.set.assert_called_once()

# tests/conftest.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient

from app.main import app
from app.database import get_db
from app.models.base import Base

# æµ‹è¯•æ•°æ®åº“é…ç½®
SQLALCHEMY_DATABASE_URL = "sqlite:///./test.db"

engine = create_engine(
    SQLALCHEMY_DATABASE_URL, connect_args={"check_same_thread": False}
)
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

@pytest.fixture(scope="session")
def db_engine():
    """åˆ›å»ºæµ‹è¯•æ•°æ®åº“å¼•æ“"""
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)

@pytest.fixture
def db_session(db_engine):
    """åˆ›å»ºæµ‹è¯•æ•°æ®åº“ä¼šè¯"""
    connection = db_engine.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)
    
    yield session
    
    session.close()
    transaction.rollback()
    connection.close()

@pytest.fixture
def client(db_session):
    """åˆ›å»ºæµ‹è¯•å®¢æˆ·ç«¯"""
    def override_get_db():
        yield db_session
    
    app.dependency_overrides[get_db] = override_get_db
    
    with TestClient(app) as test_client:
        yield test_client
    
    app.dependency_overrides.clear()
```

#### 10.1.2 å‰ç«¯å•å…ƒæµ‹è¯•

```javascript
// __tests__/components/LicenseCard.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { LicenseCard } from '@/components/LicenseCard';
import { License } from '@/types';

const mockLicense: License = {
  id: 1,
  license_key: 'TEST-KEY-1234-5678',
  application_id: 1,
  application_name: 'æµ‹è¯•åº”ç”¨',
  status: 'active',
  device_limit: 2,
  bound_devices: 1,
  expires_at: '2024-12-31T23:59:59Z',
  created_at: '2024-01-01T00:00:00Z'
};

describe('LicenseCard', () => {
  it('åº”è¯¥æ­£ç¡®æ¸²æŸ“å¡å¯†ä¿¡æ¯', () => {
    render(<LicenseCard license={mockLicense} />);
    
    expect(screen.getByText('TEST-KEY-1234-5678')).toBeInTheDocument();
    expect(screen.getByText('æµ‹è¯•åº”ç”¨')).toBeInTheDocument();
    expect(screen.getByText('å·²æ¿€æ´»')).toBeInTheDocument();
    expect(screen.getByText('1/2')).toBeInTheDocument();
  });
  
  it('åº”è¯¥æ­£ç¡®æ˜¾ç¤ºè¿‡æœŸçŠ¶æ€', () => {
    const expiredLicense = {
      ...mockLicense,
      status: 'expired' as const,
      expires_at: '2023-12-31T23:59:59Z'
    };
    
    render(<LicenseCard license={expiredLicense} />);
    
    expect(screen.getByText('å·²è¿‡æœŸ')).toBeInTheDocument();
    expect(screen.getByText('å·²è¿‡æœŸ')).toHaveClass('text-red-600');
  });
  
  it('åº”è¯¥è§¦å‘å¤åˆ¶å¡å¯†åŠŸèƒ½', async () => {
    // æ¨¡æ‹Ÿclipboard API
    Object.assign(navigator, {
      clipboard: {
        writeText: jest.fn().mockImplementation(() => Promise.resolve())
      }
    });
    
    render(<LicenseCard license={mockLicense} />);
    
    const copyButton = screen.getByRole('button', { name: /å¤åˆ¶/i });
    fireEvent.click(copyButton);
    
    expect(navigator.clipboard.writeText).toHaveBeenCalledWith('TEST-KEY-1234-5678');
  });
});

// __tests__/hooks/useLicenses.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useLicenses } from '@/hooks/useLicenses';
import { api } from '@/lib/api';

// æ¨¡æ‹ŸAPI
jest.mock('@/lib/api');
const mockedApi = api as jest.Mocked<typeof api>;

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });
  
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useLicenses', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  
  it('åº”è¯¥æˆåŠŸè·å–å¡å¯†åˆ—è¡¨', async () => {
    const mockData = {
      success: true,
      data: {
        items: [mockLicense],
        total: 1,
        page: 1,
        page_size: 10
      }
    };
    
    mockedApi.get.mockResolvedValueOnce({ data: mockData });
    
    const { result } = renderHook(() => useLicenses(), {
      wrapper: createWrapper()
    });
    
    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });
    
    expect(result.current.data?.items).toHaveLength(1);
    expect(result.current.data?.items[0]).toEqual(mockLicense);
  });
  
  it('åº”è¯¥å¤„ç†APIé”™è¯¯', async () => {
    mockedApi.get.mockRejectedValueOnce(new Error('ç½‘ç»œé”™è¯¯'));
    
    const { result } = renderHook(() => useLicenses(), {
      wrapper: createWrapper()
    });
    
    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });
    
    expect(result.current.error).toBeDefined();
  });
});
```

### 10.2 é›†æˆæµ‹è¯•

```python
# tests/test_integration.py
import pytest
from fastapi.testclient import TestClient
from datetime import datetime, timedelta

from app.main import app
from app.models.user import User
from app.models.application import Application
from app.models.license import License

class TestLicenseIntegration:
    def test_complete_license_workflow(self, client: TestClient, db_session):
        """æµ‹è¯•å®Œæ•´çš„å¡å¯†å·¥ä½œæµç¨‹"""
        # 1. åˆ›å»ºç®¡ç†å‘˜ç”¨æˆ·
        admin_user = User.create(
            db_session,
            username="admin",
            email="admin@test.com",
            hashed_password="hashed_password",
            is_admin=True
        )
        
        # 2. ç™»å½•è·å–token
        login_response = client.post("/api/v1/auth/login", json={
            "username": "admin",
            "password": "admin1314159"
        })
        assert login_response.status_code == 200
        token = login_response.json()["data"]["access_token"]
        headers = {"Authorization": f"Bearer {token}"}
        
        # 3. åˆ›å»ºåº”ç”¨
        app_response = client.post("/api/v1/applications/", json={
            "name": "æµ‹è¯•åº”ç”¨",
            "description": "ç”¨äºæµ‹è¯•çš„åº”ç”¨",
            "version": "1.0.0"
        }, headers=headers)
        assert app_response.status_code == 200
        app_id = app_response.json()["data"]["id"]
        
        # 4. åˆ›å»ºå¡å¯†
        license_response = client.post("/api/v1/licenses/", json={
            "application_id": app_id,
            "duration_days": 30,
            "device_limit": 2
        }, headers=headers)
        assert license_response.status_code == 200
        license_key = license_response.json()["data"]["license_key"]
        
        # 5. æ¿€æ´»å¡å¯†
        activate_response = client.post("/api/v1/licenses/activate", json={
            "license_key": license_key,
            "device_id": "test_device_001",
            "device_info": {
                "os": "Windows 11",
                "cpu": "Intel i7",
                "memory": "16GB"
            }
        })
        assert activate_response.status_code == 200
        assert activate_response.json()["data"]["success"] is True
        
        # 6. éªŒè¯å¡å¯†
        verify_response = client.post("/api/v1/licenses/verify", json={
            "license_key": license_key,
            "device_id": "test_device_001"
        })
        assert verify_response.status_code == 200
        assert verify_response.json()["data"]["valid"] is True
        
        # 7. å°è¯•è¶…å‡ºè®¾å¤‡é™åˆ¶
        activate_response2 = client.post("/api/v1/licenses/activate", json={
            "license_key": license_key,
            "device_id": "test_device_002"
        })
        assert activate_response2.status_code == 200
        
        activate_response3 = client.post("/api/v1/licenses/activate", json={
            "license_key": license_key,
            "device_id": "test_device_003"
        })
        assert activate_response3.status_code == 400
        assert "è®¾å¤‡ç»‘å®šæ•°é‡å·²è¾¾ä¸Šé™" in activate_response3.json()["detail"]
        
        # 8. è·å–ç»Ÿè®¡ä¿¡æ¯
        stats_response = client.get("/api/v1/licenses/statistics", headers=headers)
        assert stats_response.status_code == 200
        stats = stats_response.json()["data"]
        assert stats["total"] == 1
        assert stats["active"] == 1
```

### 10.3 æ€§èƒ½æµ‹è¯•

```python
# tests/test_performance.py
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
import requests

class TestPerformance:
    BASE_URL = "http://localhost:8000"
    
    def test_license_verification_performance(self):
        """æµ‹è¯•å¡å¯†éªŒè¯æ€§èƒ½"""
        # å‡†å¤‡æµ‹è¯•æ•°æ®
        license_key = "TEST-KEY-1234-5678"
        device_id = "performance_test_device"
        
        def verify_license():
            response = requests.post(f"{self.BASE_URL}/api/v1/licenses/verify", json={
                "license_key": license_key,
                "device_id": device_id
            })
            return response.status_code == 200
        
        # å•æ¬¡è¯·æ±‚æ€§èƒ½æµ‹è¯•
        start_time = time.time()
        result = verify_license()
        end_time = time.time()
        
        response_time = (end_time - start_time) * 1000  # è½¬æ¢ä¸ºæ¯«ç§’
        assert response_time < 300, f"å“åº”æ—¶é—´è¿‡é•¿: {response_time}ms"
        assert result is True
        
        # å¹¶å‘æ€§èƒ½æµ‹è¯•
        concurrent_requests = 100
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(verify_license) for _ in range(concurrent_requests)]
            results = [future.result() for future in futures]
        
        end_time = time.time()
        total_time = end_time - start_time
        
        # éªŒè¯ç»“æœ
        success_count = sum(results)
        success_rate = success_count / concurrent_requests
        
        assert success_rate >= 0.95, f"æˆåŠŸç‡è¿‡ä½: {success_rate}"
        assert total_time < 10, f"å¹¶å‘æµ‹è¯•æ—¶é—´è¿‡é•¿: {total_time}s"
        
        print(f"å¹¶å‘æµ‹è¯•ç»“æœ:")
        print(f"  è¯·æ±‚æ•°é‡: {concurrent_requests}")
        print(f"  æˆåŠŸæ•°é‡: {success_count}")
        print(f"  æˆåŠŸç‡: {success_rate:.2%}")
        print(f"  æ€»è€—æ—¶: {total_time:.2f}s")
        print(f"  å¹³å‡å“åº”æ—¶é—´: {(total_time / concurrent_requests * 1000):.2f}ms")
```

## 11. å®‰å…¨åŠ å›º

### 11.1 æ•°æ®åŠ å¯†

```python
# utils/crypto.py
import base64
import hashlib
import secrets
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from typing import Union, Optional

class CryptoManager:
    """åŠ å¯†ç®¡ç†å™¨"""
    
    def __init__(self, master_key: str):
        self.master_key = master_key.encode()
        self._fernet = None
    
    @property
    def fernet(self) -> Fernet:
        """è·å–Fernetå®ä¾‹"""
        if self._fernet is None:
            # ä½¿ç”¨PBKDF2æ´¾ç”Ÿå¯†é’¥
            kdf = PBKDF2HMAC(
                algorithm=hashes.SHA256(),
                length=32,
                salt=b'license_system_salt',  # ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨éšæœºsalt
                iterations=100000,
            )
            key = base64.urlsafe_b64encode(kdf.derive(self.master_key))
            self._fernet = Fernet(key)
        return self._fernet
    
    def encrypt(self, data: Union[str, bytes]) -> str:
        """åŠ å¯†æ•°æ®"""
        if isinstance(data, str):
            data = data.encode('utf-8')
        
        encrypted = self.fernet.encrypt(data)
        return base64.urlsafe_b64encode(encrypted).decode('utf-8')
    
    def decrypt(self, encrypted_data: str) -> str:
        """è§£å¯†æ•°æ®"""
        try:
            encrypted_bytes = base64.urlsafe_b64decode(encrypted_data.encode('utf-8'))
            decrypted = self.fernet.decrypt(encrypted_bytes)
            return decrypted.decode('utf-8')
        except Exception:
            raise ValueError("è§£å¯†å¤±è´¥")
    
    def hash_password(self, password: str, salt: Optional[str] = None) -> tuple[str, str]:
        """å“ˆå¸Œå¯†ç """
        if salt is None:
            salt = secrets.token_hex(16)
        
        # ä½¿ç”¨PBKDF2å“ˆå¸Œå¯†ç 
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt.encode(),
            iterations=100000,
        )
        
        hashed = kdf.derive(password.encode())
        return base64.urlsafe_b64encode(hashed).decode(), salt
    
    def verify_password(self, password: str, hashed: str, salt: str) -> bool:
        """éªŒè¯å¯†ç """
        try:
            expected_hash, _ = self.hash_password(password, salt)
            return secrets.compare_digest(hashed, expected_hash)
        except Exception:
            return False
    
    def generate_api_key(self, length: int = 32) -> str:
        """ç”ŸæˆAPIå¯†é’¥"""
        return secrets.token_urlsafe(length)
    
    def hash_device_id(self, device_id: str) -> str:
        """å“ˆå¸Œè®¾å¤‡IDï¼ˆå•å‘ï¼‰"""
        return hashlib.sha256(device_id.encode()).hexdigest()

# å…¨å±€åŠ å¯†å®ä¾‹
crypto_manager = None

def init_crypto(master_key: str):
    """åˆå§‹åŒ–åŠ å¯†ç®¡ç†å™¨"""
    global crypto_manager
    crypto_manager = CryptoManager(master_key)

def encrypt_data(data: Union[str, dict]) -> str:
    """åŠ å¯†æ•°æ®"""
    if crypto_manager is None:
        raise RuntimeError("åŠ å¯†ç®¡ç†å™¨æœªåˆå§‹åŒ–")
    
    if isinstance(data, dict):
        import json
        data = json.dumps(data, ensure_ascii=False)
    
    return crypto_manager.encrypt(data)

def decrypt_data(encrypted_data: str) -> str:
    """è§£å¯†æ•°æ®"""
    if crypto_manager is None:
        raise RuntimeError("åŠ å¯†ç®¡ç†å™¨æœªåˆå§‹åŒ–")
    
    return crypto_manager.decrypt(encrypted_data)
```

### 11.2 è®¿é—®æ§åˆ¶

```python
# middleware/security.py
import time
import hashlib
from typing import Dict, Optional
from fastapi import Request, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from collections import defaultdict, deque
from datetime import datetime, timedelta

class RateLimiter:
    """é€Ÿç‡é™åˆ¶å™¨"""
    
    def __init__(self, max_requests: int = 60, window_seconds: int = 60):
        self.max_requests = max_requests
        self.window_seconds = window_seconds
        self.requests: Dict[str, deque] = defaultdict(deque)
    
    def is_allowed(self, identifier: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦å…è®¸è¯·æ±‚"""
        now = time.time()
        window_start = now - self.window_seconds
        
        # æ¸…ç†è¿‡æœŸè®°å½•
        request_times = self.requests[identifier]
        while request_times and request_times[0] < window_start:
            request_times.popleft()
        
        # æ£€æŸ¥æ˜¯å¦è¶…å‡ºé™åˆ¶
        if len(request_times) >= self.max_requests:
            return False
        
        # è®°å½•å½“å‰è¯·æ±‚
        request_times.append(now)
        return True

class SecurityMiddleware:
    """å®‰å…¨ä¸­é—´ä»¶"""
    
    def __init__(self):
        self.rate_limiter = RateLimiter()
        self.blocked_ips = set()
        self.suspicious_activities = defaultdict(int)
    
    async def __call__(self, request: Request, call_next):
        # è·å–å®¢æˆ·ç«¯IP
        client_ip = self._get_client_ip(request)
        
        # æ£€æŸ¥IPé»‘åå•
        if client_ip in self.blocked_ips:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="IPåœ°å€å·²è¢«å°ç¦"
            )
        
        # é€Ÿç‡é™åˆ¶
        if not self.rate_limiter.is_allowed(client_ip):
            self._record_suspicious_activity(client_ip, "rate_limit_exceeded")
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail="è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•"
            )
        
        # æ£€æŸ¥è¯·æ±‚å¤´
        self._validate_headers(request)
        
        # å¤„ç†è¯·æ±‚
        start_time = time.time()
        response = await call_next(request)
        process_time = time.time() - start_time
        
        # æ·»åŠ å®‰å…¨å“åº”å¤´
        self._add_security_headers(response)
        
        # è®°å½•å“åº”æ—¶é—´ï¼ˆæ£€æµ‹å¼‚å¸¸ï¼‰
        if process_time > 5.0:  # è¶…è¿‡5ç§’è®¤ä¸ºå¼‚å¸¸
            self._record_suspicious_activity(client_ip, "slow_response")
        
        return response
    
    def _get_client_ip(self, request: Request) -> str:
        """è·å–å®¢æˆ·ç«¯çœŸå®IP"""
        # æ£€æŸ¥ä»£ç†å¤´
        forwarded_for = request.headers.get("X-Forwarded-For")
        if forwarded_for:
            return forwarded_for.split(",")[0].strip()
        
        real_ip = request.headers.get("X-Real-IP")
        if real_ip:
            return real_ip
        
        return request.client.host if request.client else "unknown"
    
    def _validate_headers(self, request: Request):
        """éªŒè¯è¯·æ±‚å¤´"""
        # æ£€æŸ¥User-Agent
        user_agent = request.headers.get("User-Agent", "")
        if not user_agent or len(user_agent) > 500:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="æ— æ•ˆçš„User-Agent"
            )
        
        # æ£€æŸ¥Content-Length
        content_length = request.headers.get("Content-Length")
        if content_length and int(content_length) > 10 * 1024 * 1024:  # 10MBé™åˆ¶
            raise HTTPException(
                status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
                detail="è¯·æ±‚ä½“è¿‡å¤§"
            )
    
    def _add_security_headers(self, response):
        """æ·»åŠ å®‰å…¨å“åº”å¤´"""
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
        response.headers["Referrer-Policy"] = "strict-origin-when-cross-origin"
    
    def _record_suspicious_activity(self, ip: str, activity_type: str):
        """è®°å½•å¯ç–‘æ´»åŠ¨"""
        key = f"{ip}:{activity_type}"
        self.suspicious_activities[key] += 1
        
        # å¦‚æœåŒä¸€IPçš„å¯ç–‘æ´»åŠ¨è¿‡å¤šï¼ŒåŠ å…¥é»‘åå•
        total_suspicious = sum(
            count for k, count in self.suspicious_activities.items()
            if k.startswith(f"{ip}:")
        )
        
        if total_suspicious >= 10:
            self.blocked_ips.add(ip)
            # è®°å½•åˆ°å®‰å…¨æ—¥å¿—
            from ..core.logging import security_logger
            security_logger.warning(
                f"IP {ip} å·²è¢«è‡ªåŠ¨å°ç¦",
                ip_address=ip,
                suspicious_count=total_suspicious
            )

class APIKeyAuth(HTTPBearer):
    """APIå¯†é’¥è®¤è¯"""
    
    def __init__(self, auto_error: bool = True):
        super().__init__(auto_error=auto_error)
        self.valid_api_keys = set()  # ä»é…ç½®æˆ–æ•°æ®åº“åŠ è½½
    
    async def __call__(self, request: Request) -> Optional[str]:
        credentials: HTTPAuthorizationCredentials = await super().__call__(request)
        
        if credentials:
            api_key = credentials.credentials
            if self._validate_api_key(api_key):
                return api_key
            else:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="æ— æ•ˆçš„APIå¯†é’¥"
                )
        
        return None
    
    def _validate_api_key(self, api_key: str) -> bool:
        """éªŒè¯APIå¯†é’¥"""
        # ç®€å•çš„å“ˆå¸ŒéªŒè¯ï¼ˆç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ•°æ®åº“ï¼‰
        api_key_hash = hashlib.sha256(api_key.encode()).hexdigest()
        return api_key_hash in self.valid_api_keys
```

### 11.3 æ•°æ®è„±æ•

```python
# utils/data_masking.py
import re
from typing import Any, Dict, List, Union

class DataMasker:
    """æ•°æ®è„±æ•å™¨"""
    
    # æ•æ„Ÿå­—æ®µæ¨¡å¼
    SENSITIVE_PATTERNS = {
        'password': r'password|pwd|passwd',
        'email': r'email|mail',
        'phone': r'phone|mobile|tel',
        'id_card': r'id_card|identity|idcard',
        'credit_card': r'card_number|credit_card',
        'license_key': r'license_key|key|token'
    }
    
    @classmethod
    def mask_dict(cls, data: Dict[str, Any], mask_license_keys: bool = False) -> Dict[str, Any]:
        """è„±æ•å­—å…¸æ•°æ®"""
        if not isinstance(data, dict):
            return data
        
        masked_data = {}
        
        for key, value in data.items():
            key_lower = key.lower()
            
            # é€’å½’å¤„ç†åµŒå¥—å­—å…¸
            if isinstance(value, dict):
                masked_data[key] = cls.mask_dict(value, mask_license_keys)
            elif isinstance(value, list):
                masked_data[key] = [cls.mask_dict(item, mask_license_keys) if isinstance(item, dict) else item for item in value]
            else:
                # æ£€æŸ¥æ˜¯å¦ä¸ºæ•æ„Ÿå­—æ®µ
                if cls._is_sensitive_field(key_lower, mask_license_keys):
                    masked_data[key] = cls._mask_value(value, key_lower)
                else:
                    masked_data[key] = value
        
        return masked_data
    
    @classmethod
    def _is_sensitive_field(cls, field_name: str, mask_license_keys: bool = False) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæ•æ„Ÿå­—æ®µ"""
        for pattern_type, pattern in cls.SENSITIVE_PATTERNS.items():
            if pattern_type == 'license_key' and not mask_license_keys:
                continue
            
            if re.search(pattern, field_name, re.IGNORECASE):
                return True
        
        return False
    
    @classmethod
    def _mask_value(cls, value: Any, field_type: str) -> str:
        """è„±æ•å€¼"""
        if value is None:
            return None
        
        value_str = str(value)
        
        if not value_str:
            return value_str
        
        # æ ¹æ®å­—æ®µç±»å‹é€‰æ‹©è„±æ•ç­–ç•¥
        if 'password' in field_type:
            return '***'
        elif 'email' in field_type:
            return cls._mask_email(value_str)
        elif 'phone' in field_type:
            return cls._mask_phone(value_str)
        elif 'license' in field_type or 'key' in field_type:
            return cls._mask_license_key(value_str)
        else:
            # é»˜è®¤è„±æ•ç­–ç•¥
            return cls._mask_default(value_str)
    
    @classmethod
    def _mask_email(cls, email: str) -> str:
        """è„±æ•é‚®ç®±"""
        if '@' not in email:
            return cls._mask_default(email)
        
        local, domain = email.split('@', 1)
        if len(local) <= 2:
            masked_local = '*' * len(local)
        else:
            masked_local = local[0] + '*' * (len(local) - 2) + local[-1]
        
        return f"{masked_local}@{domain}"
    
    @classmethod
    def _mask_phone(cls, phone: str) -> str:
        """è„±æ•æ‰‹æœºå·"""
        # ç§»é™¤éæ•°å­—å­—ç¬¦
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) < 7:
            return '*' * len(phone)
        
        # ä¿ç•™å‰3ä½å’Œå4ä½
        if len(digits) >= 11:
            return digits[:3] + '*' * (len(digits) - 7) + digits[-4:]
        else:
            return digits[:2] + '*' * (len(digits) - 4) + digits[-2:]
    
    @classmethod
    def _mask_license_key(cls, license_key: str) -> str:
        """è„±æ•å¡å¯†"""
        if len(license_key) <= 8:
            return '*' * len(license_key)
        
        # ä¿ç•™å‰4ä½å’Œå4ä½
        return license_key[:4] + '*' * (len(license_key) - 8) + license_key[-4:]
    
    @classmethod
    def _mask_default(cls, value: str) -> str:
        """é»˜è®¤è„±æ•ç­–ç•¥"""
        if len(value) <= 2:
            return '*' * len(value)
        elif len(value) <= 6:
            return value[0] + '*' * (len(value) - 2) + value[-1]
        else:
            return value[:2] + '*' * (len(value) - 4) + value[-2:]

# ä½¿ç”¨ç¤ºä¾‹
def mask_log_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """è„±æ•æ—¥å¿—æ•°æ®"""
    return DataMasker.mask_dict(data, mask_license_keys=True)

def mask_api_response(data: Dict[str, Any]) -> Dict[str, Any]:
    """è„±æ•APIå“åº”æ•°æ®"""
    return DataMasker.mask_dict(data, mask_license_keys=False)
```

## 12. é¡¹ç›®æ€»ç»“

### 12.1 æŠ€æœ¯æ¶æ„æ€»ç»“

æœ¬é‡‘é±¼æ™ºç›’å¡å¯†æˆæƒç³»ç»Ÿé‡‡ç”¨ç°ä»£åŒ–çš„å‰åç«¯åˆ†ç¦»æ¶æ„ï¼Œå…·å¤‡ä»¥ä¸‹æ ¸å¿ƒç‰¹æ€§ï¼š

#### 12.1.1 æŠ€æœ¯æ ˆé€‰æ‹©

**å‰ç«¯æŠ€æœ¯æ ˆ**ï¼š
- **React 18** + **Next.js 14**ï¼šæä¾›ç°ä»£åŒ–çš„ç”¨æˆ·ç•Œé¢å’ŒæœåŠ¡ç«¯æ¸²æŸ“èƒ½åŠ›
- **TypeScript**ï¼šå¢å¼ºä»£ç ç±»å‹å®‰å…¨å’Œå¼€å‘ä½“éªŒ
- **Tailwind CSS**ï¼šå®ç°å“åº”å¼å’Œç¾è§‚çš„UIè®¾è®¡
- **React Query**ï¼šä¼˜åŒ–æ•°æ®è·å–å’ŒçŠ¶æ€ç®¡ç†
- **Zustand**ï¼šè½»é‡çº§å…¨å±€çŠ¶æ€ç®¡ç†

**åç«¯æŠ€æœ¯æ ˆ**ï¼š
- **FastAPI**ï¼šé«˜æ€§èƒ½å¼‚æ­¥Webæ¡†æ¶ï¼Œè‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£
- **SQLAlchemy**ï¼šå¼ºå¤§çš„ORMæ¡†æ¶ï¼Œæ”¯æŒæ•°æ®åº“è¿ç§»
- **PostgreSQL**ï¼šå¯é çš„å…³ç³»å‹æ•°æ®åº“
- **Redis**ï¼šé«˜æ€§èƒ½ç¼“å­˜å’Œä¼šè¯å­˜å‚¨
- **Alembic**ï¼šæ•°æ®åº“ç‰ˆæœ¬æ§åˆ¶å’Œè¿ç§»

#### 12.1.2 ç³»ç»Ÿæ¶æ„ä¼˜åŠ¿

1. **é«˜å¯ç”¨æ€§**ï¼šé€šè¿‡Dockerå®¹å™¨åŒ–éƒ¨ç½²ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
2. **é«˜æ€§èƒ½**ï¼šRedisç¼“å­˜æœºåˆ¶ï¼Œæ•°æ®åº“è¿æ¥æ± ä¼˜åŒ–
3. **é«˜å®‰å…¨æ€§**ï¼šå¤šå±‚å®‰å…¨é˜²æŠ¤ï¼Œæ•°æ®åŠ å¯†å­˜å‚¨
4. **æ˜“ç»´æŠ¤æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ¸…æ™°çš„ä»£ç ç»“æ„
5. **æ˜“æ‰©å±•æ€§**ï¼šäº‹ä»¶é©±åŠ¨æ¶æ„ï¼Œæ”¯æŒåŠŸèƒ½æ¨¡å—ç‹¬ç«‹æ‰©å±•

### 12.2 æ ¸å¿ƒåŠŸèƒ½å®ç°

#### 12.2.1 å¡å¯†ç®¡ç†ç³»ç»Ÿ

- **å¡å¯†ç”Ÿæˆ**ï¼šé‡‡ç”¨å¯†ç å­¦å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆï¼Œé¿å…å†²çªå’ŒçŒœæµ‹
- **è®¾å¤‡ç»‘å®š**ï¼šåŸºäºç¡¬ä»¶æŒ‡çº¹çš„è®¾å¤‡è¯†åˆ«å’Œç»‘å®šé™åˆ¶
- **çŠ¶æ€ç®¡ç†**ï¼šå®Œæ•´çš„å¡å¯†ç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆå¾…æ¿€æ´»â†’å·²æ¿€æ´»â†’å·²è¿‡æœŸâ†’å·²æš‚åœï¼‰
- **æ‰¹é‡æ“ä½œ**ï¼šæ”¯æŒæ‰¹é‡ç”Ÿæˆã€å¯¼å‡ºå’Œç®¡ç†å¡å¯†

#### 12.2.2 ç”¨æˆ·æƒé™ç³»ç»Ÿ

- **è§’è‰²åˆ†ç¦»**ï¼šç®¡ç†å‘˜å’Œæ™®é€šç”¨æˆ·çš„æƒé™éš”ç¦»
- **JWTè®¤è¯**ï¼šæ— çŠ¶æ€çš„èº«ä»½éªŒè¯æœºåˆ¶
- **ä¼šè¯ç®¡ç†**ï¼šæ”¯æŒå¤šè®¾å¤‡ç™»å½•å’Œä¼šè¯æ§åˆ¶
- **æ“ä½œå®¡è®¡**ï¼šå®Œæ•´çš„ç”¨æˆ·æ“ä½œæ—¥å¿—è®°å½•

#### 12.2.3 åº”ç”¨ç®¡ç†æ¨¡å—

- **åº”ç”¨æ³¨å†Œ**ï¼šæ”¯æŒå¤šåº”ç”¨ç®¡ç†å’Œç‰ˆæœ¬æ§åˆ¶
- **ç»´æŠ¤æ¨¡å¼**ï¼šåº”ç”¨ç»´æŠ¤æœŸé—´çš„è®¿é—®æ§åˆ¶
- **å…¬å‘Šç³»ç»Ÿ**ï¼šå®æ—¶æ¶ˆæ¯æ¨é€å’Œå…¬å‘Šç®¡ç†
- **ç»Ÿè®¡åˆ†æ**ï¼šåº”ç”¨ä½¿ç”¨æƒ…å†µå’Œå¡å¯†åˆ†å¸ƒç»Ÿè®¡

### 12.3 å®‰å…¨ä¿éšœæªæ–½

#### 12.3.1 æ•°æ®å®‰å…¨

- **åŠ å¯†å­˜å‚¨**ï¼šæ•æ„Ÿæ•°æ®ä½¿ç”¨AES-256åŠ å¯†
- **ä¼ è¾“å®‰å…¨**ï¼šHTTPSåè®®å’ŒTLSåŠ å¯†
- **å¯†ç å®‰å…¨**ï¼šPBKDF2å“ˆå¸Œç®—æ³•ï¼Œé˜²å½©è™¹è¡¨æ”»å‡»
- **æ•°æ®è„±æ•**ï¼šæ—¥å¿—å’ŒAPIå“åº”çš„æ•æ„Ÿä¿¡æ¯è„±æ•

#### 12.3.2 è®¿é—®æ§åˆ¶

- **é€Ÿç‡é™åˆ¶**ï¼šé˜²æ­¢æš´åŠ›ç ´è§£å’ŒDDoSæ”»å‡»
- **IPé»‘åå•**ï¼šè‡ªåŠ¨æ£€æµ‹å’Œå°ç¦æ¶æ„IP
- **APIå¯†é’¥**ï¼šå®¢æˆ·ç«¯åº”ç”¨çš„èº«ä»½éªŒè¯
- **CORSç­–ç•¥**ï¼šè·¨åŸŸè¯·æ±‚çš„å®‰å…¨æ§åˆ¶

#### 12.3.3 ç›‘æ§å‘Šè­¦

- **å®æ—¶ç›‘æ§**ï¼šç³»ç»Ÿæ€§èƒ½å’Œä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
- **å¼‚å¸¸æ£€æµ‹**ï¼šè‡ªåŠ¨è¯†åˆ«å¼‚å¸¸è¡Œä¸ºå’Œå®‰å…¨å¨èƒ
- **æ—¥å¿—å®¡è®¡**ï¼šç»“æ„åŒ–æ—¥å¿—è®°å½•å’Œåˆ†æ
- **å¥åº·æ£€æŸ¥**ï¼šæœåŠ¡å¯ç”¨æ€§ç›‘æ§å’Œè‡ªåŠ¨æ¢å¤

### 12.4 éƒ¨ç½²è¿ç»´æ–¹æ¡ˆ

#### 12.4.1 å®¹å™¨åŒ–éƒ¨ç½²

- **Dockeré•œåƒ**ï¼šæ ‡å‡†åŒ–çš„åº”ç”¨æ‰“åŒ…å’Œåˆ†å‘
- **Docker Compose**ï¼šæœ¬åœ°å¼€å‘å’Œæµ‹è¯•ç¯å¢ƒ
- **å¤šé˜¶æ®µæ„å»º**ï¼šä¼˜åŒ–é•œåƒå¤§å°å’Œå®‰å…¨æ€§
- **å¥åº·æ£€æŸ¥**ï¼šå®¹å™¨çŠ¶æ€ç›‘æ§å’Œè‡ªåŠ¨é‡å¯

#### 12.4.2 ç”Ÿäº§ç¯å¢ƒä¼˜åŒ–

- **è´Ÿè½½å‡è¡¡**ï¼šNginxåå‘ä»£ç†å’Œè´Ÿè½½åˆ†å‘
- **æ•°æ®åº“ä¼˜åŒ–**ï¼šè¿æ¥æ± ã€ç´¢å¼•ä¼˜åŒ–ã€è¯»å†™åˆ†ç¦»
- **ç¼“å­˜ç­–ç•¥**ï¼šå¤šçº§ç¼“å­˜å’Œç¼“å­˜é¢„çƒ­
- **å¤‡ä»½æ¢å¤**ï¼šè‡ªåŠ¨åŒ–æ•°æ®å¤‡ä»½å’Œç¾éš¾æ¢å¤

### 12.5 æµ‹è¯•ä¿éšœä½“ç³»

#### 12.5.1 æµ‹è¯•è¦†ç›–

- **å•å…ƒæµ‹è¯•**ï¼šæ ¸å¿ƒä¸šåŠ¡é€»è¾‘çš„å•å…ƒæµ‹è¯•è¦†ç›–
- **é›†æˆæµ‹è¯•**ï¼šAPIæ¥å£å’Œæ•°æ®åº“äº¤äº’æµ‹è¯•
- **æ€§èƒ½æµ‹è¯•**ï¼šå¹¶å‘å‹åŠ›å’Œå“åº”æ—¶é—´æµ‹è¯•
- **å®‰å…¨æµ‹è¯•**ï¼šæ¼æ´æ‰«æå’Œæ¸—é€æµ‹è¯•

#### 12.5.2 è´¨é‡ä¿è¯

- **ä»£ç å®¡æŸ¥**ï¼šPull Requestä»£ç å®¡æŸ¥æµç¨‹
- **è‡ªåŠ¨åŒ–æµ‹è¯•**ï¼šCI/CDæµæ°´çº¿é›†æˆæµ‹è¯•
- **ä»£ç è¦†ç›–ç‡**ï¼šæµ‹è¯•è¦†ç›–ç‡ç›‘æ§å’ŒæŠ¥å‘Š
- **æ€§èƒ½åŸºå‡†**ï¼šæ€§èƒ½æŒ‡æ ‡åŸºå‡†å’Œå›å½’æµ‹è¯•

### 12.6 é¡¹ç›®äº®ç‚¹ä¸åˆ›æ–°

#### 12.6.1 æŠ€æœ¯åˆ›æ–°

1. **äº‹ä»¶é©±åŠ¨æ¶æ„**ï¼šæ¨¡å—é—´æ¾è€¦åˆçš„äº‹ä»¶é€šä¿¡æœºåˆ¶
2. **æ™ºèƒ½ç¼“å­˜ç­–ç•¥**ï¼šå¤šçº§ç¼“å­˜å’Œç¼“å­˜å¤±æ•ˆç­–ç•¥
3. **è‡ªé€‚åº”å®‰å…¨é˜²æŠ¤**ï¼šåŸºäºè¡Œä¸ºåˆ†æçš„å®‰å…¨é˜²æŠ¤
4. **å®æ—¶æ•°æ®åŒæ­¥**ï¼šWebSocketå®æ—¶æ•°æ®æ¨é€

#### 12.6.2 ç”¨æˆ·ä½“éªŒä¼˜åŒ–

1. **å“åº”å¼è®¾è®¡**ï¼šé€‚é…å¤šç§è®¾å¤‡å’Œå±å¹•å°ºå¯¸
2. **æ¸è¿›å¼åŠ è½½**ï¼šä¼˜åŒ–é¡µé¢åŠ è½½æ€§èƒ½
3. **ç¦»çº¿æ”¯æŒ**ï¼šService Workerç¦»çº¿ç¼“å­˜
4. **å›½é™…åŒ–æ”¯æŒ**ï¼šå¤šè¯­è¨€ç•Œé¢æ”¯æŒ

### 12.7 æœªæ¥å‘å±•è§„åˆ’

#### 12.7.1 åŠŸèƒ½æ‰©å±•

- **ç§»åŠ¨ç«¯åº”ç”¨**ï¼šiOSå’ŒAndroidåŸç”Ÿåº”ç”¨
- **APIç½‘å…³**ï¼šç»Ÿä¸€çš„APIç®¡ç†å’Œé™æµ
- **æ•°æ®åˆ†æ**ï¼šç”¨æˆ·è¡Œä¸ºåˆ†æå’Œå•†ä¸šæ™ºèƒ½
- **ç¬¬ä¸‰æ–¹é›†æˆ**ï¼šæ”¯ä»˜ç³»ç»Ÿå’Œç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆ

#### 12.7.2 æŠ€æœ¯å‡çº§

- **å¾®æœåŠ¡æ¶æ„**ï¼šæœåŠ¡æ‹†åˆ†å’Œç‹¬ç«‹éƒ¨ç½²
- **äº‘åŸç”Ÿéƒ¨ç½²**ï¼šKuberneteså®¹å™¨ç¼–æ’
- **AIæ™ºèƒ½åŒ–**ï¼šæœºå™¨å­¦ä¹ å¼‚å¸¸æ£€æµ‹
- **åŒºå—é“¾æŠ€æœ¯**ï¼šå»ä¸­å¿ƒåŒ–çš„æˆæƒéªŒè¯

### 12.8 å¼€å‘å›¢é˜Ÿå»ºè®®

#### 12.8.1 å¼€å‘è§„èŒƒ

1. **ä»£ç è§„èŒƒ**ï¼šç»Ÿä¸€çš„ä»£ç é£æ ¼å’Œå‘½åè§„èŒƒ
2. **Gitå·¥ä½œæµ**ï¼šæ ‡å‡†åŒ–çš„åˆ†æ”¯ç®¡ç†å’Œæäº¤è§„èŒƒ
3. **æ–‡æ¡£ç»´æŠ¤**ï¼šåŠæ—¶æ›´æ–°æŠ€æœ¯æ–‡æ¡£å’ŒAPIæ–‡æ¡£
4. **å®‰å…¨æ„è¯†**ï¼šå®šæœŸå®‰å…¨åŸ¹è®­å’Œæ¼æ´ä¿®å¤

#### 12.8.2 è¿ç»´å»ºè®®

1. **ç›‘æ§å‘Šè­¦**ï¼šå®Œå–„çš„ç›‘æ§ä½“ç³»å’Œå‘Šè­¦æœºåˆ¶
2. **å¤‡ä»½ç­–ç•¥**ï¼šå®šæœŸæ•°æ®å¤‡ä»½å’Œæ¢å¤æ¼”ç»ƒ
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šæŒç»­çš„æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–
4. **å®‰å…¨åŠ å›º**ï¼šå®šæœŸå®‰å…¨å®¡è®¡å’Œæ¼æ´æ‰«æ

---

**é¡¹ç›®æ€»ç»“**ï¼šé‡‘é±¼æ™ºç›’å¡å¯†æˆæƒç³»ç»Ÿæ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€æ¶æ„åˆç†ã€å®‰å…¨å¯é çš„ä¼ä¸šçº§æˆæƒç®¡ç†å¹³å°ã€‚é€šè¿‡ç°ä»£åŒ–çš„æŠ€æœ¯æ ˆå’Œå®Œå–„çš„å®‰å…¨æœºåˆ¶ï¼Œä¸ºè½¯ä»¶å¼€å‘å•†æä¾›äº†ä¸“ä¸šçš„æˆæƒè§£å†³æ–¹æ¡ˆã€‚ç³»ç»Ÿå…·å¤‡è‰¯å¥½çš„æ‰©å±•æ€§å’Œç»´æŠ¤æ€§ï¼Œèƒ½å¤Ÿæ»¡è¶³ä¸åŒè§„æ¨¡ä¼ä¸šçš„æˆæƒç®¡ç†éœ€æ±‚ã€‚

æœ¬æ–‡æ¡£æ¶µç›–äº†ä»éœ€æ±‚åˆ†æåˆ°éƒ¨ç½²è¿ç»´çš„å®Œæ•´å¼€å‘æµç¨‹ï¼Œä¸ºå¼€å‘å›¢é˜Ÿæä¾›äº†è¯¦ç»†çš„æŠ€æœ¯æŒ‡å¯¼å’Œæœ€ä½³å®è·µã€‚å¸Œæœ›èƒ½å¤Ÿå¸®åŠ©å¼€å‘è€…å¿«é€Ÿç†è§£å’Œå®æ–½è¿™ä¸€æˆæƒç³»ç»Ÿï¼Œä¸ºè½¯ä»¶äº§å“çš„å•†ä¸šåŒ–è¿è¥æä¾›å¼ºæœ‰åŠ›çš„æŠ€æœ¯æ”¯æ’‘ã€‚

#### 7.5.2 å¡å¯†ç®¡ç†ç»„ä»¶

```tsx
// components/licenses/LicenseList.tsx
import React, { useEffect, useState } from 'react';
import { useLicenseStore } from '../../store/licenseStore';
import { Button } from '../common/Button';
import { Table } from '../common/Table';
import { Badge } from '../common/Badge';
import { Pagination } from '../common/Pagination';
import { SearchFilter } from '../common/SearchFilter';
import { License } from '../../types/license';

export const LicenseList: React.FC = () => {
  const {
    licenses,
    total,
    isLoading,
    error,
    fetchLicenses,
    deleteLicense,
    clearError
  } = useLicenseStore();
  
  const [currentPage, setCurrentPage] = useState(1);
  const [pageSize] = useState(20);
  const [filters, setFilters] = useState({
    app_id: undefined as number | undefined,
    status: undefined as string | undefined
  });
  
  useEffect(() => {
    fetchLicenses({
      page: currentPage,
      page_size: pageSize,
      ...filters
    });
  }, [currentPage, pageSize, filters]);
  
  const handleDelete = async (id: number) => {
    if (window.confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¡å¯†å—ï¼Ÿ')) {
      try {
        await deleteLicense(id);
      } catch (error) {
        // é”™è¯¯å·²åœ¨storeä¸­å¤„ç†
      }
    }
  };
  
  const getStatusBadge = (status: string) => {
    const statusConfig = {
      active: { color: 'green', text: 'æ¿€æ´»' },
      expired: { color: 'red', text: 'è¿‡æœŸ' },
      suspended: { color: 'yellow', text: 'æš‚åœ' },
      pending: { color: 'gray', text: 'å¾…æ¿€æ´»' }
    };
    
    const config = statusConfig[status as keyof typeof statusConfig] || 
                   { color: 'gray', text: status };
    
    return <Badge color={config.color}>{config.text}</Badge>;
  };
  
  const columns = [
    {
      key: 'license_key',
      title: 'å¡å¯†',
      render: (license: License) => (
        <code className="text-sm bg-gray-100 px-2 py-1 rounded">
          {license.license_key}
        </code>
      )
    },
    {
      key: 'application_name',
      title: 'åº”ç”¨',
      render: (license: License) => license.application_name || '-'
    },
    {
      key: 'username',
      title: 'ç”¨æˆ·',
      render: (license: License) => license.username || '-'
    },
    {
      key: 'status',
      title: 'çŠ¶æ€',
      render: (license: License) => getStatusBadge(license.status)
    },
    {
      key: 'device_usage',
      title: 'è®¾å¤‡ä½¿ç”¨',
      render: (license: License) => (
        <span className={license.bound_devices >= license.device_limit ? 'text-red-600' : ''}>
          {license.bound_devices}/{license.device_limit}
        </span>
      )
    },
    {
      key: 'expires_at',
      title: 'è¿‡æœŸæ—¶é—´',
      render: (license: License) => 
        new Date(license.expires_at).toLocaleString('zh-CN')
    },
    {
      key: 'actions',
      title: 'æ“ä½œ',
      render: (license: License) => (
        <div className="flex space-x-2">
          <Button
            size="small"
            variant="outline"
            onClick={() => {/* ç¼–è¾‘é€»è¾‘ */}}
          >
            ç¼–è¾‘
          </Button>
          <Button
            size="small"
            variant="danger"
            onClick={() => handleDelete(license.id)}
          >
            åˆ é™¤
          </Button>
        </div>
      )
    }
  ];
  
  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-900">å¡å¯†ç®¡ç†</h1>
        <Button variant="primary">
          åˆ›å»ºå¡å¯†
        </Button>
      </div>
      
      <SearchFilter
        filters={[
          {
            key: 'status',
            label: 'çŠ¶æ€',
            type: 'select',
            options: [
              { value: '', label: 'å…¨éƒ¨' },
              { value: 'active', label: 'æ¿€æ´»' },
              { value: 'expired', label: 'è¿‡æœŸ' },
              { value: 'suspended', label: 'æš‚åœ' },
              { value: 'pending', label: 'å¾…æ¿€æ´»' }
            ]
          }
        ]}
        onFilterChange={setFilters}
      />
      
      {error && (
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
          {error}
          <button 
            onClick={clearError}
            className="ml-2 text-red-500 hover:text-red-700"
          >
            Ã—
          </button>
        </div>
      )}
      
      <Table
        columns={columns}
        data={licenses}
        loading={isLoading}
        emptyText="æš‚æ— å¡å¯†æ•°æ®"
      />
      
      <Pagination
        current={currentPage}
        total={total}
        pageSize={pageSize}
        onChange={setCurrentPage}
      />
    </div>
  );
};
```