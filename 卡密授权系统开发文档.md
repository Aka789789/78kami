# 卡密授权系统开发文档

## 1. 系统概述

### 1.1 项目背景

金鱼智盒卡密授权系统是一套企业级Python桌面应用授权解决方案，采用账号密码与卡密双重验证机制，确保应用程序的安全分发与使用控制。系统基于前后端分离架构设计，支持多应用管理、设备绑定、实时监控等核心功能。

### 1.2 核心目标

- **双重验证机制**：账号密码登录 + 卡密激活验证
- **设备绑定控制**：基于硬件ID的设备唯一性验证
- **实时状态监控**：WebSocket实时推送系统状态与公告
- **企业级管理**：多应用统一管理、权限分级控制
- **数据安全保障**：AES-256加密、bcrypt密码存储

### 1.3 技术参数

| 参数项 | 配置值 |
|--------|--------|
| 前端端口 | 8990 |
| 后端端口 | 8000 |
| 初始管理员账号 | admin |
| 初始管理员密码 | admin1314159 |
| 数据库类型 | PostgreSQL/MySQL/SQLite |
| 缓存系统 | Redis |
| 加密算法 | AES-256 |
| 密码加密 | bcrypt |

## 2. 技术架构

### 2.1 整体架构

```mermaid
graph TB
    subgraph "前端层 (React + Next.js)"
        A[用户界面] --> B[状态管理]
        B --> C[API客户端]
        C --> D[WebSocket客户端]
    end
    
    subgraph "后端层 (FastAPI)"
        E[API网关] --> F[认证中间件]
        F --> G[业务服务层]
        G --> H[数据访问层]
        I[WebSocket服务] --> J[事件处理器]
    end
    
    subgraph "数据层"
        K[PostgreSQL]
        L[Redis缓存]
        M[文件存储]
    end
    
    C --> E
    D --> I
    H --> K
    G --> L
    G --> M
```

### 2.2 技术栈

#### 前端技术栈
- **框架**：React 18 + Next.js 14
- **状态管理**：Zustand
- **UI组件库**：Ant Design
- **HTTP客户端**：Axios
- **WebSocket**：原生WebSocket API
- **构建工具**：Webpack + Babel

#### 后端技术栈
- **框架**：FastAPI 0.104+
- **异步运行时**：uvicorn + asyncio
- **数据库ORM**：SQLAlchemy 2.0
- **认证授权**：JWT + OAuth2
- **缓存系统**：Redis
- **任务队列**：Celery (可选)
- **API文档**：OpenAPI 3.0 + Swagger UI

### 2.3 部署架构

```mermaid
graph LR
    subgraph "生产环境"
        A[Nginx反向代理] --> B[前端静态资源]
        A --> C[后端API服务]
        C --> D[PostgreSQL主库]
        C --> E[Redis集群]
        C --> F[文件存储NFS]
    end
    
    subgraph "开发环境"
        G[前端开发服务器:8990] --> H[后端开发服务器:77889]
        H --> I[本地PostgreSQL]
        H --> J[本地Redis]
    end
```

## 3. 功能模块

### 3.1 用户认证模块

#### 核心定位
负责系统用户的身份验证、权限管理及会话控制，支持管理员与普通用户的分级权限体系。

#### 详细功能

| 子功能 | 详细描述 | 操作流程 |
|--------|----------|----------|
| 用户登录 | 账号密码验证 + JWT令牌生成 | 输入凭据→验证身份→生成令牌→返回用户信息 |
| 权限验证 | 基于角色的访问控制(RBAC) | 解析令牌→检查权限→允许/拒绝访问 |
| 会话管理 | 令牌刷新、登出、超时控制 | 监控会话→自动刷新→超时登出 |
| 密码管理 | 密码修改、重置、强度验证 | 验证旧密码→检查强度→bcrypt加密存储 |
| 用户注册 | 新用户创建、邮箱验证 | 填写信息→邮箱验证→创建账户→分配权限 |

#### 业务规则
- 密码强度要求：至少8位，包含大小写字母、数字、特殊字符
- JWT令牌有效期：访问令牌2小时，刷新令牌7天
- 登录失败锁定：连续5次失败锁定30分钟
- 会话并发限制：同一用户最多3个活跃会话

### 3.2 应用管理模块

#### 核心定位
统一管理需要授权的桌面应用程序，包括应用注册、版本控制、配置管理及状态监控。

#### 详细功能

| 子功能 | 详细描述 | 操作流程 |
|--------|----------|----------|
| 应用注册 | 新应用接入系统 | 填写应用信息→上传图标→生成应用ID→配置参数 |
| 版本管理 | 应用版本发布与回滚 | 上传新版本→设置更新策略→推送更新通知 |
| 配置管理 | 应用运行参数配置 | 设置启动参数→配置授权策略→保存配置 |
| 状态监控 | 应用运行状态实时监控 | 收集状态数据→分析异常→生成报告 |
| 维护模式 | 应用维护状态控制 | 开启维护模式→推送公告→禁止新登录 |

#### 业务规则
- 应用ID生成规则：UUID格式，全局唯一
- 版本号格式：语义化版本(SemVer)，如1.2.3
- 图标文件限制：PNG/JPG格式，最大2MB，推荐256x256像素
- 维护模式下：禁止新用户登录，已登录用户可继续使用

### 3.3 卡密管理模块

#### 核心定位
卡密授权系统的核心模块，负责卡密的生成、分发、激活、验证及生命周期管理。

#### 详细功能

| 子功能 | 详细描述 | 操作流程 |
|--------|----------|----------|
| 卡密生成 | 批量生成授权卡密 | 设置生成参数→选择应用→批量生成→导出卡密 |
| 卡密激活 | 用户激活卡密获得授权 | 输入卡密→验证有效性→绑定设备→激活成功 |
| 使用验证 | 应用启动时验证卡密 | 读取本地授权→验证服务器→检查有效期→允许启动 |
| 状态管理 | 卡密状态跟踪与控制 | 监控使用状态→处理异常→更新状态 |
| 批量操作 | 卡密批量导入导出 | 选择操作类型→上传文件→批量处理→生成报告 |

#### 业务规则
- 卡密格式：16位字符，包含数字和大写字母，分4组显示
- 卡密状态：未激活、已激活、已过期、已禁用、已删除
- 激活限制：每个卡密只能激活一次，绑定一台设备
- 有效期类型：永久、按天数、按截止日期
- 设备绑定：基于CPU ID、主板序列号、MAC地址生成唯一标识

### 3.4 设备管理模块

#### 核心定位
管理已授权设备的信息、状态及安全控制，确保授权设备的唯一性和可追溯性。

#### 详细功能

| 子功能 | 详细描述 | 操作流程 |
|--------|----------|----------|
| 设备注册 | 新设备首次激活注册 | 获取硬件信息→生成设备指纹→注册到系统 |
| 设备绑定 | 卡密与设备关联绑定 | 验证设备信息→检查绑定限制→建立绑定关系 |
| 状态监控 | 设备在线状态跟踪 | 定期心跳检测→更新在线状态→异常告警 |
| 解绑操作 | 设备授权解除绑定 | 验证权限→解除绑定→释放授权额度 |
| 黑名单管理 | 异常设备黑名单控制 | 检测异常行为→加入黑名单→禁止访问 |

#### 业务规则
- 设备指纹算法：MD5(CPU_ID + 主板序列号 + MAC地址)
- 绑定数量限制：每个卡密最多绑定1台设备
- 心跳间隔：客户端每5分钟发送一次心跳
- 离线判定：超过15分钟未收到心跳视为离线
- 黑名单策略：异常设备永久禁止，可手动解除

### 3.5 公告管理模块

#### 核心定位
系统公告的发布、推送及展示管理，支持多种公告类型和定向推送策略。

#### 详细功能

| 子功能 | 详细描述 | 操作流程 |
|--------|----------|----------|
| 公告创建 | 创建系统公告内容 | 编写公告内容→设置类型→选择推送范围 |
| 定时发布 | 公告定时发布控制 | 设置发布时间→系统自动发布→推送通知 |
| 推送管理 | 公告推送策略配置 | 选择推送对象→设置推送方式→执行推送 |
| 阅读统计 | 公告阅读情况统计 | 收集阅读数据→生成统计报告→分析效果 |
| 公告分类 | 公告类型分类管理 | 设置公告类型→配置显示样式→分类展示 |

#### 业务规则
- 公告类型：系统通知、维护公告、版本更新、安全警告
- 推送范围：全体用户、指定应用用户、特定用户组
- 优先级设置：高、中、低三个级别，影响显示顺序
- 有效期控制：可设置公告有效期，过期自动隐藏
- 强制阅读：重要公告可设置为强制阅读，用户必须确认

### 3.6 日志审计模块

#### 核心定位
系统操作日志的记录、存储、查询及分析，提供完整的审计追踪能力。

#### 详细功能

| 子功能 | 详细描述 | 操作流程 |
|--------|----------|----------|
| 操作记录 | 用户操作行为记录 | 拦截操作→记录详情→异步存储 |
| 日志查询 | 多维度日志检索 | 设置查询条件→执行搜索→展示结果 |
| 统计分析 | 日志数据统计分析 | 聚合数据→生成图表→导出报告 |
| 日志导出 | 日志数据批量导出 | 选择导出范围→格式转换→下载文件 |
| 自动清理 | 历史日志自动清理 | 设置清理策略→定时执行→释放空间 |

#### 业务规则
- 日志级别：DEBUG、INFO、WARNING、ERROR、CRITICAL
- 记录内容：操作时间、用户ID、IP地址、操作类型、详细描述
- 存储策略：热数据保留30天，冷数据保留1年
- 导出格式：CSV、JSON、Excel格式
- 清理策略：超过保留期的日志自动归档或删除

## 4. 模块联动关系

### 4.1 联动关系矩阵

| 触发模块 | 目标模块 | 联动事件 | 触发条件 | 执行动作 |
|----------|----------|----------|----------|----------|
| 用户认证 | 日志审计 | 登录事件 | 用户登录/登出 | 记录认证日志 |
| 卡密管理 | 设备管理 | 激活事件 | 卡密激活成功 | 创建设备绑定 |
| 应用管理 | 公告管理 | 维护事件 | 应用进入维护模式 | 推送维护公告 |
| 设备管理 | 日志审计 | 异常事件 | 设备异常行为 | 记录安全日志 |
| 公告管理 | 用户认证 | 推送事件 | 公告发布 | WebSocket推送 |
| 卡密管理 | 公告管理 | 过期事件 | 卡密即将过期 | 推送过期提醒 |

### 4.2 核心业务流程

#### 4.2.1 卡密激活完整流程

```mermaid
sequenceDiagram
    participant U as 用户客户端
    participant A as 认证模块
    participant C as 卡密模块
    participant D as 设备模块
    participant L as 日志模块
    participant N as 公告模块
    
    U->>A: 1. 用户登录
    A->>L: 2. 记录登录日志
    U->>C: 3. 提交卡密激活
    C->>C: 4. 验证卡密有效性
    C->>D: 5. 检查设备绑定限制
    D->>D: 6. 生成设备指纹
    D->>C: 7. 返回设备信息
    C->>D: 8. 创建设备绑定
    C->>L: 9. 记录激活日志
    C->>N: 10. 触发激活成功公告
    N->>U: 11. WebSocket推送通知
    C->>U: 12. 返回激活结果
```

#### 4.2.2 应用维护模式联动流程

```mermaid
sequenceDiagram
    participant Admin as 管理员
    participant App as 应用模块
    participant Ann as 公告模块
    participant Auth as 认证模块
    participant WS as WebSocket
    participant Users as 在线用户
    
    Admin->>App: 1. 开启维护模式
    App->>Ann: 2. 触发维护公告创建
    Ann->>WS: 3. 推送维护公告
    WS->>Users: 4. 通知所有在线用户
    App->>Auth: 5. 设置登录限制
    Auth->>Auth: 6. 拒绝新用户登录
    App->>App: 7. 更新应用状态
```

### 4.3 事件总线机制

#### 4.3.1 事件类型定义

```python
from enum import Enum
from dataclasses import dataclass
from typing import Any, Dict

class EventType(Enum):
    # 用户事件
    USER_LOGIN = "user.login"
    USER_LOGOUT = "user.logout"
    USER_REGISTER = "user.register"
    
    # 应用事件
    APP_MAINTENANCE_START = "app.maintenance.start"
    APP_MAINTENANCE_END = "app.maintenance.end"
    APP_VERSION_UPDATE = "app.version.update"
    
    # 卡密事件
    CARD_KEY_ACTIVATED = "card_key.activated"
    CARD_KEY_EXPIRED = "card_key.expired"
    CARD_KEY_DISABLED = "card_key.disabled"
    
    # 设备事件
    DEVICE_REGISTERED = "device.registered"
    DEVICE_OFFLINE = "device.offline"
    DEVICE_ANOMALY = "device.anomaly"
    
    # 系统事件
    SYSTEM_BACKUP = "system.backup"
    SYSTEM_ERROR = "system.error"

@dataclass
class Event:
    type: EventType
    data: Dict[str, Any]
    user_id: str = None
    timestamp: float = None
```

#### 4.3.2 事件处理器实现

```python
import asyncio
from typing import Callable, Dict, List
from collections import defaultdict

class EventHandler:
    def __init__(self):
        self._handlers: Dict[EventType, List[Callable]] = defaultdict(list)
        self._global_handlers: List[Callable] = []
        self._event_queue = asyncio.Queue()
        self._running = False
    
    async def start(self):
        """启动事件处理器"""
        self._running = True
        await self._process_events()
    
    async def stop(self):
        """停止事件处理器"""
        self._running = False
    
    def register_handler(self, event_type: EventType, handler: Callable):
        """注册特定事件处理器"""
        self._handlers[event_type].append(handler)
    
    def register_global_handler(self, handler: Callable):
        """注册全局事件处理器"""
        self._global_handlers.append(handler)
    
    async def emit(self, event: Event):
        """发送事件"""
        await self._event_queue.put(event)
    
    async def _process_events(self):
        """处理事件队列"""
        while self._running:
            try:
                event = await asyncio.wait_for(
                    self._event_queue.get(), timeout=1.0
                )
                await self._handle_event(event)
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"事件处理错误: {e}")
    
    async def _handle_event(self, event: Event):
        """处理单个事件"""
        # 执行特定事件处理器
        for handler in self._handlers[event.type]:
            try:
                await handler(event)
            except Exception as e:
                logger.error(f"事件处理器执行错误: {e}")
        
        # 执行全局事件处理器
        for handler in self._global_handlers:
            try:
                await handler(event)
            except Exception as e:
                logger.error(f"全局事件处理器执行错误: {e}")
```

## 5. 非功能性需求

### 5.1 性能要求

| 性能指标 | 目标值 | 测量方法 |
|----------|--------|----------|
| API响应时间 | ≤300ms | 95%请求响应时间 |
| 并发用户数 | ≥1000 | 同时在线用户数 |
| 数据库查询 | ≤100ms | 单次查询平均时间 |
| WebSocket延迟 | ≤50ms | 消息推送延迟 |
| 文件上传速度 | ≥10MB/s | 大文件上传速率 |
| 内存使用率 | ≤80% | 系统运行时内存占用 |
| CPU使用率 | ≤70% | 高负载时CPU占用 |

### 5.2 可靠性要求

| 可靠性指标 | 目标值 | 保障措施 |
|------------|--------|----------|
| 系统可用性 | ≥99.9% | 集群部署、故障转移 |
| 数据完整性 | 100% | 事务控制、备份恢复 |
| 故障恢复时间 | ≤5分钟 | 自动重启、健康检查 |
| 数据备份频率 | 每日备份 | 自动备份、异地存储 |
| 错误率 | ≤0.1% | 异常处理、重试机制 |

### 5.3 安全性要求

| 安全指标 | 实现方案 | 技术细节 |
|----------|----------|----------|
| 数据传输加密 | HTTPS/WSS | TLS 1.3协议 |
| 数据存储加密 | AES-256 | 敏感数据字段加密 |
| 密码存储 | bcrypt | 加盐哈希存储 |
| 访问控制 | JWT + RBAC | 基于角色的权限控制 |
| SQL注入防护 | ORM参数化 | SQLAlchemy防注入 |
| XSS防护 | 输入验证 | 前后端数据校验 |
| CSRF防护 | Token验证 | CSRF令牌机制 |

### 5.4 扩展性要求

| 扩展维度 | 设计方案 | 实现策略 |
|----------|----------|----------|
| 水平扩展 | 微服务架构 | 服务拆分、负载均衡 |
| 数据库扩展 | 读写分离 | 主从复制、分库分表 |
| 缓存扩展 | Redis集群 | 分片存储、一致性哈希 |
| 存储扩展 | 对象存储 | 文件服务分离 |
| 功能扩展 | 插件机制 | 模块化设计 |

## 6. 兼容性与部署

### 6.1 浏览器兼容性

| 浏览器 | 最低版本 | 支持特性 |
|--------|----------|----------|
| Chrome | 90+ | 完整支持 |
| Firefox | 88+ | 完整支持 |
| Safari | 14+ | 基本支持 |
| Edge | 90+ | 完整支持 |
| IE | 不支持 | - |

### 6.2 操作系统兼容性

| 操作系统 | 版本要求 | 部署方式 |
|----------|----------|----------|
| Windows | 10+ | 原生部署/Docker |
| macOS | 10.15+ | 原生部署/Docker |
| Linux | Ubuntu 20.04+ | 原生部署/Docker |
| CentOS | 8+ | 原生部署/Docker |

### 6.3 部署配置

#### 6.3.1 开发环境部署

```bash
# 1. 克隆项目
git clone <repository-url>
cd 金鱼智盒应用授权系统

# 2. 后端环境配置
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt

# 3. 数据库初始化
alembic upgrade head
python scripts/init_data.py

# 4. 启动后端服务
python run.py

# 5. 前端环境配置
cd ../frontend
npm install
npm run dev
```

#### 6.3.2 生产环境部署

```yaml
# docker-compose.yml
version: '3.8'
services:
  backend:
    build: ./backend
    ports:
      - "77889:77889"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/authdb
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
  
  frontend:
    build: ./frontend
    ports:
      - "8990:8990"
    depends_on:
      - backend
  
  db:
    image: postgres:15
    environment:
      - POSTGRES_DB=authdb
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  postgres_data:
  redis_data:
```

### 6.4 环境变量配置

```bash
# .env 文件示例
# 数据库配置
DATABASE_URL=postgresql://username:password@localhost:5432/authdb
DATABASE_ECHO=false

# Redis配置
REDIS_URL=redis://localhost:6379/0
REDIS_PASSWORD=

# JWT配置
JWT_SECRET_KEY=your-super-secret-jwt-key
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=120
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# 加密配置
ENCRYPTION_KEY=your-32-byte-encryption-key
PASSWORD_SALT_ROUNDS=12

# 文件存储配置
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=10485760  # 10MB

# 邮件配置
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-password

# 日志配置
LOG_LEVEL=INFO
LOG_FILE=./logs/app.log
LOG_MAX_SIZE=10485760
LOG_BACKUP_COUNT=5

# 应用配置
APP_NAME=金鱼智盒授权系统
APP_VERSION=1.0.0
DEBUG=false
ALLOWED_HOSTS=localhost,127.0.0.1
CORS_ORIGINS=http://localhost:8990
```

## 7. 测试策略

### 7.1 测试分类

| 测试类型 | 覆盖范围 | 工具选择 | 目标覆盖率 |
|----------|----------|----------|------------|
| 单元测试 | 业务逻辑、工具函数 | pytest, Jest | ≥80% |
| 集成测试 | API接口、数据库 | pytest-asyncio | ≥70% |
| 端到端测试 | 用户流程 | Playwright | ≥60% |
| 性能测试 | 并发负载 | Locust | 关键接口 |
| 安全测试 | 漏洞扫描 | OWASP ZAP | 全覆盖 |

### 7.2 测试用例示例

#### 7.2.1 卡密激活测试

```python
import pytest
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

class TestCardKeyActivation:
    """卡密激活功能测试"""
    
    def test_valid_card_key_activation(self):
        """测试有效卡密激活"""
        # 准备测试数据
        card_key = "ABCD-EFGH-IJKL-MNOP"
        device_info = {
            "cpu_id": "test_cpu_123",
            "motherboard_id": "test_mb_456",
            "mac_address": "00:11:22:33:44:55"
        }
        
        # 执行激活请求
        response = client.post(
            "/api/v1/card-keys/activate",
            json={
                "card_key": card_key,
                "device_info": device_info
            },
            headers={"Authorization": "Bearer valid_token"}
        )
        
        # 验证响应
        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
        assert data["message"] == "卡密激活成功"
        assert "device_id" in data["data"]
    
    def test_invalid_card_key_activation(self):
        """测试无效卡密激活"""
        response = client.post(
            "/api/v1/card-keys/activate",
            json={
                "card_key": "INVALID-KEY",
                "device_info": {}
            },
            headers={"Authorization": "Bearer valid_token"}
        )
        
        assert response.status_code == 400
        data = response.json()
        assert data["success"] is False
        assert "无效的卡密" in data["message"]
    
    def test_duplicate_device_activation(self):
        """测试重复设备激活"""
        # 第一次激活
        self.test_valid_card_key_activation()
        
        # 第二次激活相同设备
        response = client.post(
            "/api/v1/card-keys/activate",
            json={
                "card_key": "ABCD-EFGH-IJKL-MNOP",
                "device_info": {
                    "cpu_id": "test_cpu_123",
                    "motherboard_id": "test_mb_456",
                    "mac_address": "00:11:22:33:44:55"
                }
            },
            headers={"Authorization": "Bearer valid_token"}
        )
        
        assert response.status_code == 409
        data = response.json()
        assert "设备已绑定" in data["message"]
```

#### 7.2.2 前端组件测试

```javascript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { CardKeyActivation } from '../components/CardKeyActivation';
import { AuthProvider } from '../contexts/AuthContext';

describe('CardKeyActivation Component', () => {
  const renderWithAuth = (component) => {
    return render(
      <AuthProvider>
        {component}
      </AuthProvider>
    );
  };
  
  test('renders activation form correctly', () => {
    renderWithAuth(<CardKeyActivation />);
    
    expect(screen.getByLabelText('卡密')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: '激活' })).toBeInTheDocument();
  });
  
  test('validates card key format', async () => {
    renderWithAuth(<CardKeyActivation />);
    
    const input = screen.getByLabelText('卡密');
    const button = screen.getByRole('button', { name: '激活' });
    
    // 输入无效格式
    fireEvent.change(input, { target: { value: 'invalid' } });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(screen.getByText('卡密格式不正确')).toBeInTheDocument();
    });
  });
  
  test('handles successful activation', async () => {
    // Mock API response
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({
          success: true,
          message: '激活成功',
          data: { device_id: 'test_device' }
        })
      })
    );
    
    renderWithAuth(<CardKeyActivation />);
    
    const input = screen.getByLabelText('卡密');
    const button = screen.getByRole('button', { name: '激活' });
    
    fireEvent.change(input, { target: { value: 'ABCD-EFGH-IJKL-MNOP' } });
    fireEvent.click(button);
    
    await waitFor(() => {
      expect(screen.getByText('激活成功')).toBeInTheDocument();
    });
  });
});
```

### 7.3 性能测试

```python
from locust import HttpUser, task, between

class AuthSystemUser(HttpUser):
    wait_time = between(1, 3)
    
    def on_start(self):
        """用户开始时登录"""
        response = self.client.post("/api/v1/auth/login", json={
            "username": "test_user",
            "password": "test_password"
        })
        if response.status_code == 200:
            self.token = response.json()["access_token"]
            self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(3)
    def view_dashboard(self):
        """查看仪表板"""
        self.client.get("/api/v1/dashboard", headers=self.headers)
    
    @task(2)
    def list_card_keys(self):
        """查看卡密列表"""
        self.client.get("/api/v1/card-keys", headers=self.headers)
    
    @task(1)
    def activate_card_key(self):
        """激活卡密"""
        self.client.post(
            "/api/v1/card-keys/activate",
            json={
                "card_key": "TEST-CARD-KEY-001",
                "device_info": {
                    "cpu_id": "test_cpu",
                    "motherboard_id": "test_mb",
                    "mac_address": "00:11:22:33:44:55"
                }
            },
            headers=self.headers
        )
```

## 8. 监控与运维

### 8.1 系统监控

#### 8.1.1 监控指标

| 监控类别 | 具体指标 | 告警阈值 | 监控工具 |
|----------|----------|----------|----------|
| 应用性能 | 响应时间、吞吐量、错误率 | >500ms, <100req/s, >5% | Prometheus + Grafana |
| 系统资源 | CPU、内存、磁盘、网络 | >80%, >85%, >90%, >80% | Node Exporter |
| 数据库 | 连接数、查询时间、锁等待 | >80%, >200ms, >10s | PostgreSQL Exporter |
| 缓存 | 命中率、内存使用、连接数 | <90%, >80%, >1000 | Redis Exporter |
| 业务指标 | 激活成功率、登录成功率 | <95%, <98% | 自定义指标 |

#### 8.1.2 监控配置示例

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "alert_rules.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'auth-system-backend'
    static_configs:
      - targets: ['backend:77889']
    metrics_path: '/metrics'
    scrape_interval: 10s
  
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
  
  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
  
  - job_name: 'node'
    static_configs:
      - targets: ['node-exporter:9100']
```

### 8.2 日志管理

#### 8.2.1 日志配置

```python
# logging_config.py
import logging
import logging.handlers
from pathlib import Path

def setup_logging():
    """配置日志系统"""
    log_dir = Path("logs")
    log_dir.mkdir(exist_ok=True)
    
    # 创建格式化器
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # 创建文件处理器
    file_handler = logging.handlers.RotatingFileHandler(
        log_dir / "app.log",
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.INFO)
    
    # 创建错误文件处理器
    error_handler = logging.handlers.RotatingFileHandler(
        log_dir / "error.log",
        maxBytes=10*1024*1024,
        backupCount=5
    )
    error_handler.setFormatter(formatter)
    error_handler.setLevel(logging.ERROR)
    
    # 创建控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.DEBUG)
    
    # 配置根日志器
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.DEBUG)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(error_handler)
    root_logger.addHandler(console_handler)
    
    return root_logger
```

### 8.3 备份策略

#### 8.3.1 数据备份

```bash
#!/bin/bash
# backup.sh - 数据备份脚本

BACKUP_DIR="/backup/$(date +%Y%m%d)"
DB_NAME="authdb"
DB_USER="postgres"
REDIS_HOST="localhost"
REDIS_PORT="6379"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 数据库备份
echo "开始数据库备份..."
pg_dump -h localhost -U $DB_USER -d $DB_NAME | gzip > $BACKUP_DIR/database.sql.gz

# Redis备份
echo "开始Redis备份..."
redis-cli -h $REDIS_HOST -p $REDIS_PORT --rdb $BACKUP_DIR/redis.rdb

# 文件备份
echo "开始文件备份..."
tar -czf $BACKUP_DIR/uploads.tar.gz ./uploads
tar -czf $BACKUP_DIR/logs.tar.gz ./logs

# 清理旧备份（保留30天）
find /backup -type d -mtime +30 -exec rm -rf {} +

echo "备份完成: $BACKUP_DIR"
```

#### 8.3.2 自动备份配置

```bash
# crontab配置
# 每日凌晨2点执行备份
0 2 * * * /path/to/backup.sh >> /var/log/backup.log 2>&1

# 每周日凌晨3点执行完整备份
0 3 * * 0 /path/to/full_backup.sh >> /var/log/backup.log 2>&1
```

## 9. 安全加固

### 9.1 安全配置清单

| 安全项目 | 配置要求 | 实现方式 |
|----------|----------|----------|
| HTTPS强制 | 所有HTTP请求重定向到HTTPS | Nginx配置 |
| 安全头设置 | HSTS、CSP、X-Frame-Options等 | 中间件配置 |
| 密码策略 | 复杂度要求、定期更换 | 前后端验证 |
| 会话安全 | 安全Cookie、会话超时 | JWT配置 |
| 输入验证 | 所有输入数据验证 | Pydantic模型 |
| SQL注入防护 | 参数化查询 | SQLAlchemy ORM |
| XSS防护 | 输出编码、CSP | 前端过滤 |
| CSRF防护 | Token验证 | 中间件实现 |

### 9.2 安全中间件实现

```python
from fastapi import Request, Response
from fastapi.middleware.base import BaseHTTPMiddleware
import time
import hashlib

class SecurityMiddleware(BaseHTTPMiddleware):
    """安全中间件"""
    
    def __init__(self, app, secret_key: str):
        super().__init__(app)
        self.secret_key = secret_key
        self.rate_limit = {}  # 简单的速率限制
    
    async def dispatch(self, request: Request, call_next):
        # 添加安全头
        response = await call_next(request)
        
        # 安全头设置
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = (
            "default-src 'self'; "
            "script-src 'self' 'unsafe-inline'; "
            "style-src 'self' 'unsafe-inline'; "
            "img-src 'self' data: https:;"
        )
        
        # 速率限制
        client_ip = request.client.host
        current_time = time.time()
        
        if client_ip in self.rate_limit:
            if current_time - self.rate_limit[client_ip]["last_request"] < 1:
                self.rate_limit[client_ip]["count"] += 1
                if self.rate_limit[client_ip]["count"] > 100:  # 每秒最多100请求
                    response.status_code = 429
                    response.headers["Retry-After"] = "60"
                    return response
            else:
                self.rate_limit[client_ip] = {"count": 1, "last_request": current_time}
        else:
            self.rate_limit[client_ip] = {"count": 1, "last_request": current_time}
        
        return response
```

### 9.3 数据加密实现

```python
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class DataEncryption:
    """数据加密工具类"""
    
    def __init__(self, password: str):
        self.password = password.encode()
        self.salt = os.urandom(16)
        self.key = self._derive_key()
        self.cipher = Fernet(self.key)
    
    def _derive_key(self) -> bytes:
        """派生加密密钥"""
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=self.salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.password))
        return key
    
    def encrypt(self, data: str) -> str:
        """加密数据"""
        encrypted_data = self.cipher.encrypt(data.encode())
        return base64.urlsafe_b64encode(
            self.salt + encrypted_data
        ).decode()
    
    def decrypt(self, encrypted_data: str) -> str:
        """解密数据"""
        data = base64.urlsafe_b64decode(encrypted_data.encode())
        salt = data[:16]
        encrypted = data[16:]
        
        # 重新派生密钥
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(self.password))
        cipher = Fernet(key)
        
        decrypted_data = cipher.decrypt(encrypted)
        return decrypted_data.decode()
```

## 10. 总结

### 10.1 系统特色

1. **双重验证机制**：账号密码与卡密结合，提供企业级安全保障
2. **实时通信能力**：WebSocket支持实时状态推送和公告通知
3. **模块化设计**：松耦合架构，支持功能扩展和维护
4. **完整的审计追踪**：全方位日志记录，满足合规要求
5. **高性能架构**：异步处理、缓存优化，支持高并发访问

### 10.2 技术亮点

1. **事件驱动架构**：基于事件总线的模块间通信机制
2. **安全加固**：多层次安全防护，数据加密存储
3. **监控运维**：完整的监控体系和自动化运维
4. **测试覆盖**：全面的测试策略，确保代码质量
5. **部署灵活**：支持Docker容器化部署

### 10.3 后续优化方向

1. **微服务拆分**：将单体应用拆分为微服务架构
2. **AI智能分析**：引入机器学习进行异常检测
3. **移动端支持**：开发移动端管理应用
4. **国际化支持**：多语言界面和时区支持
5. **云原生改造**：支持Kubernetes部署和服务网格

本文档为金鱼智盒卡密授权系统的完整开发指南，涵盖了系统设计、功能实现、部署运维等各个方面。开发团队可基于此文档进行系统开发和维护工作。